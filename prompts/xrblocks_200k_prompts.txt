Treat user's text input as <my_xr_experience>.
Enable Gemini Canvas mode.
Act as a expert in three.js, WebXR, WebGL, and a creative technologist. author new WebXR experiences (with *Gemini Canvas* if available): <my_xr_experience>.

<rules>
Strictly adhere to the following engineering guidelines:

1.  **SDK Integration** (CRITICAL): For HTML, you **MUST** use `https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js` (replace any local `../../sdk/xrblocks.js` references).
2.  **Styling**: USE `https://xrblocks.github.io/css/xr.css` for XR Blocks.
3.  **Architecture**: Output a SINGLE `index.html` file. Embed `main.js` logic inline within `<script type="module">`.
4.  **Framework**: Build the project by referencing the provided XRBlocks SDK and three.js version.
5. Here are some XRBlocks **templates** that help you get started...
6.  **UI/Text**: For text rendering, follow the `1_ui` pattern to import and use `troika-three-text` for crisp XR legibility.
7.  **Performance**: Do NOT import TensorFlow libraries unless the request explicitly requires custom gestures or Machine Learning.
8.  **Spatial Layout**:
    * **Scenes**: Ensure users can freely walk physically within the scene (world scale).
    * **Objects**: Place objects in front of the user at a reasonable physical size.
9.  **Model Interaction**: If the experience involves viewing a model, you **MUST** use XR Blocks's `ModelViewer` (refer to `samples/modelviewer`). Ensure users can drag the platform to move it and rotate the model by dragging the object itself.
10. **Standard Coordinates**: For a primary demo model, initialize it at `position.set(0, this.user.height - 0.5, -this.user.objectDistance)` and wrap it with `ModelViewer`.
11. **Gemini**: if user requests Gemini Live and AI features, add `// Provided by the environment
  const API_KEY = ""; `, then link this empty key to `ai` module, so Gemini Canvas will auto-populate the API keys.
</rules>


Template: 0_basic
(example: ../xrblocks/templates/0_basic/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Basic: Pinch to Set Color | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/0_basic/main.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

/**
 * A basic example of XRBlocks to render a cylinder and pinch to change color.
 */
class MainScript extends xb.Script {
  init() {
    this.add(new THREE.HemisphereLight(0xffffff, 0x666666, /*intensity=*/ 3));

    const geometry = new THREE.CylinderGeometry(
      0.2,
      0.2,
      0.4,
      /*segments=*/ 32
    );
    const material = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
    });
    this.player = new THREE.Mesh(geometry, material);
    this.player.position.set(0, xb.user.height - 0.5, -xb.user.objectDistance);
    this.add(this.player);
  }

  /**
   * Changes the color of the mesh on a pinch in XR.
   * @param {SelectEvent} event event.target holds controler / hand data.
   */
  onSelectEnd(event) {
    this.player.material.color.set(Math.random() * 0xffffff);
  }

  /**
   * Changes the color of the mesh to blue during pinching in XR.
   * @param {SelectEvent} event The controller / hand event.
   */
  onSelecting(event) {
    this.player.material.color.set(0x66ccff);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  xb.add(new MainScript());
  xb.init(new xb.Options());
});



Template: 1_ui
(example: ../xrblocks/templates/1_ui/UIManager.js)
import * as xb from 'xrblocks';

/**
 * Rending a draggable spatial UI panel with SDF font libraries, and icons
 * buttons using XR Blocks.
 */
export class UIManager extends xb.Script {
  constructor() {
    super();

    // Adds an interactive SpatialPanel as a container for UI elements.
    const panel = new xb.SpatialPanel({backgroundColor: '#2b2b2baa'});
    this.add(panel);

    const grid = panel.addGrid();
    // `weight` defines the perentage of a view's dimension to its parent.
    // Here, question occupies 70% of the height of the panel.
    const question = grid.addRow({weight: 0.7}).addText({
      text: 'Welcome to UI Playground! Is it your first time here?',
      fontColor: '#ffffff',
      fontSize: 0.08,
    });
    this.question = question;

    // ctrlRow occupies 30% of the height of the panel.
    const ctrlRow = grid.addRow({weight: 0.3});

    // The `text` field defines the icon of the button from Material Icons in
    // https://fonts.google.com/icons
    const yesButton = ctrlRow
      .addCol({weight: 0.5})
      .addIconButton({text: 'check_circle', fontSize: 0.5});

    // onTriggered defines unified behavior for `onSelected`, `onClicked`,
    // `onPinched`, `onTouched` for buttons.
    yesButton.onTriggered = () => {
      this._onYes();
    };

    const noButton = ctrlRow
      .addCol({weight: 0.5})
      .addIconButton({text: 'cancel', fontSize: 0.5});

    noButton.onTriggered = () => {
      this._onNo();
    };
  }

  _onYes() {
    console.log('yes');
  }

  _onNo() {
    console.log('no');
  }
}

(example: ../xrblocks/templates/1_ui/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>UI: Spatial Panels | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js?version=2"></script>
  </body>
</html>

(example: ../xrblocks/templates/1_ui/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {UIManager} from './UIManager.js';

const options = new xb.Options();
options.enableUI();

document.addEventListener('DOMContentLoaded', function () {
  xb.add(new UIManager());
  xb.init(options);
});



Template: 2_hands
(example: ../xrblocks/templates/2_hands/HandsInteraction.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

export class HandsInteraction extends xb.Script {
  init() {
    // Touch state.
    this.leftHandTouching = false;
    this.rightHandTouching = false;

    // Grab state.
    this.isGrabbing = false;
    this._handToObject = null;

    // Add a cylinder to touch and grab.
    this.originalColor = new THREE.Color(0xfbbc05);
    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 32).translate(
      0,
      1.45,
      -0.4
    );
    const material = new THREE.MeshPhongMaterial({color: this.originalColor});
    this.target = new THREE.Mesh(geometry, material);
    this.add(this.target);

    // Add a light.
    this.add(new THREE.HemisphereLight(0xbbbbbb, 0x888888, 3));
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(1, 1, 1).normalize();
    this.add(light);
  }

  _updateColor() {
    if (this.leftHandTouching && this.rightHandTouching) {
      this.target.material.color.setHex(0xdb4437); // Red
    } else if (this.leftHandTouching) {
      this.target.material.color.setHex(0x34a853); // Green
    } else if (this.rightHandTouching) {
      this.target.material.color.setHex(0x4285f4); // Blue
    } else {
      this.target.material.color.copy(this.originalColor); // Yellow
    }
  }

  onObjectTouchStart(event) {
    const handName = event.handIndex === xb.Handedness.LEFT ? 'left' : 'right';
    console.log(`Touch started with ${handName} hand!`);

    if (event.handIndex === xb.Handedness.LEFT) {
      this.leftHandTouching = true;
    } else if (event.handIndex === xb.Handedness.RIGHT) {
      this.rightHandTouching = true;
    }
    this._updateColor();
  }

  onObjectTouchEnd(event) {
    const handName = event.handIndex === xb.Handedness.LEFT ? 'left' : 'right';
    console.log(`Touch ended with ${handName} hand!`);

    if (event.handIndex === xb.Handedness.LEFT) {
      this.leftHandTouching = false;
    } else if (event.handIndex === xb.Handedness.RIGHT) {
      this.rightHandTouching = false;
    }
    this._updateColor();
  }

  onObjectGrabStart(event) {
    if (this.isGrabbing) return;
    this.isGrabbing = true;

    const handName = event.handIndex === xb.Handedness.LEFT ? 'left' : 'right';
    console.log(`Grab started with ${handName} hand!`);

    // Make sure matrices are fresh.
    this.target.updateMatrixWorld(true);
    event.hand.updateMatrixWorld(true);

    // Save the initial hand to object delta transform.
    const H0 = new THREE.Matrix4().copy(event.hand.matrixWorld);
    const O0 = new THREE.Matrix4().copy(this.target.matrixWorld);
    this._handToObject = new THREE.Matrix4().copy(H0).invert().multiply(O0);
  }

  onObjectGrabbing(event) {
    if (!this.isGrabbing || !this._handToObject) return;

    event.hand.updateMatrixWorld(true);
    const H = new THREE.Matrix4().copy(event.hand.matrixWorld);
    const O = new THREE.Matrix4().multiplyMatrices(H, this._handToObject);
    const parent = this.target.parent;
    if (parent) parent.updateMatrixWorld(true);
    const parentInv = parent
      ? new THREE.Matrix4().copy(parent.matrixWorld).invert()
      : new THREE.Matrix4().identity();

    const Olocal = new THREE.Matrix4().multiplyMatrices(parentInv, O);
    const pos = new THREE.Vector3();
    const quat = new THREE.Quaternion();
    const scl = new THREE.Vector3();
    Olocal.decompose(pos, quat, scl);

    this.target.position.copy(pos);
    this.target.quaternion.copy(quat);

    this.target.updateMatrix();
  }

  onObjectGrabEnd(event) {
    if (!this.isGrabbing) return;
    const handName = event.handIndex === xb.Handedness.LEFT ? 'left' : 'right';
    console.log(`Grab ended with ${handName} hand!`);

    this.isGrabbing = false;
    this._handToObject = null;
  }
}

(example: ../xrblocks/templates/2_hands/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Hands: Mesh and Touch | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js?version=2"></script>
  </body>
</html>

(example: ../xrblocks/templates/2_hands/main.js)
// Provides optional 2D UIs for simulator on desktop.
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {HandsInteraction} from './HandsInteraction.js';

const options = new xb.Options();
options.enableReticles();
options.enableHands();

options.hands.enabled = true;
options.hands.visualization = true;
// Visualize hand joints.
options.hands.visualizeJoints = true;
// Visualize hand meshes.
options.hands.visualizeMeshes = true;

options.simulator.defaultMode = xb.SimulatorMode.POSE;

function start() {
  xb.add(new HandsInteraction());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});



Template: 3_depth
(example: ../xrblocks/templates/3_depth/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Depth | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/3_depth/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as THREE from 'three';
import * as xb from 'xrblocks';

const pawnModelPath =
  'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/models/arcore_pawn_compressed.glb';

class PawnPlacer extends xb.Script {
  async init() {
    this.addLights();
    await this.loadPawnModel();
  }

  async loadPawnModel() {
    const pawnGltf = await new xb.ModelLoader().load({
      url: pawnModelPath,
      renderer: xb.core.renderer,
    });
    pawnGltf.scene.scale.setScalar(0.5);
    this.pawnModel = pawnGltf.scene;
  }

  addLights() {
    const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
    directionalLight.position.set(0, 1, 0);
    this.add(directionalLight);
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    this.add(ambientLight);
  }

  onSelectStart(event) {
    const intersection = xb.user.select(xb.core.depth.depthMesh, event.target);
    if (intersection) {
      this.add(
        xb.placeObjectAtIntersectionFacingTarget(
          this.pawnModel.clone(),
          intersection,
          xb.core.camera
        )
      );
    }
  }
}

document.addEventListener('DOMContentLoaded', async function () {
  const options = new xb.Options();
  options.reticles.enabled = true;
  options.depth = new xb.DepthOptions(xb.xrDepthMeshOptions);
  await xb.init(options);
  xb.showReticleOnDepthMesh(true);
  xb.add(new PawnPlacer());
});



Template: 4_stereo
(example: ../xrblocks/templates/4_stereo/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Stereo | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/4_stereo/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as THREE from 'three';
import * as xb from 'xrblocks';

const stereoTextureFile = 'SV_20241216_144600.webp';

class StereoImage extends xb.Script {
  async init() {
    await this.addStereoQuad();
  }

  async addStereoQuad() {
    const stereoObject = new THREE.Group();
    const [leftTexture, rightTexture] =
      await xb.loadStereoImageAsTextures(stereoTextureFile);
    const geometry = new THREE.PlaneGeometry(1, 1);
    const leftMesh = new THREE.Mesh(
      geometry,
      new THREE.MeshBasicMaterial({
        map: leftTexture,
        side: THREE.DoubleSide,
      })
    );

    xb.showOnlyInLeftEye(leftMesh);
    stereoObject.add(leftMesh);
    const rightMesh = new THREE.Mesh(
      geometry,
      new THREE.MeshBasicMaterial({
        map: rightTexture,
        side: THREE.DoubleSide,
      })
    );

    xb.showOnlyInRightEye(rightMesh);
    stereoObject.add(rightMesh);
    stereoObject.position.set(0.0, 1.5, -1.5);
    this.add(stereoObject);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.simulator.stereo.enabled = true;
  xb.add(new StereoImage());
  xb.init(options);
});



Template: 5_camera
(example: ../xrblocks/templates/5_camera/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Camera | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js?version=2"></script>
  </body>
</html>

(example: ../xrblocks/templates/5_camera/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

/**
 * A class that provides UI to display and cycle through device cameras.
 */
export class CameraViewManager extends xb.Script {
  /** @private {XRDeviceCamera|null} */
  cameraStream_ = null;

  constructor() {
    super();
    this.panel = new xb.SpatialPanel({
      backgroundColor: '#2b2b2baa',
      useDefaultPosition: true,
    });
    const grid = this.panel.addGrid();
    this.videoView = grid.addRow({weight: 0.7}).addVideo();
    const txtRow = grid.addRow({weight: 0.15});
    this.cameraLabel = txtRow
      .addCol({weight: 1})
      .addText({text: 'Camera', fontColor: '#ffffff', fontSize: 0.05});
    const ctrlRow = grid.addRow({weight: 0.2});
    this.prevCameraButton = ctrlRow.addCol({weight: 0.5}).addIconButton({
      text: 'skip_previous',
      fontSize: 0.5,
    });
    this.nextCameraButton = ctrlRow.addCol({weight: 0.5}).addIconButton({
      text: 'skip_next',
      fontSize: 0.5,
    });

    this.prevCameraButton.onTriggered = () => this.cycleCamera_(-1);
    this.nextCameraButton.onTriggered = () => this.cycleCamera_(1);

    this.add(this.panel);
  }

  async init() {
    this.cameraStream_ = xb.core.deviceCamera;

    // Listen for camera state changes to update UI
    this.cameraStream_.addEventListener('statechange', (event) => {
      this.cameraLabel.setText(event.device?.label || event.state || 'Camera');
      if (event.state === 'streaming') {
        this.videoView.load(this.cameraStream_);
      }
    });
    this.cameraLabel.setText(
      this.cameraStream_.getCurrentDevice()?.label || 'Camera'
    );
    this.videoView.load(this.cameraStream_);
  }

  /**
   * Cycle to the next or previous device.
   * @param {number} offset - The direction to cycle (-1 for prev, 1 for next).
   */
  async cycleCamera_(offset) {
    const devices = this.cameraStream_.getAvailableDevices();
    if (devices.length <= 1) return;
    const newIndex =
      (this.cameraStream_.getCurrentDeviceIndex() + offset + devices.length) %
      devices.length;
    await this.cameraStream_.setDeviceId(devices[newIndex].deviceId);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.enableUI();
  options.enableCamera();
  xb.add(new CameraViewManager());
  xb.init(options);
});



Template: 6_ai
(example: ../xrblocks/templates/6_ai/GeminiQueryManager.js)
import * as xb from 'xrblocks';

export class GeminiQueryManager extends xb.Script {
  constructor() {
    super();
    this.panel = null;
    this.isProcessing = false;
    this.responseDisplay = null;
  }

  init() {
    this.ai = xb.core.ai;

    this.createPanel();
  }

  createPanel() {
    this.panel = new xb.SpatialPanel({
      width: 2.5,
      height: 1.5,
      backgroundColor: '#1a1a1abb',
    });
    this.panel.position.set(0, 1.6, -2);
    this.add(this.panel);

    const grid = this.panel.addGrid();

    // Response area
    const responseRow = grid.addRow({weight: 0.8});
    this.responseDisplay = new xb.ScrollingTroikaTextView({
      text: '',
      fontSize: 0.04,
    });
    responseRow.add(this.responseDisplay);

    const buttonRow = grid.addRow({weight: 0.2});
    const textCol = buttonRow.addCol({weight: 0.5});
    const textButton = textCol.addTextButton({
      text: 'Ask about WebXR',
      fontColor: '#ffffff',
      backgroundColor: '#4285f4',
      fontSize: 0.24,
    });

    const imageCol = buttonRow.addCol({weight: 0.5});
    const imageButton = imageCol.addTextButton({
      text: 'Send Sample Image',
      fontColor: '#ffffff',
      backgroundColor: '#34a853',
      fontSize: 0.24,
    });

    textButton.onTriggered = () => this.askText();
    imageButton.onTriggered = () => this.askImage();
  }

  async ask(parts, displayText) {
    if (this.isProcessing || !this.ai?.isAvailable()) return;

    this.isProcessing = true;
    this.responseDisplay.addText(displayText);

    try {
      const response = await this.ai.query({
        type: 'multiPart',
        parts: parts,
      });
      this.responseDisplay.addText(`ü§ñ AI: ${response.text}\n\n`);
    } catch (error) {
      this.responseDisplay.addText(`‚ùå Error: ${error.message}\n\n`);
    }

    this.isProcessing = false;
  }

  askText() {
    const question = 'Hello! What is WebXR?';
    const parts = [{text: question + ' reply succinctly.'}];
    const displayText = `üí¨ You: ${question}\n\n`;
    this.ask(parts, displayText);
  }

  askImage() {
    const question = 'What do you see in this image?';
    const image = {
      inlineData: {
        data: 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==',
        mimeType: 'image/png',
      },
    };
    const parts = [image, {text: question}];
    const displayText = `üí¨ You: ${question}\nüì∏ [Sample image sent]\n\n`;
    this.ask(parts, displayText);
  }
}

(example: ../xrblocks/templates/6_ai/index.html)
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>XR Blocks - AI Query Demo</title>
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/6_ai/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {GeminiQueryManager} from './GeminiQueryManager.js';

const options = new xb.Options();
options.enableUI();
options.enableAI();

function start() {
  try {
    xb.init(options);
    xb.add(new GeminiQueryManager());
  } catch (error) {
    console.error('Failed to initialize XR app:', error);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});



Template: 7_ai_live
(example: ../xrblocks/templates/7_ai_live/GeminiManager.js)
import * as xb from 'xrblocks';

import {TranscriptionManager} from './TranscriptionManager.js';

export class GeminiManager extends xb.Script {
  constructor() {
    super();
    this.xrDeviceCamera = null;
    this.transcription = null;
    this.ai = null;
    this.isAIRunning = false;
    this.screenshotInterval = null;
    this.defaultText = '';
  }

  init() {
    this.xrDeviceCamera = xb.core.deviceCamera;
    this.ai = xb.core.ai;
    this.createTextDisplay();
  }

  async toggleGeminiLive() {
    return this.isAIRunning ? this.stopGeminiLive() : this.startGeminiLive();
  }

  async startGeminiLive() {
    if (this.isAIRunning || !this.ai) return;
    try {
      await xb.core.sound.enableAudio();
      await this.startLiveAI();
      this.startScreenshotCapture();
      this.isAIRunning = true;
      this.updateButtonState();
    } catch (error) {
      console.error('Failed to start AI session:', error);
      this.transcription?.addText(
        'Error: Failed to start AI session - ' + error.message
      );
      this.cleanup();
      this.isAIRunning = false;
      this.updateButtonState();
    }
  }

  async stopGeminiLive() {
    if (!this.isAIRunning) return;
    await this.ai?.stopLiveSession?.();
    this.cleanup();
    this.isAIRunning = false;
    this.updateButtonState();
    this.transcription?.clear();
    this.transcription?.setText(this.defaultText);
  }

  async startLiveAI() {
    return new Promise((resolve, reject) => {
      this.ai.setLiveCallbacks({
        onopen: resolve,
        onmessage: (message) => this.handleAIMessage(message),
        onerror: reject,
        onclose: (closeEvent) => {
          this.cleanup();
          this.isAIRunning = false;
          this.updateButtonState();
          this.transcription?.clear();
          this.transcription?.setText(closeEvent.reason || this.defaultText);
        },
      });
      this.ai.startLiveSession().catch(reject);
    });
  }

  createTextDisplay() {
    this.textPanel = new xb.SpatialPanel({
      width: 3,
      height: 1.5,
      backgroundColor: '#1a1a1abb',
    });
    const grid = this.textPanel.addGrid();

    const responseDisplay = new xb.ScrollingTroikaTextView({
      text: this.defaultText,
      fontSize: 0.03,
      textAlign: 'left',
    });
    grid.addRow({weight: 0.7}).add(responseDisplay);
    this.transcription = new TranscriptionManager(responseDisplay);

    this.toggleButton = grid.addRow({weight: 0.3}).addTextButton({
      text: '‚ñ∂ Start',
      fontColor: '#ffffff',
      backgroundColor: '#006644',
      fontSize: 0.2,
    });
    this.toggleButton.onTriggered = () => this.toggleGeminiLive();

    this.textPanel.position.set(0, 1.2, -2);
    this.add(this.textPanel);
  }

  handleAIMessage(message) {
    message.data && xb.core.sound.playAIAudio(message.data);

    const content = message.serverContent;
    if (content) {
      content.inputTranscription?.text &&
        this.transcription.handleInputTranscription(
          content.inputTranscription.text
        );
      content.outputTranscription?.text &&
        this.transcription.handleOutputTranscription(
          content.outputTranscription.text
        );
      content.turnComplete && this.transcription.finalizeTurn();
    }
  }

  startScreenshotCapture() {
    this.screenshotInterval = setInterval(() => {
      const base64Image = this.xrDeviceCamera?.getSnapshot({
        outputFormat: 'base64',
        mimeType: 'image/jpeg',
        quality: 1,
      });
      if (base64Image) {
        const base64Data = base64Image.startsWith('data:')
          ? base64Image.split(',')[1]
          : base64Image;
        try {
          this.ai?.sendRealtimeInput?.({
            video: {data: base64Data, mimeType: 'image/jpeg'},
          });
        } catch (error) {
          console.warn(error);
          this.stopGeminiLive();
        }
      }
    }, 1000);
  }

  updateButtonState() {
    this.toggleButton?.setText(this.isAIRunning ? '‚èπ Stop' : '‚ñ∂ Start');
  }

  cleanup() {
    if (this.screenshotInterval) {
      clearInterval(this.screenshotInterval);
      this.screenshotInterval = null;
    }
    xb.core.sound?.disableAudio();
    xb.core.sound?.stopAIAudio();
  }

  dispose() {
    this.cleanup();
    super.dispose();
  }
}

(example: ../xrblocks/templates/7_ai_live/TranscriptionManager.js)
export class TranscriptionManager {
  constructor(responseDisplay) {
    this.responseDisplay = responseDisplay;
    this.currentInputText = '';
    this.currentOutputText = '';
    this.conversationHistory = [];
  }

  handleInputTranscription(text) {
    if (!text) return;
    this.currentInputText += text;
    this.updateLiveDisplay();
  }

  handleOutputTranscription(text) {
    if (!text) return;
    this.currentOutputText += text;
    this.updateLiveDisplay();
  }

  finalizeTurn() {
    if (this.currentInputText.trim()) {
      this.conversationHistory.push({
        speaker: 'You',
        text: this.currentInputText.trim(),
      });
    }
    if (this.currentOutputText.trim()) {
      this.conversationHistory.push({
        speaker: 'AI',
        text: this.currentOutputText.trim(),
      });
    }
    this.currentInputText = '';
    this.currentOutputText = '';
    this.updateFinalDisplay();
  }

  updateLiveDisplay() {
    let displayText = '';
    for (const entry of this.conversationHistory.slice(-2)) {
      displayText += `${entry.speaker}: ${entry.text}\n\n`;
    }
    if (this.currentInputText.trim()) {
      displayText += `You: ${this.currentInputText}`;
    }
    if (this.currentOutputText.trim()) {
      if (this.currentInputText.trim()) displayText += '\n\n';
      displayText += `AI: ${this.currentOutputText}`;
    }
    this.responseDisplay?.setText(displayText);
  }

  updateFinalDisplay() {
    let displayText = '';
    for (const entry of this.conversationHistory) {
      displayText += `${entry.speaker}: ${entry.text}\n\n`;
    }
    this.responseDisplay?.setText(displayText);
  }

  clear() {
    this.currentInputText = '';
    this.currentOutputText = '';
    this.conversationHistory = [];
  }

  addText(text) {
    this.responseDisplay?.addText(text + '\n\n');
  }

  setText(text) {
    this.responseDisplay?.setText(text);
  }
}

(example: ../xrblocks/templates/7_ai_live/index.html)
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>XR Blocks - Gemini Live AI Demo</title>
    <link type="text/css" rel="stylesheet" href="../../site/css/demo.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/7_ai_live/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {GeminiManager} from './GeminiManager.js';

const options = new xb.Options();
options.enableUI();
options.enableHands();
options.enableAI();
options.enableCamera();
options.deviceCamera = new xb.DeviceCameraOptions({
  enabled: true,
  videoConstraints: {
    width: {ideal: 1280},
    height: {ideal: 720},
    facingMode: 'environment',
  },
});

async function requestAudioPermission() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: 16000,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true,
      },
    });
    stream.getTracks().forEach((track) => track.stop());
    return stream;
  } catch (error) {
    console.error('Audio permission denied or not available:', error);
    alert(
      'Audio permission is required for Gemini Live AI features. Please enable microphone access and refresh the page.'
    );
    return null;
  }
}

async function start() {
  try {
    await requestAudioPermission();
    xb.init(options);
    xb.add(new GeminiManager());
  } catch (error) {
    console.error('Failed to initialize XR app:', error);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});



Template: 8_objects
(example: ../xrblocks/templates/8_objects/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>World Component: Object Detection | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/8_objects/main.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

/**
 * A basic example of using the XR Blocks SDK's world component to detect
 * objects in the real world using Gemini.
 */
class MainScript extends xb.Script {
  init() {
    this.add(new THREE.HemisphereLight(0xffffff, 0x666666, /*intensity=*/ 3));
  }

  /**
   * Runs object detection on select (click in simulator, pinch in XR device).
   * The results of the detection are automatically handled by the
   * ObjectDetector, which will create debug visuals for each detected object.
   * This behavior is enabled when `showDebugVisualizations` is set to true.
   * @param {XRInputSourceEvent} event event.target holds controller or hand
   * data.
   */
  async onSelectEnd() {
    console.log('Running object detection...');
    const detectedObjects = await xb.world.objects.runDetection();

    // `detectedObjects` is an array of THREE.Object3D instances, each
    // representing a detected object. These objects contain the 3D world
    // position and other metadata returned by the detection model.
    if (detectedObjects.length > 0) {
      console.log('Detected objects:', detectedObjects);
    } else {
      console.log('No objects detected.');
    }
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();

  // AI is required for the object detection backend. Please set your
  options.enableAI();

  // Enable the environment camera to provide the video feed to the AI module.
  options.enableCamera('environment');

  // Depth is required to project the 2D detections from the AI module into 3D.
  options.enableDepth();

  // Enable the object detection feature and its debug visualizations.
  options.world.enableObjectDetection();
  options.world.objects.showDebugVisualizations = true;

  xb.add(new MainScript());
  xb.init(options);
});



Template: 9_xr-toggle
(example: ../xrblocks/templates/9_xr-toggle/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Transition between AR and VR | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/9_xr-toggle/main.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

/**
 * Demonstrates how to use the XRTransition component to smoothly switch
 * between AR and VR backgrounds.
 */
class MainScript extends xb.Script {
  init() {
    this.add(new THREE.HemisphereLight(0xffffff, 0x666666, /*intensity=*/ 3));

    const geometry = new THREE.CylinderGeometry(
      0.2,
      0.2,
      0.4,
      /*segments=*/ 32
    );
    const material = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
    });
    this.cylinder = new THREE.Mesh(geometry, material);
    this.cylinder.position.set(
      0,
      xb.core.user.height - 0.5,
      -xb.core.user.objectDistance
    );
    this.add(this.cylinder);
  }

  /**
   * On pinch, toggle between AR and VR modes and update cylinder color.
   */
  onSelectEnd() {
    if (!xb.core.transition) {
      console.warn('XRTransition not enabled.');
      return;
    }
    this.cylinder.material.color.set(Math.random() * 0xffffff);

    // Toggle between AR and VR based on the current mode.
    if (xb.core.transition.currentMode === 'AR') {
      xb.core.transition.toVR({color: Math.random() * 0xffffff});
    } else {
      xb.core.transition.toAR();
    }
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options().enableXRTransitions();
  xb.add(new MainScript());
  xb.init(options);
});



Template: heuristic_hand_gestures
(example: ../xrblocks/templates/heuristic_hand_gestures/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Gestures: Heuristic Logging | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js?version=2"></script>
  </body>
</html>

(example: ../xrblocks/templates/heuristic_hand_gestures/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

const options = new xb.Options();
options.enableReticles();
options.enableGestures();

options.gestures.setGestureEnabled('point', true);
options.gestures.setGestureEnabled('spread', true);

options.hands.enabled = true;
options.hands.visualization = true;
options.hands.visualizeJoints = true;
options.hands.visualizeMeshes = true;

options.simulator.defaultMode = xb.SimulatorMode.POSE;

class GestureLogger extends xb.Script {
  init() {
    const gestures = xb.core.gestureRecognition;
    if (!gestures) {
      console.warn(
        '[GestureLogger] GestureRecognition is unavailable. ' +
          'Make sure options.enableGestures() is called before xb.init().'
      );
      return;
    }
    this._onGestureStart = (event) => {
      const {hand, name, confidence = 0} = event.detail;
      console.log(
        `[gesture] ${hand} hand started ${name} (${confidence.toFixed(2)})`
      );
    };
    this._onGestureEnd = (event) => {
      const {hand, name} = event.detail;
      console.log(`[gesture] ${hand} hand ended ${name}`);
    };
    gestures.addEventListener('gesturestart', this._onGestureStart);
    gestures.addEventListener('gestureend', this._onGestureEnd);
  }

  dispose() {
    const gestures = xb.core.gestureRecognition;
    if (!gestures) return;
    if (this._onGestureStart) {
      gestures.removeEventListener('gesturestart', this._onGestureStart);
    }
    if (this._onGestureEnd) {
      gestures.removeEventListener('gestureend', this._onGestureEnd);
    }
  }
}

function start() {
  xb.add(new GestureLogger());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', () => {
  start();
});



Template: meshes
(example: ../xrblocks/templates/meshes/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Meshes | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/meshes/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

document.addEventListener('DOMContentLoaded', async function () {
  const options = new xb.Options();
  options.reticles.enabled = true;
  options.world.enableMeshDetection();
  options.world.meshes.showDebugVisualizations = true;
  await xb.init(options);
});



Template: planes
(example: ../xrblocks/templates/planes/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Planes | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/templates/planes/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

document.addEventListener('DOMContentLoaded', async function () {
  const options = new xb.Options();
  options.reticles.enabled = true;
  options.world.enablePlaneDetection();
  options.world.planes.showDebugVisualizations = true;
  await xb.init(options);
});



Template: uikit
(example: ../xrblocks/templates/uikit/MaterialSymbolsIcon.js)
import {Svg} from '@pmndrs/uikit';
import {computed} from '@preact/signals-core';

const SVG_BASE_PATH =
  'https://cdn.jsdelivr.net/gh/marella/material-symbols@v0.38.0/svg/{{weight}}/{{style}}/{{icon}}.svg';

export class MaterialSymbolsIcon extends Svg {
  name = 'Material Symbols Icon';
  constructor(properties, initialClasses, config) {
    const icon = properties?.icon ?? config?.defaultOverrides?.icon;
    const iconStyle =
      properties?.iconStyle ?? config?.defaultOverrides?.iconStyle;
    const iconWeight =
      properties?.iconWeight ?? config?.defaultOverrides?.iconWeight;

    const svgPath = computed(() => {
      const finalIcon = icon?.value ?? icon ?? 'question_mark';
      const finalStyle = iconStyle?.value ?? iconStyle ?? 'outlined';
      const finalWeight = iconWeight?.value ?? iconWeight ?? 400;

      return SVG_BASE_PATH.replace('{{style}}', finalStyle)
        .replace('{{icon}}', finalIcon)
        .replace('{{weight}}', String(finalWeight));
    });

    super(properties, initialClasses, {
      ...config,
      defaultOverrides: {
        src: svgPath,
        ...config?.defaultOverrides,
      },
    });
  }
}

(example: ../xrblocks/templates/uikit/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>XR Blocks x @pmndrs/uikit Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/": "https://cdn.jsdelivr.net/npm/three@0.182.0/",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "@pmndrs/uikit": "https://cdn.jsdelivr.net/npm/@pmndrs/uikit@1.0.56/dist/index.min.js",
          "@pmndrs/uikit-pub-sub": "https://cdn.jsdelivr.net/npm/@pmndrs/uikit-pub-sub@1.0.56/dist/index.min.js",
          "@pmndrs/msdfonts": "https://cdn.jsdelivr.net/npm/@pmndrs/msdfonts@1.0.56/dist/index.min.js",
          "@preact/signals-core": "https://cdn.jsdelivr.net/npm/@preact/signals-core@1.12.1/dist/signals-core.mjs",
          "yoga-layout/load": "https://cdn.jsdelivr.net/npm/yoga-layout@3.2.1/dist/src/load.js",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js?version=2"></script>
  </body>
</html>

(example: ../xrblocks/templates/uikit/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';
import * as uikit from '@pmndrs/uikit';
import * as xb from 'xrblocks';

import {MaterialSymbolsIcon} from './MaterialSymbolsIcon.js';

class UikitPanel extends xb.Script {
  dragFacingCamera = true;
  draggable = true;
  draggingMode = xb.DragMode.TRANSLATING;
  container;

  constructor() {
    super();
    const panelSize = 0.5;
    this.container = new uikit.Container({
      sizeX: (panelSize * 16) / 9,
      sizeY: panelSize,
      pixelSize: panelSize / 512,
      flexDirection: 'column',
      textAlign: 'center',
      color: 'white',
      fontSize: 64,
      backgroundColor: 'gray',
      borderRadius: 64,
      padding: 16,
    });
    this.add(this.container);
  }

  update() {
    this.container?.update(xb.getDeltaTime());
  }

  onObjectSelectStart(event) {
    this.dispatchEventRecursively(event.target, 'click', this.container);
  }

  dispatchEventRecursively(controller, eventType, object) {
    const intersections = xb.core.input.intersectObjectByController(
      controller,
      object
    );
    if (intersections.length == 0 || !(object instanceof uikit.Component)) {
      return;
    }
    for (const child of object.children) {
      this.dispatchEventRecursively(controller, eventType, child);
    }
    const intersection = intersections[0];
    object.dispatchEvent({
      type: 'click',
      distance: intersection.distance,
      nativeEvent: {},
      object: intersection.object,
      point: intersection.point,
      pointerId: controller.userData.id,
    });
  }
}

/**
 * UIKit Template
 */
class UikitTemplate extends xb.Script {
  constructor() {
    super();

    const spatialPanel = new UikitPanel();
    spatialPanel.position.set(0, 1.5, -1);
    this.add(spatialPanel);

    const topRow = new uikit.Text({
      text: 'XR Blocks x @pmndrs/uikit',
      flexGrow: 2,
    });
    spatialPanel.container.add(topRow);

    const bottomRow = new uikit.Container({
      flexDirection: 'row',
      flexGrow: 1,
      justifyContent: 'space-evenly',
      gap: 64,
    });
    spatialPanel.container.add(bottomRow);

    const yesButton = new MaterialSymbolsIcon({
      icon: 'check_circle',
    });
    yesButton.addEventListener('click', () => {
      console.log('yes button clicked');
    });
    bottomRow.add(yesButton);

    const noButton = new MaterialSymbolsIcon({
      icon: 'x_circle',
    });
    noButton.addEventListener('click', () => {
      console.log('no button clicked');
    });
    bottomRow.add(noButton);
  }
}

const options = new xb.Options();
options.enableUI();

document.addEventListener('DOMContentLoaded', async function () {
  xb.add(new UikitTemplate());
  options.simulator.instructions.enabled = false;
  await xb.init(options);
  const renderer = xb.core.renderer;
  renderer.localClippingEnabled = true;
  renderer.setTransparentSort(uikit.reversePainterSortStable);
});



Sample: depthmap
(example: ../xrblocks/samples/depthmap/DepthMapScene.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

import {DepthVisualizationPass} from './DepthVisualizationPass.js';

export class DepthMapScene extends xb.Script {
  init() {
    if (xb.core.effects) {
      this.depthVisPass = new DepthVisualizationPass(xb.scene, xb.core.camera);
      xb.core.effects.addPass(this.depthVisPass);
    } else {
      console.error(
        'This sample needs post processing for adding the depth visualization pass. Please enable options.usePostprocessing'
      );
    }

    this.depthMeshAlphaSlider = new xb.FreestandingSlider(
      /*start=*/ 1.0,
      /*min=*/ 0.0,
      /*max=*/ 1.0,
      /*scale*/ 5.0
    );
    // Which controller is currently selecting depthMeshAlphaSlider.
    this.currentSliderController = null;

    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
    light.position.set(0.5, 1, 0.25);
    this.add(light);
  }

  onSelectStart(event) {
    const controller = event.target;
    controller.userData.selected = true;
    this.currentSliderController = controller;
    this.depthMeshAlphaSlider.setInitialPose(
      controller.position,
      controller.quaternion
    );
  }

  onSelectEnd(event) {
    const controller = event.target;
    controller.userData.selected = false;
    if (this.currentSliderController == controller) {
      const opacity = this.depthMeshAlphaSlider.getValueFromController(
        this.currentSliderController
      );
      this.depthVisPass.setAlpha(opacity);
      this.depthMeshAlphaSlider.updateValue(opacity);
    }
    this.currentSliderController = null;
  }

  update() {
    if (this.currentSliderController) {
      const opacity = this.depthMeshAlphaSlider.getValueFromController(
        this.currentSliderController
      );
      this.depthVisPass.setAlpha(opacity);
    }
    this.depthVisPass.updateEnvironmentalDepthTexture(xb.core.depth);
  }
}

(example: ../xrblocks/samples/depthmap/DepthVisualizationPass.js)
import * as THREE from 'three';
import {FullScreenQuad} from 'three/addons/postprocessing/Pass.js';
import * as xb from 'xrblocks';

import {DepthMapShader} from './depthmap.glsl.js';

/**
 * Depth map visualization postprocess pass.
 */
export class DepthVisualizationPass extends xb.XRPass {
  constructor() {
    super();
    this.depthTextures = [null, null];
    this.uniforms = {
      uDepthTexture: {value: null},
      uDepthTextureArray: {value: null},
      uRawValueToMeters: {value: 8.0 / 65536.0},
      uAlpha: {value: 1.0},
      tDiffuse: {value: null},
      uView: {value: 0},
      uIsTextureArray: {value: 0},
      // Used to interpret Quest 3 depth.
      uDepthNear: {value: 0},
    };
    this.depthMapQuad = new FullScreenQuad(
      new THREE.ShaderMaterial({
        name: 'DepthMapShader',
        uniforms: this.uniforms,
        vertexShader: DepthMapShader.vertexShader,
        fragmentShader: DepthMapShader.fragmentShader,
      })
    );
  }

  setAlpha(value) {
    this.uniforms.uAlpha.value = value;
  }

  updateEnvironmentalDepthTexture(xrDepth) {
    this.depthTextures[0] = xrDepth.getTexture(0);
    this.depthTextures[1] = xrDepth.getTexture(1);
    this.uniforms.uRawValueToMeters.value = xrDepth.rawValueToMeters;
    if (this.depthTextures[0]) {
      this.uniforms.uIsTextureArray.value = this.depthTextures[0]
        .isExternalTexture
        ? 1.0
        : 0;
    }
  }

  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive, viewId) {
    const texture = this.depthTextures[viewId];
    if (!texture) return;
    if (texture.isExternalTexture) {
      this.uniforms.uDepthTextureArray.value = texture;
      const depthNear = xb.core.depth.gpuDepthData[0].depthNear;
      this.uniforms.uDepthNear.value = depthNear;
    } else {
      this.uniforms.uDepthTexture.value = texture;
    }
    this.uniforms.tDiffuse.value = readBuffer.texture;
    this.uniforms.uView.value = viewId;
    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
    this.depthMapQuad.render(renderer);
  }

  dispose() {
    this.depthMapQuad.dispose();
  }
}

(example: ../xrblocks/samples/depthmap/depthmap.glsl.js)
export const DepthMapShader = {
  name: 'DepthMapShader',
  defines: {},

  vertexShader: /* glsl */ `
  varying vec2 vTexCoord;

  void main() {
      vTexCoord = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
`,

  fragmentShader: /* glsl */ `
  #include <packing>

  precision mediump float;

  uniform sampler2D uDepthTexture;
  uniform sampler2DArray uDepthTextureArray;
  uniform float uRawValueToMeters;
  uniform float uAlpha;
  uniform float uIsTextureArray;
  uniform int uView;
  uniform float uDepthNear;

  uniform sampler2D tDiffuse;
  uniform float cameraNear;
  uniform float cameraFar;

  varying vec2 vTexCoord;

  float DepthGetMeters(in sampler2D depth_texture, in vec2 depth_uv) {
    // Assume we're using floating point depth.
    return uRawValueToMeters * texture2D(depth_texture, depth_uv).r;
  }

  float DepthArrayGetMeters(in sampler2DArray depth_texture, in vec2 depth_uv) {
    float textureValue = texture(depth_texture, vec3(depth_uv.x, depth_uv.y, uView)).r;
    return uRawValueToMeters * uDepthNear / (1.0 - textureValue);
  }

  vec3 TurboColormap(in float x) {
    const vec4 kRedVec4 = vec4(0.55305649, 3.00913185, -5.46192616, -11.11819092);
    const vec4 kGreenVec4 = vec4(0.16207513, 0.17712472, 15.24091500, -36.50657960);
    const vec4 kBlueVec4 = vec4(-0.05195877, 5.18000081, -30.94853351, 81.96403246);
    const vec2 kRedVec2 = vec2(27.81927491, -14.87899417);
    const vec2 kGreenVec2 = vec2(25.95549545, -5.02738237);
    const vec2 kBlueVec2 = vec2(-86.53476570, 30.23299484);

    // Adjusts color space via 6 degree poly interpolation to avoid pure red.
    x = clamp(x * 0.9 + 0.03, 0.0, 1.0);
    vec4 v4 = vec4( 1.0, x, x * x, x * x * x);
    vec2 v2 = v4.zw * v4.z;
    return vec3(
      dot(v4, kRedVec4)   + dot(v2, kRedVec2),
      dot(v4, kGreenVec4) + dot(v2, kGreenVec2),
      dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)
    );
  }

  void main(void) {
    vec4 texCoord = vec4(vTexCoord, 0, 1);
    vec2 uv = texCoord.xy;

    vec4 diffuse = texture2D( tDiffuse, texCoord.xy );
    highp float real_depth;
    if (uIsTextureArray < 0.5) {
      uv.y = 1.0 - uv.y;
      real_depth = DepthGetMeters(uDepthTexture, uv);
    } else
      real_depth = DepthArrayGetMeters(uDepthTextureArray, uv);
    vec4 depth_visualization = vec4(
      TurboColormap(clamp(real_depth / 8.0, 0.0, 1.0)), 1.0);
    gl_FragColor = mix(diffuse, depth_visualization, uAlpha);
  }
`,
};

(example: ../xrblocks/samples/depthmap/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Depth Map | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/depthmap/main.js)
import 'xrblocks/addons/simulator/instructions/SimulatorInstructions.js';

import * as xb from 'xrblocks';

import {DepthMapScene} from './DepthMapScene.js';

const options = new xb.Options();
options.depth.enabled = true;
options.depth.depthTexture.enabled = true;
options.depth.depthTypeRequest = [xb.getUrlParameter('depthType') ?? 'raw'];
options.usePostprocessing = true;
options.setAppTitle('Depth Map');

function start() {
  xb.add(new DepthMapScene());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});



Sample: depthmesh
(example: ../xrblocks/samples/depthmesh/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Depth Mesh | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/depthmesh/main.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

class DepthMeshVisualizer extends xb.Script {
  currentSliderController = null;
  depthMeshAlphaSlider = new xb.FreestandingSlider(
    /*start=*/ 1.0,
    /*min=*/ 0.0,
    /*max=*/ 1.0,
    /*scale*/ 5.0
  );

  constructor() {
    super();
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
    light.position.set(0.5, 1, 0.25);
    this.add(light);
  }

  init() {
    xb.core.depth.depthMesh.material.uniforms.uOpacity.value =
      this.depthMeshAlphaSlider.startingValue;
  }

  onSelectStart(event) {
    this.currentSliderController = event.target;
    this.depthMeshAlphaSlider.setInitialPoseFromController(
      this.currentSliderController
    );
  }

  onSelectEnd(event) {
    const controller = event.target;
    if (this.currentSliderController == controller) {
      const opacity = this.depthMeshAlphaSlider.getValueFromController(
        this.currentSliderController
      );
      xb.core.depth.depthMesh.material.uniforms.uOpacity.value = opacity;
      this.depthMeshAlphaSlider.updateValue(opacity);
    }
    this.currentSliderController = null;
  }

  update() {
    if (this.currentSliderController) {
      const opacity = this.depthMeshAlphaSlider.getValueFromController(
        this.currentSliderController
      );
      xb.core.depth.depthMesh.material.uniforms.uOpacity.value = opacity;
      console.log('opacity:' + opacity);
    }
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.setAppTitle('Depth Mesh');
  options.depth = new xb.DepthOptions(xb.xrDepthMeshVisualizationOptions);
  options.depth.depthTypeRequest = [xb.getUrlParameter('depthType') ?? 'raw'];
  xb.add(new DepthMeshVisualizer());
  xb.init(options);
});



Sample: game_rps
(example: ../xrblocks/samples/game_rps/GameRps.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

import {GestureDetectionHandler} from './GestureDetectionHandler.js';

const LEFT_HAND_INDEX = 0;
const RIGHT_HAND_INDEX = 1;

const countdownImages = [
  'images/start1.webp',
  'images/start2.webp',
  'images/start3.webp',
  'images/startGo.webp',
];

const rpsLeftImages = [
  'images/gestureUnknown.webp',
  'images/gestureFistLeft.webp',
  'images/gestureScissorsLeft.webp',
  'images/gesturePaperLeft.webp',
];

const rpsRightImages = [
  'images/gestureUnknown.webp',
  'images/gestureFistRight.webp',
  'images/gestureScissorsRight.webp',
  'images/gesturePaperRight.webp',
];

const resultImages = [
  'images/resultTie.webp',
  'images/resultWin.webp',
  'images/resultLose.webp',
];

const gameOutcomePhrases = [
  // Phrases for a draw
  [
    'A draw!',
    "We've matched.",
    'Great minds think alike.',
    "It's a stalemate.",
    "We're even.",
    'Neither of us wins this time.',
    "Looks like we're in sync.",
    "We'll have to go again.",
    'A perfect match.',
    "It's a tie.",
  ],
  // Phrases for a Gemeni lose
  [
    'You got me.',
    'Nicely done, you win.',
    'Ah, you were one step ahead.',
    'The victory is yours.',
    "I'll have to get you next time.",
    "You've defeated me.",
    "I couldn't beat that.",
    'Well played, you earned it.',
    'You read my mind.',
    'The point goes to you.',
  ],
  // Phrases for a Gemini victory
  [
    'Victory is mine!',
    'I got you that time.',
    'Looks like I came out on top.',
    "I'll take that win.",
    'Another one for my column.',
    "You've been bested.",
    'I predicted your move perfectly.',
    "That's how it's done.",
    'I have the winning strategy.',
    'The round goes to me.',
  ],
];

export class GameRps extends xb.Script {
  constructor() {
    super();
    // List of detected gestures for the left and right hands.
    this.handGesture = [[], []];
    this.isDebug = false;

    //
    // Initializes UI.
    //
    {
      // Makes a root panel > grid > row > controlPanel > grid.
      const panel = new xb.SpatialPanel({
        backgroundColor: '#00000000',
        useDefaultPosition: false,
        showEdge: false,
      });
      panel.scale.set(panel.width, panel.height, 1);
      panel.isRoot = true;
      this.add(panel);

      const grid = panel.addGrid();
      // Adds blank space on top of the ctrlPanel.
      this.startImageRow = grid.addRow({weight: 0.4});
      this.startImageRow.addCol({weight: 0.3});
      this.startImage = this.startImageRow.addCol({weight: 0.4}).addImage({
        src: 'images/startStart.webp',
      });
      this.startImageRow.addCol({weight: 0.3});

      if (this.isDebug) {
        //
        // UI to debug user gestures.
        //
        this.playImageRow = grid.addRow({weight: 0.2});
        this.playImageRow.addCol({weight: 0.2});
        this.imageGesture1 = this.playImageRow.addCol({weight: 0.2}).addImage({
          src: 'images/gestureEmpty.webp',
        });
        // VS text
        this.playImageRow.addCol({weight: 0.2}).addImage({
          src: 'images/resultVS.webp',
        });
        this.imageGesture2 = this.playImageRow.addCol({weight: 0.2}).addImage({
          src: 'images/gestureEmpty.webp',
        });
        this.playImageRow.addCol({weight: 0.3});
        this.playImageRow.hide();

        this.resultImageRow = grid.addRow({weight: 0.2});
        this.resultImageRow.addCol({weight: 0.4});
        this.resultImage = this.resultImageRow.addCol({weight: 0.2}).addImage({
          src: 'images/gestureEmpty.webp',
        });
        this.resultImageRow.hide();
      }

      // Space for orbiter
      grid.addRow({weight: 0.1});
      // control row
      const controlRow = grid.addRow({weight: 0.5});
      const ctrlPanel = controlRow.addPanel({backgroundColor: '#000000bb'});

      const ctrlGrid = ctrlPanel.addGrid();
      {
        // middle column
        const midColumn = ctrlGrid.addCol({weight: 0.9});

        // top indentation
        midColumn.addRow({weight: 0.1});

        const gesturesRow = midColumn.addRow({weight: 0.4});

        // left indentation
        gesturesRow.addCol({weight: 0.05});

        const textCol = gesturesRow.addCol({weight: 1.0});
        this.textField1 = textCol.addRow({weight: 1.0}).addText({
          text: "Let's play Rock-Paper-Scissors!",
          fontColor: '#ffffff',
          fontSize: 0.045,
        });
        this.textField2 = textCol.addRow({weight: 1.0}).addText({
          text: 'Do a thumbs-up gesture to get started!',
          fontColor: '#ffffff',
          fontSize: 0.045,
        });

        // right indentation
        gesturesRow.addCol({weight: 0.01});

        // bottom indentation
        midColumn.addRow({weight: 0.1});
      }

      const orbiter = ctrlGrid.addOrbiter();
      orbiter.addExitButton();

      panel.updateLayouts();

      this.panel = panel;

      // Gesture detector
      this.gestureDetectionHandler = new GestureDetectionHandler();
      this.gestureDetectionHandler.registerObserver(this);
    }

    // state for 1-2-3-GO
    this.state = 0;
    // delay for 1-2-3-GO
    this.delayMs = this.isDebug ? 400 : 800;
    // Wait for 2.5 sec to enable game restart
    this.gameRestartTimeout = this.isDebug ? 1000 : 2500;
    this.gameGestureDetectionTimeout = this.isDebug ? 900 : 2500;

    // The gesture detection start time
    this.gestureStartTime = 0;

    // Frame counter
    this.frameId = 0;

    // Play states for both left and right hands
    this.handRpsStates = [[], []];

    // 1-2-3-GO
    this.displayNextImage = this.displayNextImage.bind(this);
  }

  displayNextImage() {
    if (this.state < countdownImages.length) {
      // Load and display the current image
      this.startImage.load(countdownImages[this.state]);
      this.state++; // Move to the next image for the next call

      // Schedule the next image display after the delay
      setTimeout(this.displayNextImage, this.delayMs);
    } else {
      this.gestureStartTime = Date.now();
      // Enable the papter detection/disable thumb up
      this.gestureDetectionHandler.enablePaperGesture(true);

      setTimeout(() => {
        this.displayRandomGesture();
      }, this.delayMs);
    }
  }

  displayRandomGesture() {
    this.randomGesture = Math.floor(Math.random() * 3) + 1;
    if (this.isDebug) {
      this.startImageRow.hide();
      this.playImageRow.show();
      this.resultImageRow.show();
      // Load random gesture
      this.imageGesture1.load(rpsLeftImages[this.randomGesture]);
    } else {
      this.startImage.load(rpsLeftImages[this.randomGesture]);
    }
  }

  displayGameSummary(idx) {
    let result = 2;
    if (idx == 0) {
      this.textField1.setText("I didn't catch what you threw! Let's retry!");
      this.textField2.setText('Do a thumbs-up gesture when you are ready!');
    } else {
      let result = this.getRPSOutcome(this.randomGesture, idx);
      this.textField1.setText(this.getRandomPhrase(result));
      this.textField2.setText('Do a thumbs-up gesture to play more!');
    }

    //
    // Debug UI - show game summary and user gesture
    //
    if (this.isDebug) {
      // 'OTHER', 'FIST', 'VICTORY', 'PAPER'
      this.imageGesture2.load(rpsRightImages[idx < 4 ? idx : 0]);
      // Show user gesture
      this.resultImage.load(resultImages[result]);
    }
  }

  /**
   * Determines the outcome of a Rock-Paper-Scissors game.
   *
   * @param {number} playerChoice - The player's choice (1: Rock, 2: Paper, 3:
   *     Scissors).
   * @param {number} opponentChoice - The opponent's choice (1: Rock, 2: Paper,
   *     3: Scissors).
   * @returns {number} The outcome (0: Match, 1: Win, 2: Lose).
   */
  getRPSOutcome(playerChoice, opponentChoice) {
    // Check for a tie
    if (playerChoice === opponentChoice) {
      return 0; // Match (Tie)
    }

    // Determine win/lose based on the classic rules
    // Player Wins if:
    // Rock (1) beats Scissors (3)
    // Paper (2) beats Rock (1)
    // Scissors (3) beats Paper (2)
    if (
      (playerChoice === 1 && opponentChoice === 3) || // Rock vs Scissors
      (playerChoice === 2 && opponentChoice === 1) || // Paper vs Rock
      (playerChoice === 3 && opponentChoice === 2) // Scissors vs Paper
    ) {
      return 1; // Win
    } else {
      return 2; // Lose (all other cases are losses)
    }
  }

  startGame() {
    if (this.isDebug) {
      // Show 1-2-3-GO
      this.startImageRow.show();
      // Reset result images
      this.imageGesture1.load('images/gestureEmpty.webp');
      this.imageGesture2.load('images/gestureEmpty.webp');
      this.resultImage.load('images/gestureEmpty.webp');
      // hide result
      this.playImageRow.hide();
      this.resultImageRow.hide();
    }

    this.textField1.setText('');

    // start timer for the 1-2-3-go
    this.displayNextImage();
  }

  onGestureDetected(handIndex, result) {
    // Thumb up
    if (result == 4) {
      // Ensure the game isn't currently active.
      if (this.state === 0) {
        this.startGame();
      }
      return;
    }

    if (this.gestureStartTime === 0) {
      // skip all late gesture detections
      return;
    }

    // Record all gesture changes for the
    let delta = Date.now() - this.gestureStartTime;
    //
    // Gesture detection time interval exceeded
    //
    if (delta > this.gameGestureDetectionTimeout) {
      this.gestureStartTime = 0;
      this.detectFinalGestures();
    } else {
      let len = this.handRpsStates[handIndex].length;
      if (
        len == 0 ||
        (this.handGesture[handIndex][len - 1] &&
          this.handGesture[handIndex][len - 1].gesture !== result)
      ) {
        // Save gesture-duration for each hand
        this.handRpsStates[handIndex].push({gesture: result, delta: delta});
        this.handGesture[handIndex] = result;
      }
    }
  }

  detectFinalGestures() {
    // TODO: we can check both hands values
    // this.leftHandGesture =
    // this.detectRPSGesture(this.handRpsStates[LEFT_HAND_INDEX]);
    this.rightHandGesture = this.detectRPSGesture(
      this.handRpsStates[RIGHT_HAND_INDEX]
    );

    this.displayGameSummary(this.rightHandGesture);

    // Reset cached states
    this.handRpsStates = [[], []];

    // Disable the papter detection. Enable thumb up
    this.gestureDetectionHandler.enablePaperGesture(false);

    // add delay before user could re-start the game
    setTimeout(() => {
      // Ready to play again
      this.state = 0;
    }, this.gameRestartTimeout);
  }

  detectRPSGesture(handRpsStates, options = {}) {
    const defaultOptions = {
      // Gesture must be stable for 300ms
      stabilityDurationMs: 300,
      // Skip first gesture, if it is changed in 300ms
      initialRockIgnoreDurationMs: 300, // Ignore initial rock for 300ms (not directly used in this
      // solution, but kept for context)
      // gesture detection period
      maxDetectionWindowMs: this.gameGestureDetectionTimeout,
    };
    const {maxDetectionWindowMs} = {...defaultOptions, ...options};

    if (!handRpsStates || handRpsStates.length === 0) {
      return 0; // Other
    }

    // Ensure data is sorted by delta
    handRpsStates.sort((a, b) => a.delta - b.delta);

    const firstPhaseEndMs = maxDetectionWindowMs * (2 / 5);
    // Corrected to 2/5 to ensure 3/5 remaining
    const secondPhaseStartMs = maxDetectionWindowMs * (2 / 5);

    let rockStartedInFirstPhase = false;
    const gestureDurations = new Map(); // Stores {gesture: totalDurationMs}

    let prevDelta = 0;
    let prevGesture = 0; // Initialize with 0 to handle the very first gesture

    for (let i = 0; i < handRpsStates.length; i++) {
      const {gesture, delta} = handRpsStates[i];

      // Only consider data within the max detection window
      if (delta > maxDetectionWindowMs) {
        break;
      }

      // Calculate duration for the previous gesture segment
      const duration = delta - prevDelta;

      // Accumulate duration for the previous gesture
      if (prevGesture !== 0 && prevGesture > 0 && prevGesture < 4) {
        // Only consider valid RPS gestures
        gestureDurations.set(
          prevGesture,
          (gestureDurations.get(prevGesture) || 0) + duration
        );
      }

      // Check if gesture '1' (rock) started in the first phase
      if (gesture === 1 && delta <= firstPhaseEndMs) {
        rockStartedInFirstPhase = true;
      }

      prevDelta = delta;
      prevGesture = gesture;
    }

    // Handle the duration of the very last segment up to maxDetectionWindowMs
    // if it extends beyond the last recorded delta
    if (
      prevDelta < maxDetectionWindowMs &&
      prevGesture !== 0 &&
      prevGesture > 0 &&
      prevGesture < 4
    ) {
      const remainingDuration = maxDetectionWindowMs - prevDelta;
      gestureDurations.set(
        prevGesture,
        (gestureDurations.get(prevGesture) || 0) + remainingDuration
      );
    }

    let longestGesture = 0;
    let maxDuration = 0;
    const minRequiredDuration = 300;

    // Determine the relevant time window for finding the longest gesture
    let effectiveStartTime = 0;
    let effectiveEndTime = maxDetectionWindowMs;

    if (rockStartedInFirstPhase) {
      effectiveStartTime = secondPhaseStartMs;
    }

    // Filter and find the longest non-0 gesture within the effective time
    // window We need to re-evaluate durations based on the effective window. A
    // simpler approach is to have accumulated durations and then apply the
    // window logic. Given the accumulated durations, we now iterate through
    // them and find the longest. The previous accumulation already implicitly
    // considers the entire window. The conditional logic
    // (rockStartedInFirstPhase) means we might ignore some initial durations.
    // This requires re-calculating or filtering the `handRpsStates` based on
    // the effective window.

    // Let's re-calculate durations based on the effective window for clarity
    const filteredGestureDurations = new Map();
    let currentWindowPrevDelta = effectiveStartTime;
    let currentWindowPrevGesture = 0; // To track the gesture at the start of the effective window

    // Find the gesture at the effectiveStartTime
    for (let i = 0; i < handRpsStates.length; i++) {
      const {gesture, delta} = handRpsStates[i];
      if (delta >= effectiveStartTime) {
        currentWindowPrevGesture = prevGesture; // The gesture *before* reaching effectiveStartTime
        if (i > 0) {
          currentWindowPrevGesture = handRpsStates[i - 1].gesture;
        } else {
          currentWindowPrevGesture = gesture; // If the very first delta is already within the
          // effective window
        }
        break;
      }
      prevGesture = gesture; // Keep track of the last gesture before effectiveStartTime
    }

    for (let i = 0; i < handRpsStates.length; i++) {
      const {gesture, delta} = handRpsStates[i];

      if (delta < effectiveStartTime) {
        currentWindowPrevDelta = delta; // Continue updating prevDelta until we
        // hit the effectiveStartTime
        currentWindowPrevGesture = gesture; // Update currentWindowPrevGesture
        continue;
      }

      if (delta > effectiveEndTime) {
        // Calculate duration for the segment up to effectiveEndTime
        const duration = Math.max(
          0,
          effectiveEndTime -
            Math.max(currentWindowPrevDelta, effectiveStartTime)
        );
        if (
          currentWindowPrevGesture !== 0 &&
          currentWindowPrevGesture > 0 &&
          currentWindowPrevGesture < 4
        ) {
          filteredGestureDurations.set(
            currentWindowPrevGesture,
            (filteredGestureDurations.get(currentWindowPrevGesture) || 0) +
              duration
          );
        }
        break; // We are past the effective end time
      }

      const segmentStart = Math.max(currentWindowPrevDelta, effectiveStartTime);
      const segmentEnd = delta;
      const duration = segmentEnd - segmentStart;

      if (
        currentWindowPrevGesture !== 0 &&
        currentWindowPrevGesture > 0 &&
        currentWindowPrevGesture < 4
      ) {
        filteredGestureDurations.set(
          currentWindowPrevGesture,
          (filteredGestureDurations.get(currentWindowPrevGesture) || 0) +
            duration
        );
      }

      currentWindowPrevDelta = delta;
      currentWindowPrevGesture = gesture;
    }

    // Handle the remaining duration if the last recorded delta is before
    // effectiveEndTime
    if (
      currentWindowPrevDelta < effectiveEndTime &&
      currentWindowPrevGesture !== 0 &&
      currentWindowPrevGesture > 0 &&
      currentWindowPrevGesture < 4
    ) {
      const remainingDuration =
        effectiveEndTime - Math.max(currentWindowPrevDelta, effectiveStartTime);
      filteredGestureDurations.set(
        currentWindowPrevGesture,
        (filteredGestureDurations.get(currentWindowPrevGesture) || 0) +
          remainingDuration
      );
    }

    for (const [gesture, duration] of filteredGestureDurations.entries()) {
      if (gesture !== 0 && duration >= minRequiredDuration) {
        if (duration > maxDuration) {
          maxDuration = duration;
          longestGesture = gesture;
        }
      }
    }

    return longestGesture;
  }

  /**
   * Initializes the PaintScript.
   */
  init() {
    xb.core.renderer.localClippingEnabled = true;

    this.add(new THREE.HemisphereLight(0x888877, 0x777788, 3));
    const light = new THREE.DirectionalLight(0xffffff, 5.0);
    light.position.set(-0.5, 4, 1.0);
    this.add(light);

    this.panel.position.set(0, xb.core.user.height, -1.0);
  }

  async update() {
    //
    // Run gesture detection 12 times per second for ~60fps
    // But an avg fps for webxr is 30-60
    //
    if (this.frameId % 5 === 0) {
      const hands = xb.core.user.hands;
      if (hands.isValid()) {
        this.gestureDetectionHandler.postTask(
          hands.hands[LEFT_HAND_INDEX].joints,
          LEFT_HAND_INDEX
        );
        this.gestureDetectionHandler.postTask(
          hands.hands[RIGHT_HAND_INDEX].joints,
          RIGHT_HAND_INDEX
        );
      }
    }

    this.frameId++;
  }

  /**
   * Selects a random phrase from a specified category of game outcomes.
   * @param {number} categoryIndex - The index of the category (0 for victory, 1
   *     for loss, 2 for draw).
   * @returns {string|null} A randomly selected phrase from the category, or
   *     null if the index is invalid.
   */
  getRandomPhrase(categoryIndex) {
    if (categoryIndex < 0 || categoryIndex >= gameOutcomePhrases.length) {
      console.error(
        'Invalid category index provided. Please use 0 for victory, 1 for loss, or 2 for draw.'
      );
      return null;
    }
    const phrasesArray = gameOutcomePhrases[categoryIndex];
    const randomIndex = Math.floor(Math.random() * phrasesArray.length);
    return phrasesArray[randomIndex];
  }
}

(example: ../xrblocks/samples/game_rps/GestureDetectionHandler.js)
// LiteRt
import {loadLiteRt, setWebGpuDevice} from '@litertjs/core';
import {runWithTfjsTensors} from '@litertjs/tfjs-interop';
// TensorflowJS + WebGPU backend
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import {WebGPUBackend} from '@tensorflow/tfjs-backend-webgpu';
import * as tf from '@tensorflow/tfjs';
import * as xb from 'xrblocks';

const GESTURE_RETURN_LABELS_MAX_ENUM = 5;

const UNKNOWN_GESTURE = 0;

/**
 * Threshold for a dot product to indicate a straight or extended finger segment.
 * 0.9 implies ~25.8 degrees tolerance.
 * @const {number}
 */
const STRAIGHT_FINGER_THRESHOLD = 0.9;

/**
 * Indices in the `relativeHandBoneAngles` tensor, derived directly from the
 * order in the HAND_BONE_IDX_CONNECTION_MAP provided.
 * @enum {number}
 */
const ANGLE_INDICES = {
  // Thumb angles (2 angles for straightness)
  THUMB_SEGMENT_ANGLE_1: 0,
  THUMB_SEGMENT_ANGLE_2: 1,

  // Index finger angles (3 angles for straightness)
  INDEX_SEGMENT_ANGLE_1: 2,
  INDEX_SEGMENT_ANGLE_2: 3,
  INDEX_SEGMENT_ANGLE_3: 4,

  // Middle finger angles (3 angles for straightness)
  MIDDLE_SEGMENT_ANGLE_1: 5,
  MIDDLE_SEGMENT_ANGLE_2: 6,
  MIDDLE_SEGMENT_ANGLE_3: 7,

  // Ring finger angles (3 angles for straightness)
  RING_SEGMENT_ANGLE_1: 8,
  RING_SEGMENT_ANGLE_2: 9,
  RING_SEGMENT_ANGLE_3: 10,

  // Pinky finger angles (3 angles for straightness)
  PINKY_SEGMENT_ANGLE_1: 11,
  PINKY_SEGMENT_ANGLE_2: 12,
  PINKY_SEGMENT_ANGLE_3: 13,
};

/**
 * A queue that only processes the most recent task, discarding outdated ones.
 */
class LatestTaskQueue {
  constructor() {
    this.latestTask = null;
    this.isProcessing = false;
  }

  enqueue(task) {
    if (typeof task !== 'function') {
      console.error('Task must be a function.');
      return;
    }
    this.latestTask = task;
    if (!this.isProcessing) {
      this.processLatestTask();
    }
  }

  processLatestTask() {
    if (this.latestTask) {
      this.isProcessing = true;
      const taskToProcess = this.latestTask;
      this.latestTask = null; // Clear the reference immediately

      // Execute the task asynchronously using setTimeout (or queueMicrotask)
      setTimeout(async () => {
        try {
          await taskToProcess(); // If the task is async
        } catch (error) {
          console.error('Error processing latest task:', error);
        } finally {
          this.isProcessing = false;
          if (this.latestTask) {
            this.processLatestTask();
          }
        }
      }, 0); // Delay of 0ms puts it in the event queue
    }
  }

  getSize() {
    return this.latestTask === null ? 0 : 1;
  }

  isEmpty() {
    return this.latestTask === null;
  }
}

/**
 * Handles gesture detection using TFJS and LiteRT.
 */
export class GestureDetectionHandler {
  constructor() {
    // model
    this.modelPath = './custom_gestures_model.tflite';
    this.modelState = 'None';

    // Enable/Disable paper gesture detection
    this.enablePaperDetection = false;

    //
    // left and right hand queues
    this.queue = [];
    this.queue.push(new LatestTaskQueue());
    this.queue.push(new LatestTaskQueue());

    setTimeout(() => {
      this.setBackendAndLoadModel();
    }, 1);
  }

  /**
   * Enables or disables specific paper gesture detection logic.
   * @param {boolean} value
   */
  enablePaperGesture(value) {
    this.enablePaperDetection = value;
  }

  /**
   * Sets up the WebGPU backend and loads the TFLite model.
   */
  async setBackendAndLoadModel() {
    this.modelState = 'Loading';
    try {
      await tf.setBackend('webgpu');
      await tf.ready();

      const wasmPath = 'https://unpkg.com/@litertjs/core@0.2.1/wasm/';
      const liteRt = await loadLiteRt(wasmPath);

      // Makes LiteRT use the same GPU device as TFJS (for tensor conversion).
      const backend = tf.backend(); // as WebGPUBackend;
      setWebGpuDevice(backend.device);

      // Loads model via LiteRT.
      await this.loadModel(liteRt);

      if (this.model) {
        // Prints model details to the log.
        console.log('MODEL DETAILS: ', this.model.getInputDetails());
      }
      this.modelState = 'Ready';
    } catch (error) {
      console.error('Failed to load model or backend:', error);
    }
  }

  /**
   * Loads the TFLite model.
   * @param {Object} liteRt The LiteRT instance.
   */
  async loadModel(liteRt) {
    try {
      this.model = await liteRt.loadAndCompile(this.modelPath, {
        // Currently, only 'webgpu' is supported.
        accelerator: 'webgpu',
      });
    } catch (error) {
      this.model = null;
      console.error('Error loading model:', error);
    }
  }

  calculateRelativeHandBoneAngles(jointPositions) {
    // Reshape jointPositions.
    let jointPositionsReshaped = [];

    jointPositionsReshaped = jointPositions.reshape([xb.HAND_JOINT_COUNT, 3]);

    // Calculates bone vectors.
    const boneVectors = [];
    xb.HAND_JOINT_IDX_CONNECTION_MAP.forEach(([joint1, joint2]) => {
      const boneVector = jointPositionsReshaped
        .slice([joint2, 0], [1, 3])
        .sub(jointPositionsReshaped.slice([joint1, 0], [1, 3]))
        .squeeze();
      const norm = boneVector.norm();
      const normalizedBoneVector = boneVector.div(norm);
      boneVectors.push(normalizedBoneVector);
    });

    // Calculates relative hand bone angles.
    const relativeHandBoneAngles = [];
    xb.HAND_BONE_IDX_CONNECTION_MAP.forEach(([bone1, bone2]) => {
      const angle = boneVectors[bone1].dot(boneVectors[bone2]);
      relativeHandBoneAngles.push(angle);
    });

    // Stacks the angles into a tensor.
    return tf.stack(relativeHandBoneAngles);
  }

  /**
   * Runs inference on hand joints.
   * @param {Array<number>} handJoints Flat array of joint positions.
   * @return {Promise<number>} The detected gesture ID.
   */
  async detectGesture(handJoints) {
    if (!this.model || !handJoints || handJoints.length !== 25 * 3) {
      console.log('Invalid hand joints or model load error.');
      return GESTURE_RETURN_LABELS_MAX_ENUM;
    }

    try {
      // Use tidy to clean up intermediate tensors.
      const tensor = tf.tidy(() =>
        this.calculateRelativeHandBoneAngles(tf.tensor1d(handJoints))
      );

      // Detect "Paper" gesture for 2 seconds.
      if (this.enablePaperDetection && this.isPaperGesture(tensor)) {
        // Paper gesture - GESTURE_RETURN_LABELS
        return 2;
      }

      const tensorReshaped = tf.tidy(() =>
        tensor.reshape([1, xb.HAND_BONE_IDX_CONNECTION_MAP.length, 1])
      );
      tensor.dispose(); // Disposes original tensor after reshape.

      const result = runWithTfjsTensors(this.model, tensorReshaped);
      tensorReshaped.dispose();

      const integerLabel = result[0].as1D().arraySync();
      if (integerLabel.length == 7) {
        let maxScore = integerLabel[0];

        let idx = 0;
        for (let t = 0; t < 7; ++t) {
          if (integerLabel[t] > maxScore) {
            idx = t;
            maxScore = integerLabel[t];
          }
        }

        // No need to detect thumb up for a play mode
        if (idx === 2) {
          if (
            this.enablePaperDetection ||
            !this.isThumbUp(handJoints, 2, 3, 4)
          ) {
            return 0;
          }
        }

        //
        // Maps model result to the return index for the game.
        //

        // Thumb Up Logic check (Model Index 2)
        if (idx == 2) {
          return 4; // Thumb Up
        }

        // Fist (Model Index 4)
        if (idx == 4) {
          return 2; // Rock
        }

        // Victory / Scissors (Model Index 1)
        else if (idx == 1) {
          return 1; // Scissors
        }

        // OTHER gesture
        return 0;
      }
    } catch (error) {
      console.error('Error:', error);
    }
    return GESTURE_RETURN_LABELS_MAX_ENUM;
  }

  /**
   * Wrapper for thumb up detection.
   */
  isThumbUp(d1, p1, p2, p3) {
    return this.isThumbUpSimple(d1, p1, p3);
  }

  /**
   * Advanced vector calculation for thumb up.
   * @param {Array<number>} data Flat array of joints.
   * @param {number} p1 Base index.
   * @param {number} p2 Knuckle index.
   * @param {number} p3 Tip index.
   * @return {boolean}
   */
  isThumbUpAdvanced(data, p1, p2, p3) {
    // Assuming p1 is the base of the thumb, p2 is the knuckle, and p3 is the
    // tip.

    // Vector from base to knuckle
    const v1 = {
      x: data[p2 * 3] - data[p1 * 3],
      y: data[p2 * 3 + 1] - data[p1 * 3 + 1],
      z: data[p2 * 3 + 2] - data[p1 * 3 + 2],
    };

    // Vector from knuckle to tip
    const v2 = {
      x: data[p3 * 3] - data[p2 * 3],
      y: data[p3 * 3 + 1] - data[p2 * 3 + 1],
      z: data[p3 * 3 + 2] - data[p2 * 3 + 2],
    };

    // Calculate the angle between the two vectors using the dot product
    const dotProduct = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;

    // Calculate the magnitudes (lengths) of the vectors
    const magnitudeV1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
    const magnitudeV2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);

    // Avoid division by zero if either vector has zero length
    if (magnitudeV1 === 0 || magnitudeV2 === 0) {
      return false; // Cannot determine angle if segments have zero length
    }

    // Calculate the cosine of the angle
    const cosAngle = dotProduct / (magnitudeV1 * magnitudeV2);

    // Get the angle in radians
    const angleRadians = Math.acos(Math.max(-1, Math.min(1, cosAngle))); // Clamp to handle potential floating-point errors

    // Convert the angle to degrees
    const angleDegrees = angleRadians * (180 / Math.PI);

    // Define a threshold angle for what we consider "thumb up".
    // This value might need adjustment based on your specific application and
    // data.
    const thumbUpThreshold = 90; // Example: If the angle is greater than 90
    // degrees, it's considered "up"

    // In a typical "thumb up" gesture, the angle between the base-knuckle
    // segment and the knuckle-tip segment would be relatively straight or even
    // slightly bent backward. Therefore, we are looking for an angle close to
    // 180 degrees or greater than 90.

    return angleDegrees > thumbUpThreshold;
  }

  /**
   * Detects if the hand is showing a "paper" (open palm) gesture based on bone
   * angles. Assumes `relativeHandBoneAngles` is a tf.Tensor containing dot
   * products (cosines of angles) between connected bone vectors, as generated
   * by `calculateRelativeHandBoneAngles`.
   *
   * @param {tf.Tensor} relativeHandBoneAngles A TensorFlow.js tensor of bone
   *     angles (dot products).
   * @returns {boolean} True if the gesture is "paper", false otherwise.
   */
  isPaperGesture(relativeHandBoneAngles) {
    if (!relativeHandBoneAngles || relativeHandBoneAngles.size === 0) {
      // No angle data, cannot detect gesture
      return false;
    }

    // Convert the tensor to a plain JavaScript array for easier access
    const angles = relativeHandBoneAngles.arraySync();

    // Helper to check if a finger's segments are sufficiently straight
    // All angle values for the segments should be above the threshold
    const areSegmentsStraight = (...angleIndices) => {
      return angleIndices.every(
        (idx) => angles[idx] > STRAIGHT_FINGER_THRESHOLD
      );
    };

    // Check straightness for each finger based on its segment angles
    const isThumbStraight = areSegmentsStraight(
      ANGLE_INDICES.THUMB_SEGMENT_ANGLE_1,
      ANGLE_INDICES.THUMB_SEGMENT_ANGLE_2
    );

    const isIndexStraight = areSegmentsStraight(
      ANGLE_INDICES.INDEX_SEGMENT_ANGLE_1,
      ANGLE_INDICES.INDEX_SEGMENT_ANGLE_2,
      ANGLE_INDICES.INDEX_SEGMENT_ANGLE_3
    );

    const isMiddleStraight = areSegmentsStraight(
      ANGLE_INDICES.MIDDLE_SEGMENT_ANGLE_1,
      ANGLE_INDICES.MIDDLE_SEGMENT_ANGLE_2,
      ANGLE_INDICES.MIDDLE_SEGMENT_ANGLE_3
    );

    const isRingStraight = areSegmentsStraight(
      ANGLE_INDICES.RING_SEGMENT_ANGLE_1,
      ANGLE_INDICES.RING_SEGMENT_ANGLE_2,
      ANGLE_INDICES.RING_SEGMENT_ANGLE_3
    );

    const isPinkyStraight = areSegmentsStraight(
      ANGLE_INDICES.PINKY_SEGMENT_ANGLE_1,
      ANGLE_INDICES.PINKY_SEGMENT_ANGLE_2,
      ANGLE_INDICES.PINKY_SEGMENT_ANGLE_3
    );

    // For a "paper" gesture, all fingers (including the thumb) should be
    // straight. As discussed, explicit thumb abduction isn't provided by your
    // current angle map, so we focus on overall finger extension.
    const isPaper =
      isThumbStraight &&
      isIndexStraight &&
      isMiddleStraight &&
      isRingStraight &&
      isPinkyStraight;

    return isPaper;
  }

  //
  // Clone joints and post queue task
  //
  postTask(joints, handIndex) {
    if (Object.keys(joints).length !== 25) {
      return UNKNOWN_GESTURE;
    }

    let handJointPositions = [];
    for (const i in joints) {
      handJointPositions.push(joints[i].position.x);
      handJointPositions.push(joints[i].position.y);
      handJointPositions.push(joints[i].position.z);
    }

    if (handJointPositions.length !== 25 * 3) {
      return UNKNOWN_GESTURE;
    }

    if (handIndex >= 0 && handIndex < this.queue.length) {
      this.queue[handIndex].enqueue(async () => {
        let result = await this.detectGesture(handJointPositions);

        if (this.observer && this.observer.onGestureDetected) {
          this.observer.onGestureDetected(handIndex, result);
        }
      });
    }
  }

  isThumbUpSimple(data, p1, p2) {
    // Assuming p1 is the base of the thumb and p2 is the tip.

    // Vector from base to tip
    const vector = {
      x: data[p2 * 3] - data[p1 * 3],
      y: data[p2 * 3 + 1] - data[p1 * 3 + 1],
      z: data[p2 * 3 + 2] - data[p1 * 3 + 2],
    };

    // Calculate the magnitude of the vector
    const magnitude = Math.sqrt(
      vector.x * vector.x + vector.y * vector.y + vector.z * vector.z
    );

    // If the magnitude is very small, it's likely not a significant gesture
    if (magnitude < 0.001) {
      return false;
    }

    // Normalize the vector to get its direction
    const normalizedVector = {
      x: vector.x / magnitude,
      y: vector.y / magnitude,
      z: vector.z / magnitude,
    };

    // Define the "up" direction vector (positive Y-axis)
    const upVector = {x: 0, y: 1, z: 0};

    // Calculate the dot product between the normalized thumb vector and the up
    // vector
    const dotProduct =
      normalizedVector.x * upVector.x +
      normalizedVector.y * upVector.y +
      normalizedVector.z * upVector.z;

    // The dot product of two normalized vectors is equal to the cosine of the
    // angle between them. An angle of 45 degrees has a cosine of approximately
    // Math.cos(Math.PI / 4) or ~0.707. We want the angle to be within 45
    // degrees of the vertical "up" direction. This means the cosine of the
    // angle should be greater than or equal to cos(45 degrees).

    const cos45Degrees = Math.cos((45 * Math.PI) / 180); // Approximately 0.707

    return dotProduct >= cos45Degrees;
  }

  registerObserver(observer) {
    this.observer = observer;
  }
}

(example: ../xrblocks/samples/game_rps/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Rock Paper Scissors | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "@tensorflow/tfjs-core": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core/+esm",
          "@tensorflow/tfjs": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/+esm",
          "@tensorflow/tfjs-backend-webgpu": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu/+esm",
          "@litertjs/core": "https://unpkg.com/@litertjs/core@0.2.1",
          "@litertjs/tfjs-interop": "https://unpkg.com/@litertjs/tfjs-interop@1.0.1",
          "@litertjs/wasm-utils": "https://unpkg.com/@litertjs/wasm-utils@0.2.1",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/game_rps/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {GameRps} from './GameRps.js';

const options = new xb.Options();
options.enableReticles();
options.enableHands();
options.simulator.defaultMode = xb.SimulatorMode.POSE;
options.simulator.defaultHand = xb.Handedness.RIGHT;
options.setAppTitle('Rock Paper Scissors');

async function start() {
  xb.add(new GameRps());
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  setTimeout(function () {
    start();
  }, 200);
});



Sample: gestures_custom
(example: ../xrblocks/samples/gestures_custom/CustomGestureDemo.js)
// Imports LiteRt: https://ai.google.dev/edge/litert/web/get_started
import {loadLiteRt, setWebGpuDevice} from '@litertjs/core';
import {runWithTfjsTensors} from '@litertjs/tfjs-interop';
// TensorFlow.js + WebGPU backend
import * as tf from '@tensorflow/tfjs';
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import {WebGPUBackend} from '@tensorflow/tfjs-backend-webgpu';
import * as THREE from 'three';
import * as xb from 'xrblocks';

const GESTURE_LABELS = [
  'OTHER',
  'FIST',
  'THUMB UP',
  'THUMB DOWN',
  'POINT',
  'VICTORY',
  'ROCK',
  'SHAKA',
  'GESTURE_LABEL_MAX_ENUM',
];

const GESTURE_IMAGES = [
  'images/empty.png',
  'images/fist.png',
  'images/thumb.png',
  'images/thumb_down.png',
  'images/point.png',
  'images/victory.png',
  'images/rock.png',
  'images/shaka.png',
  'images/error.png',
];

const LEFT_HAND_INDEX = 0;
const RIGHT_HAND_INDEX = 1;

const UNKNOWN_GESTURE = 8;

/**
 * A demo scene that uses a custom ML model to detect and display static hand
 * gestures for both hands in real-time.
 */
export class CustomGestureDemo extends xb.Script {
  constructor() {
    super();

    // Initializes UI.
    {
      // Make a root panel>grid>row>controlPanel>grid
      const panel = new xb.SpatialPanel({backgroundColor: '#00000000'});
      this.add(panel);

      const grid = panel.addGrid();

      // Show user data
      const dataRow = grid.addRow({weight: 0.3});
      // Left hand image and text
      const leftCol = dataRow.addCol({weight: 0.5});
      const leftHandRow = leftCol.addRow({weight: 0.5});
      // Indentation
      leftHandRow.addCol({weight: 0.4});
      this.leftHandImage = leftHandRow.addCol({weight: 0.2}).addImage({
        src: GESTURE_IMAGES[0],
        scaleFactor: 0.3,
      });
      this.leftHandLabel = leftCol.addRow({weight: 0.5}).addText({
        text: 'Loading...',
        fontColor: '#ffffff',
      });
      const rightCol = dataRow.addCol({weight: 0.5});
      const rightHandRow = rightCol.addRow({weight: 0.5});
      // Indentation
      rightHandRow.addCol({weight: 0.4});
      // Image
      this.rightHandImage = rightHandRow.addCol({weight: 0.2}).addImage({
        src: GESTURE_IMAGES[0],
        scaleFactor: 0.3,
      });
      this.rightHandLabel = rightCol.addRow({weight: 0.4}).addText({
        text: 'Loading...',
        fontColor: '#ffffff',
      });

      // Indentation
      grid.addRow({weight: 0.1});

      // Control row
      const controlRow = grid.addRow({weight: 0.6});
      const ctrlPanel = controlRow.addPanel({backgroundColor: '#00000055'});
      const ctrlGrid = ctrlPanel.addGrid();
      {
        // Left indentation
        ctrlGrid.addCol({weight: 0.1});

        // Middle column
        const midColumn = ctrlGrid.addCol({weight: 0.8});

        midColumn.addRow({weight: 0.1});
        midColumn.addRow({weight: 0.2}).addText({
          text: 'Perform one of these gestures',
          fontColor: '#ffffff',
        });
        midColumn
          .addRow({weight: 0.2})
          .addText({text: '(either hand):', fontColor: '#ffffff'});
        const gesturesRow = midColumn.addRow({weight: 0.5});
        gesturesRow.addCol({weight: 0.1});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/fist.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/thumb.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/thumb_down.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/point.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/victory.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/rock.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/shaka.png', scaleFactor: 0.3});

        // Vertical alignment on the description text element.
        midColumn.addRow({weight: 0.1});

        // Right indentation.
        ctrlGrid.addCol({weight: 0.1});
      }

      const orbiter = ctrlGrid.addOrbiter();
      orbiter.addExitButton();

      panel.updateLayouts();

      this.panel = panel;
    }

    // Model
    this.modelPath = './custom_gestures_model.tflite';
    this.modelState = 'None';

    this.frameId = 0;

    setTimeout(() => {
      this.setBackendAndLoadModel();
    }, 1);
  }

  init() {
    // Adds light.
    this.add(new THREE.HemisphereLight(0x888877, 0x777788, 3));
    const light = new THREE.DirectionalLight(0xffffff, 1.5);
    light.position.set(0, 4, 0);
    this.add(light);
  }

  async setBackendAndLoadModel() {
    this.modelState = 'Loading';
    try {
      await tf.setBackend('webgpu');
      await tf.ready();

      // Initializes LiteRT.js's WASM files.
      const wasmPath = 'https://unpkg.com/@litertjs/core@0.2.1/wasm/';
      const liteRt = await loadLiteRt(wasmPath);

      // Makes LiteRt use the same GPU device as TF.js (for tensor conversion).
      const backend = tf.backend();
      setWebGpuDevice(backend.device);

      // Loads model via LiteRt.
      await this.loadModel(liteRt);

      if (this.model) {
        // Prints model details to the log.
        console.log('Model Details: ', this.model.getInputDetails());
      }
      this.modelState = 'Ready';
    } catch (error) {
      console.error('Failed to load model or backend:', error);
    }
  }

  async loadModel(liteRt) {
    try {
      this.model = await liteRt.loadAndCompile(this.modelPath, {
        // Currently, only 'webgpu' is supported.
        accelerator: 'webgpu',
      });
    } catch (error) {
      this.model = null;
      console.error('Error loading model:', error);
    }
  }

  calculateRelativeHandBoneAngles(jointPositions) {
    // Reshape jointPositions
    let jointPositionsReshaped = [];

    jointPositionsReshaped = jointPositions.reshape([xb.HAND_JOINT_COUNT, 3]);

    // Calculate bone vectors
    const boneVectors = [];
    xb.HAND_JOINT_IDX_CONNECTION_MAP.forEach(([joint1, joint2]) => {
      const boneVector = jointPositionsReshaped
        .slice([joint2, 0], [1, 3])
        .sub(jointPositionsReshaped.slice([joint1, 0], [1, 3]))
        .squeeze();
      const norm = boneVector.norm();
      const normalizedBoneVector = boneVector.div(norm);
      boneVectors.push(normalizedBoneVector);
    });

    // Calculate relative hand bone angles
    const relativeHandBoneAngles = [];
    xb.HAND_BONE_IDX_CONNECTION_MAP.forEach(([bone1, bone2]) => {
      const angle = boneVectors[bone1].dot(boneVectors[bone2]);
      relativeHandBoneAngles.push(angle);
    });

    // Stack the angles into a tensor.
    return tf.stack(relativeHandBoneAngles);
  }

  async detectGesture(handJoints) {
    if (!this.model || !handJoints || handJoints.length !== 25 * 3) {
      console.log('Invalid hand joints or model load error.');
      return UNKNOWN_GESTURE;
    }

    try {
      const tensor = this.calculateRelativeHandBoneAngles(
        tf.tensor1d(handJoints)
      );

      let tensorReshaped = tensor.reshape([
        1,
        xb.HAND_BONE_IDX_CONNECTION_MAP.length,
        1,
      ]);
      var result = -1;

      result = runWithTfjsTensors(this.model, tensorReshaped);

      let integerLabel = result[0].as1D().arraySync();
      if (integerLabel.length == 7) {
        let x = integerLabel[0];
        let idx = 0;
        for (let t = 0; t < 7; ++t) {
          if (integerLabel[t] > x) {
            idx = t;
            x = integerLabel[t];
          }
        }
        return idx;
      }
    } catch (error) {
      console.error('Error:', error);
    }
    return UNKNOWN_GESTURE;
  }

  async #detectHandGestures(joints) {
    if (Object.keys(joints).length !== 25) {
      return UNKNOWN_GESTURE;
    }

    let handJointPositions = [];
    for (const i in joints) {
      handJointPositions.push(joints[i].position.x);
      handJointPositions.push(joints[i].position.y);
      handJointPositions.push(joints[i].position.z);
    }

    if (handJointPositions.length !== 25 * 3) {
      return UNKNOWN_GESTURE;
    }

    let result = await this.detectGesture(handJointPositions);
    return result;
  }

  #shiftIndexIfNeeded(joints, result) {
    // no need to shift before thumb which is 2
    result += result > 2 ? 1 : 0;
    // check thumb direction
    if (result === 2) {
      // console.log(joints["thumb-phalanx-distal"], joints["thumb-tip"]);
      let tmp = this.isThumbUpOrDown(
        joints['thumb-phalanx-distal'].position,
        joints['thumb-tip'].position
      );
      // 1 -up; -1 down; 0 - other
      result = tmp === 0 ? 0 : tmp < 0 ? result + 1 : result;
    }
    return result;
  }

  async update() {
    if (this.frameId % 5 === 0) {
      const hands = xb.user.hands;
      if (hands != null && hands.hands && hands.hands.length == 2) {
        // Left hand.
        const leftJoints = hands.hands[LEFT_HAND_INDEX].joints;
        let leftHandResult = await this.#detectHandGestures(leftJoints);
        leftHandResult = this.#shiftIndexIfNeeded(leftJoints, leftHandResult);

        // Update image and label.
        this.leftHandImage.load(GESTURE_IMAGES[leftHandResult]);
        this.leftHandLabel.setText(GESTURE_LABELS[leftHandResult]);

        // Right hand.
        const rightJoints = hands.hands[RIGHT_HAND_INDEX].joints;
        let rightHandResult = await this.#detectHandGestures(rightJoints);
        rightHandResult = this.#shiftIndexIfNeeded(
          rightJoints,
          rightHandResult
        );

        // Update image and label.
        this.rightHandImage.load(GESTURE_IMAGES[rightHandResult]);
        this.rightHandLabel.setText(GESTURE_LABELS[rightHandResult]);
      }
    }
    this.frameId++;
  }

  isThumbUpOrDown(p1, p2) {
    // Assuming p1 is the base of the thumb and p2 is the tip.

    // Vector from base to tip.
    const vector = {
      x: p2.x - p1.x,
      y: p2.y - p1.y,
      z: p2.z - p1.z,
    };

    // Calculate the magnitude of the vector.
    const magnitude = Math.sqrt(
      vector.x * vector.x + vector.y * vector.y + vector.z * vector.z
    );

    // If the magnitude is very small, it's likely not a significant gesture
    if (magnitude < 0.001) {
      return 0; // Otherwise
    }

    // Normalize the vector to get its direction.
    const normalizedVector = {
      x: vector.x / magnitude,
      y: vector.y / magnitude,
      z: vector.z / magnitude,
    };

    // Define the "up" and "down" direction vectors (positive and negative
    // Y-axis)
    const upVector = {x: 0, y: 1, z: 0};
    const downVector = {x: 0, y: -1, z: 0};

    // Angle threshold (cosine) for "up" (within 45 degrees of vertical)
    const cosUpThreshold = Math.cos((45 * Math.PI) / 180); // Approximately 0.707

    // Angle threshold (cosine) for "down" (within 45 degrees of negative
    // vertical) We need the dot product with the *down* vector to be >= cos(45
    // degrees)
    const dotDownThreshold = cosUpThreshold;

    // Calculates the dot product with the "up" vector.
    const dotUp =
      normalizedVector.x * upVector.x +
      normalizedVector.y * upVector.y +
      normalizedVector.z * upVector.z;

    // Calculates the dot product with the "down" vector (negate the y component
    // of normalized vector).
    const dotDown =
      normalizedVector.x * downVector.x +
      normalizedVector.y * downVector.y +
      normalizedVector.z * downVector.z;

    if (dotUp >= cosUpThreshold) {
      return 1; // Thumb up
    } else if (dotDown >= dotDownThreshold) {
      return -1; // Thumb down
    } else {
      return 0; // Otherwise
    }
  }
}

(example: ../xrblocks/samples/gestures_custom/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Custom Hand Gestures | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "@tensorflow/tfjs-core": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core/+esm",
          "@tensorflow/tfjs": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/+esm",
          "@tensorflow/tfjs-backend-webgpu": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu/+esm",
          "@litertjs/core": "https://unpkg.com/@litertjs/core@0.2.1",
          "@litertjs/tfjs-interop": "https://unpkg.com/@litertjs/tfjs-interop@1.0.1",
          "@litertjs/wasm-utils": "https://unpkg.com/@litertjs/wasm-utils@0.2.1",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/gestures_custom/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {CustomGestureDemo} from './CustomGestureDemo.js';

const options = new xb.Options({
  antialias: true,
  reticles: {enabled: true},
  visualizeRays: false,
  hands: {enabled: true, visualization: false},
  simulator: {defaultMode: xb.SimulatorMode.POSE},
});

async function start() {
  options.setAppTitle('Custom Gestures');
  xb.add(new CustomGestureDemo());
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  setTimeout(function () {
    start();
  }, 200);
});



Sample: gestures_heuristic
(example: ../xrblocks/samples/gestures_heuristic/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Gestures: Heuristic HUD | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/gestures_heuristic/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';
import * as THREE from 'three';

const options = new xb.Options();
options.enableReticles();
options.enableGestures();

options.gestures.setGestureEnabled('point', true);
options.gestures.setGestureEnabled('spread', true);

options.hands.enabled = true;
options.hands.visualization = true;
options.hands.visualizeJoints = true;
options.hands.visualizeMeshes = true;

options.simulator.defaultMode = xb.SimulatorMode.POSE;

function createHudElement() {
  const style = document.createElement('style');
  style.textContent = `
    #gesture-hud {
      position: fixed;
      top: 12px;
      right: 12px;
      min-width: 220px;
      padding: 12px;
      border-radius: 12px;
      background: rgba(10, 12, 20, 0.82);
      color: #f4f4f4;
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
      z-index: 9999;
    }
    #gesture-hud h2 {
      margin: 0 0 8px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.01em;
    }
    #gesture-hud .hand-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.04);
      margin-bottom: 6px;
    }
    #gesture-hud .hand-row:last-child {
      margin-bottom: 0;
    }
    #gesture-hud .hand-label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 11px;
      opacity: 0.75;
    }
    #gesture-hud .gesture {
      font-weight: 700;
    }
    #gesture-hud .gesture[data-active="false"] {
      opacity: 0.65;
    }
  `;
  document.head.appendChild(style);

  const container = document.createElement('div');
  container.id = 'gesture-hud';
  container.innerHTML = `
    <h2>Gestures</h2>
    <div class="hand-row">
      <span class="hand-label">Left</span>
      <span class="gesture" data-hand="left" data-active="false">None</span>
    </div>
    <div class="hand-row">
      <span class="hand-label">Right</span>
      <span class="gesture" data-hand="right" data-active="false">None</span>
    </div>
  `;
  document.body.appendChild(container);
  return container;
}

class GestureLogger extends xb.Script {
  init() {
    const gestures = xb.core.gestureRecognition;
    if (!gestures) {
      console.warn(
        '[GestureLogger] GestureRecognition is unavailable. ' +
          'Make sure options.enableGestures() is called before xb.init().'
      );
      return;
    }
    this._onGestureStart = (event) => {
      const {hand, name, confidence = 0} = event.detail;
      console.log(
        `[gesture] ${hand} hand started ${name} (${confidence.toFixed(2)})`
      );
    };
    this._onGestureEnd = (event) => {
      const {hand, name} = event.detail;
      console.log(`[gesture] ${hand} hand ended ${name}`);
    };
    gestures.addEventListener('gesturestart', this._onGestureStart);
    gestures.addEventListener('gestureend', this._onGestureEnd);
    this.add(new THREE.HemisphereLight(0xaaaaaa, 0x666666, 3));
  }

  dispose() {
    const gestures = xb.core.gestureRecognition;
    if (!gestures) return;
    if (this._onGestureStart) {
      gestures.removeEventListener('gesturestart', this._onGestureStart);
    }
    if (this._onGestureEnd) {
      gestures.removeEventListener('gestureend', this._onGestureEnd);
    }
  }
}

class GestureHUD extends xb.Script {
  init() {
    this._container = createHudElement();
    this._active = {
      left: new Map(),
      right: new Map(),
    };
    this._labels = {
      left: this._container.querySelector('[data-hand="left"]'),
      right: this._container.querySelector('[data-hand="right"]'),
    };

    const gestures = xb.core.gestureRecognition;
    if (!gestures) {
      console.warn(
        '[GestureHUD] GestureRecognition is unavailable. ' +
          'Make sure options.enableGestures() is called before xb.init().'
      );
      return;
    }

    const update = (event) => {
      const {name, hand, confidence = 0} = event.detail;
      this._active[hand].set(name, confidence);
      this._refresh(hand);
    };
    const clear = (event) => {
      const {name, hand} = event.detail;
      this._active[hand].delete(name);
      this._refresh(hand);
    };

    this._onGestureStart = update;
    this._onGestureUpdate = update;
    this._onGestureEnd = clear;

    gestures.addEventListener('gesturestart', this._onGestureStart);
    gestures.addEventListener('gestureupdate', this._onGestureUpdate);
    gestures.addEventListener('gestureend', this._onGestureEnd);
  }

  _refresh(hand) {
    const label = this._labels[hand];
    if (!label) return;
    const entries = this._active[hand];
    if (!entries || entries.size === 0) {
      label.dataset.active = 'false';
      label.textContent = 'None';
      return;
    }
    let topGesture = 'None';
    let topConfidence = 0;
    for (const [name, confidence] of entries.entries()) {
      if (confidence >= topConfidence) {
        topGesture = name;
        topConfidence = confidence;
      }
    }
    label.dataset.active = 'true';
    label.textContent = `${topGesture} (${topConfidence.toFixed(2)})`;
  }

  dispose() {
    const gestures = xb.core.gestureRecognition;
    if (gestures) {
      if (this._onGestureStart) {
        gestures.removeEventListener('gesturestart', this._onGestureStart);
      }
      if (this._onGestureUpdate) {
        gestures.removeEventListener('gestureupdate', this._onGestureUpdate);
      }
      if (this._onGestureEnd) {
        gestures.removeEventListener('gestureend', this._onGestureEnd);
      }
    }
    if (this._container?.parentElement) {
      this._container.parentElement.removeChild(this._container);
    }
  }
}

async function start() {
  options.setAppTitle('Heuristic Gestures');
  xb.add(new GestureLogger());
  xb.add(new GestureHUD());
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', () => {
  start();
});



Sample: lighting
(example: ../xrblocks/samples/lighting/LightingScene.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';
import {ModelManager} from 'xrblocks/addons/ui/ModelManager.js';

import {ANIMALS_DATA} from './animals_data.js';

export class LightingScene extends xb.Script {
  constructor() {
    super();
    this.pointer = new THREE.Vector3();
    this.raycaster = new THREE.Raycaster();
    this.modelManager = new ModelManager(
      ANIMALS_DATA,
      /*enableOcclusion=*/ true
    );
    this.modelManager.layers.enable(xb.OCCLUDABLE_ITEMS_LAYER);
    this.add(this.modelManager);
  }
  init() {
    xb.core.input.addReticles();
    xb.showReticleOnDepthMesh(true);
  }
  updatePointerPosition(event) {
    // (-1 to +1) for both components
    this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // scale pointer.x from [-1, 0] to [-1, 1]
    this.pointer.x = 1 + 2 * this.pointer.x;
  }
  onSelectStart(event) {
    const controller = event.target;
    if (xb.core.input.intersectionsForController.get(controller).length > 0) {
      const intersection =
        xb.core.input.intersectionsForController.get(controller)[0];
      if (intersection.handleSelectRaycast) {
        intersection.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object.handleSelectRaycast) {
        intersection.object.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object == xb.core.depth.depthMesh) {
        this.onDepthMeshSelectStart(intersection);
        return;
      }
    }
  }
  onDepthMeshSelectStart(intersection) {
    console.log('Depth mesh select intersection:', intersection.point);
    this.modelManager.positionModelAtIntersection(intersection, xb.core.camera);
  }
  onPointerDown(event) {
    this.updatePointerPosition(event);
    const cameras = xb.core.renderer.xr.getCamera().cameras;
    if (cameras.length == 0) return;
    const camera = cameras[0];
    this.raycaster.setFromCamera(this.pointer, camera);
    const intersections = this.raycaster.intersectObjects(
      xb.core.input.reticleTargets
    );
    for (let intersection of intersections) {
      if (intersection.handleSelectRaycast) {
        intersection.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object.handleSelectRaycast) {
        intersection.object.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object == xb.core.depth.depthMesh) {
        this.modelManager.positionModelAtIntersection(intersection, camera);
        return;
      }
    }
  }
}

(example: ../xrblocks/samples/lighting/animals_data.js)
export const ANIMALS_DATA = [
  {
    path: 'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/',
    model: 'models/Cat/cat.gltf',
    thumbnail: 'thumbnail.png',
  },
];

(example: ../xrblocks/samples/lighting/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Lighting Estimation | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "@material/web/": "https://esm.run/@material/web/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/lighting/main.js)
import * as xb from 'xrblocks';

import {LightingScene} from './LightingScene.js';

// Set up depth mesh optinos. Need depth mesh to render shadows to.
let options = new xb.Options();
options.depth = new xb.DepthOptions(xb.xrDepthMeshOptions);
options.depth.enabled = true;
options.depth.depthMesh.enabled = true;
options.depth.depthTexture.enabled = true;
options.depth.depthMesh.updateFullResolutionGeometry = true;
options.depth.depthMesh.renderShadow = true;
options.depth.depthMesh.shadowOpacity = 0.6;
options.depth.occlusion.enabled = true;

// Set up lighting options.
options.lighting = new xb.LightingOptions(xb.xrLightingOptions);
options.lighting.enabled = true;
options.lighting.useAmbientSH = true;
options.lighting.useDirectionalLight = true;
options.lighting.castDirectionalLightShadow = true;
options.lighting.useDynamicSoftShadow = false;

options.xrButton = {
  ...options.xrButton,
  startText: '<i id="xrlogo"></i> BRING IT TO LIFE',
  endText: '<i id="xrlogo"></i> MISSION COMPLETE',
};
async function start() {
  const lightingScene = new LightingScene();
  options.setAppTitle('Lighting Estimation');
  await xb.init(options);
  xb.add(lightingScene);
  window.addEventListener(
    'pointerdown',
    lightingScene.onPointerDown.bind(lightingScene)
  );
}
document.addEventListener('DOMContentLoaded', function () {
  start();
});



Sample: modelviewer
(example: ../xrblocks/samples/modelviewer/ModelViewerScene.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

const kLightX = xb.getUrlParamFloat('lightX', 0);
const kLightY = xb.getUrlParamFloat('lightY', 500);
const kLightZ = xb.getUrlParamFloat('lightZ', -10);

const ASSETS_BASE_URL = 'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/';
const PROPRIETARY_ASSETS_BASE_URL =
  'https://cdn.jsdelivr.net/gh/xrblocks/proprietary-assets@main/';

export class ModelViewerScene extends xb.Script {
  constructor() {
    super();
  }

  async init() {
    xb.core.input.addReticles();
    this.addLights();
    this.createModelFromObject();
    await Promise.all([
      this.createModelFromGLTF(),
      this.createModelFromAnimatedGLTF(),
      this.createModelFromSplat(),
      this.createModelInPanel(),
    ]);
  }

  addLights() {
    this.add(new THREE.HemisphereLight(0xbbbbbb, 0x888888, 3));
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(kLightX, kLightY, kLightZ);
    this.add(light);
  }

  createModelFromObject() {
    const model = new xb.ModelViewer({});
    model.add(
      new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 0.4),
        new THREE.MeshPhongMaterial({color: 0xdb5461})
      )
    );
    model.setupBoundingBox();
    model.setupRaycastCylinder();
    model.setupPlatform();
    model.position.set(-0.15, 0.75, -1.65);
    this.add(model);
  }

  async createModelFromGLTF() {
    const model = new xb.ModelViewer({});
    this.add(model);
    await model.loadGLTFModel({
      data: {
        scale: {x: 0.009, y: 0.009, z: 0.009},
        path: PROPRIETARY_ASSETS_BASE_URL,
        model: 'chess/chess_compressed.glb',
      },
      renderer: xb.core.renderer,
    });
    model.position.set(0, 0.78, -1.1);
  }

  async createModelFromAnimatedGLTF() {
    const model = new xb.ModelViewer({});
    this.add(model);
    await model.loadGLTFModel({
      data: {
        scale: {x: 1.0, y: 1.0, z: 1.0},
        path: ASSETS_BASE_URL,
        model: 'models/Cat/cat.gltf',
      },
      renderer: xb.core.renderer,
    });
    model.position.set(0.9, 0.68, -0.95);
  }

  async createModelFromSplat() {
    const model = new xb.ModelViewer({castShadow: false, receiveShadow: false});
    this.add(model);
    await model.loadSplatModel({
      data: {
        model: PROPRIETARY_ASSETS_BASE_URL + 'lego/lego.spz',
        scale: {x: 0.6, y: 0.6, z: 0.6},
        rotation: {x: 0, y: 180, z: 0},
      },
    });
    model.position.set(0.4, 0.78, -1.1);
    model.rotation.set(0, -Math.PI / 6, 0);
  }

  async createModelInPanel() {
    const panel = new xb.SpatialPanel({
      backgroundColor: '#00000000',
      width: 0.5,
      height: 0.25,
      useDefaultPosition: false,
    });
    panel.isRoot = true;
    this.add(panel);
    panel.position.set(0, 1.5, -2.0);

    panel.updateLayouts();

    const model = new xb.ModelViewer({});
    panel.add(model);
    await model.loadGLTFModel({
      data: {
        scale: {x: 0.002, y: 0.002, z: 0.002},
        rotation: {x: 0, y: 180, z: 0},
        path: PROPRIETARY_ASSETS_BASE_URL,
        model: 'earth/Earth_1_12756.glb',
      },
      setupPlatform: false,
      renderer: xb.core.renderer,
    });
  }
}

(example: ../xrblocks/samples/modelviewer/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Model Viewer | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/",
          "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js"
        }
      }
    </script>
  </head>

  <body>
    <div class="background-image" style="background-color: #000000"></div>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/modelviewer/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import {html} from 'lit';
import * as xb from 'xrblocks';

import {ModelViewerScene} from './ModelViewerScene.js';

document.addEventListener('DOMContentLoaded', async () => {
  const modelViewerScene = new ModelViewerScene();
  xb.add(modelViewerScene);
  const options = new xb.Options();
  options.simulator.instructions.customInstructions = [
    {
      header: html`<h1>Model Viewer</h1>`,
      videoSrc: 'model_viewer_simulator_usage.webm',
      description: html`Click or pinch the object to rotate. Drag the platform
      to move.`,
    },
  ];
  options.setAppTitle('Model Viewer');
  await xb.init(options);
});



Sample: paint
(example: ../xrblocks/samples/paint/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Paint | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/paint/main.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as THREE from 'three';
import {TubePainter} from 'three/addons/misc/TubePainter.js';
import * as xb from 'xrblocks';

/**
 * A remixed version of three.js's examples/webxr_xr_paint.html in XR Blocks.
 * PaintDemo is an example script for using pinch to paint in Android XR and
 * using clicks to draw in desktop simulated environments.
 */
class PaintDemo extends xb.Script {
  init() {
    this.add(new THREE.HemisphereLight(0xffffff, 0x666666, /*intensity=*/ 3));

    // Painting setup.
    this.painters = [];
    this.user = xb.core.user;

    for (let i = 0; i < this.user.controllers.length; ++i) {
      const painter = new TubePainter();
      this.painters.push(painter);
      this.add(painter.mesh);
    }

    // Adds pivotal points to indicate user's intents.
    this.user.enablePivots();
  }

  /**
   * Moves the painter to the pivot position when select starts.
   * @param {XRInputSourceEvent} event
   */
  onSelectStart(event) {
    const id = event.target.userData.id;
    const painter = this.painters[id];
    const cursor = this.user.getPivotPosition(id);
    painter.moveTo(cursor);
  }

  /**
   * Updates the painter's line to the current pivot position during selection.
   * @param {XRInputSourceEvent} event
   */
  onSelecting(event) {
    const id = event.target.userData.id;
    const painter = this.painters[id];
    const cursor = this.user.getPivotPosition(id);
    painter.lineTo(cursor);
    painter.update();
  }

  /**
   * Stores the initial position and scale of the controller when squeeze
   * starts.
   * @param {XRInputSourceEvent} event
   */
  onSqueezeStart(event) {
    const controller = event.target;
    const id = controller.userData.id;
    const data = this.user.data[id].squeeze;

    data.positionOnStart = controller.position.y;
    data.scaleOnStart = controller.position.y;
  }

  /**
   * Updates the scale of the controller's pivot based on the squeeze amount.
   * @param {XRInputSourceEvent} event
   */
  onSqueezing(event) {
    const controller = event.target;
    const id = controller.userData.id;
    const pivot = this.user.getPivot(id);
    const data = this.user.data[id].squeeze;

    const delta = (controller.position.y - data.positionOnStart) * 5;
    const scale = Math.max(0.1, data.scaleOnStart + delta);
    pivot.scale.setScalar(scale);
  }
}

/**
 * Entry point for the application.
 */
function start() {
  const options = new xb.Options();
  options.setAppTitle('XR Paint');
  xb.add(new PaintDemo());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', start);



Sample: reticle
(example: ../xrblocks/samples/reticle/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Reticle | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/reticle/main.js)
import * as xb from 'xrblocks';
import {TextBillboard} from 'xrblocks/addons/ui/TextBillboard.js';

class ReticleVisualizer extends xb.Script {
  activeControllerToBillboardMap = new Map();

  init() {
    xb.showReticleOnDepthMesh(true);
  }

  onSelectStart(event) {
    const controller = event.target;
    const intersection = xb.core.user.select(
      xb.core.depth.depthMesh,
      controller
    );
    if (!intersection) return;
    const billboard = new TextBillboard();
    this.add(billboard);
    this.activeControllerToBillboardMap.set(controller, billboard);
    this.updateBillboard(controller, billboard);
  }

  onSelectEnd(event) {
    this.activeControllerToBillboardMap.delete(event.target);
  }

  update() {
    this.activeControllerToBillboardMap.forEach((billboard, controller) => {
      this.updateBillboard(controller, billboard);
    });
  }

  updateBillboard(controller, billboard) {
    const intersection = xb.core.user.select(
      xb.core.depth.depthMesh,
      controller
    );
    if (intersection) {
      const reticleHeight = intersection.point.y;
      billboard.position.copy(intersection.point);
      billboard.lookAt(xb.core.camera.position);
      billboard.updateText(
        `Distance: ${intersection.distance.toFixed(2)} m\n` +
          `Height: ${reticleHeight.toFixed(2)} m`
      );
    }
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.depth = new xb.DepthOptions(xb.xrDepthMeshOptions);
  options.setAppTitle('XR Reticle');
  xb.add(new ReticleVisualizer());
  xb.init(options);
});



Sample: skybox_agent
(example: ../xrblocks/samples/skybox_agent/GeminiSkyboxGenerator.js)
/* eslint-env browser */
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as THREE from 'three';
import * as xb from 'xrblocks';

import {TranscriptionManager} from './TranscriptionManager.js';

export class GeminiSkyboxGenerator extends xb.Script {
  constructor() {
    super();
    this.transcription = null;
    this.liveAgent = null;
    this.statusText = null;
    this.defaultText =
      "I am a skybox designer agent. Describe the background you want, and I'll render it for you!";
  }

  init() {
    this.createTextDisplay();
    this.createAgent();

    this.add(new THREE.HemisphereLight(0x888877, 0x777788, 3));
    const light = new THREE.DirectionalLight(0xffffff, 5.0);
    light.position.set(-0.5, 4, 1.0);
    this.add(light);
  }

  createAgent() {
    this.liveAgent = new xb.SkyboxAgent(
      xb.core.ai,
      xb.core.sound,
      xb.core.scene,
      {
        onSessionStart: () => {
          this.updateButtonState();
          this.updateStatus('Session started - Ready to listen');
        },
        onSessionEnd: () => {
          this.updateButtonState();
          this.transcription?.clear();
          this.transcription?.setText(this.defaultText);
          this.updateStatus('Session ended');
        },
        onError: (error) => {
          this.updateStatus(`Error: ${error.message}`);
          this.transcription?.addText(`‚úó Error: ${error.message}`);
        },
      }
    );
  }

  async toggleGeminiLive() {
    const isActive = this.liveAgent?.getSessionState().isActive;
    return isActive ? this.stopGeminiLive() : this.startGeminiLive();
  }

  async startGeminiLive() {
    if (this.liveAgent?.getSessionState().isActive) return;

    try {
      this.updateStatus('Starting session...');

      // Enable audio BEFORE starting the session
      await xb.core.sound.enableAudio();

      // Start live session with callbacks
      await this.liveAgent.startLiveSession({
        onopen: () => {
          this.updateStatus('Connected - Listening...');
        },
        onmessage: (message) => this.handleAIMessage(message),
        onclose: (closeEvent) => {
          this.handleSessionClose(closeEvent);
        },
      });
    } catch (error) {
      this.updateStatus(`Failed to start: ${error.message}`);
      this.transcription?.addText(
        `Error: Failed to start AI session - ${error.message}`
      );
      await this.cleanup();
    }
  }

  async stopGeminiLive() {
    if (!this.liveAgent?.getSessionState().isActive) return;
    await this.cleanup();
  }

  handleSessionClose(closeEvent) {
    if (closeEvent.reason) {
      this.transcription?.addText(closeEvent.reason);
    }
    xb.core.sound?.disableAudio();
    xb.core.sound?.stopAIAudio();
  }

  createTextDisplay() {
    this.textPanel = new xb.SpatialPanel({
      width: 3,
      height: 1.8,
      backgroundColor: '#1a1a1abb',
    });
    const grid = this.textPanel.addGrid();

    const statusRow = grid.addRow({weight: 0.1});
    this.statusText = statusRow.addText({
      text: 'Click Start to begin',
      fontSize: 0.04,
      fontColor: '#4ecdc4',
      textAlign: 'center',
    });

    const responseDisplay = new xb.ScrollingTroikaTextView({
      text: this.defaultText,
      fontSize: 0.03,
      textAlign: 'left',
    });
    grid.addRow({weight: 0.65}).add(responseDisplay);
    this.transcription = new TranscriptionManager(responseDisplay);

    this.toggleButton = grid.addRow({weight: 0.25}).addTextButton({
      text: '‚ñ∂ Start',
      fontColor: '#ffffff',
      backgroundColor: '#006644',
      fontSize: 0.2,
    });
    this.toggleButton.onTriggered = () => this.toggleGeminiLive();

    this.textPanel.position.set(0, 1.2, -2);
    this.add(this.textPanel);
  }

  async handleAIMessage(message) {
    if (message.data) {
      xb.core.sound.playAIAudio(message.data);
    }

    const content = message.serverContent;
    if (content) {
      if (content.inputTranscription?.text) {
        this.transcription.handleInputTranscription(
          content.inputTranscription.text
        );
      }
      if (content.outputTranscription?.text) {
        this.transcription.handleOutputTranscription(
          content.outputTranscription.text
        );
      }
      if (content.turnComplete) {
        this.transcription.finalizeTurn();
      }
    }

    if (message.toolCall) {
      this.updateStatus('AI is calling a tool...');
      const functionResponses = [];

      for (const fc of message.toolCall.functionCalls) {
        const tool = this.liveAgent.findTool(fc.name);

        if (tool) {
          const promptText = fc.args?.prompt || 'custom scene';
          this.updateStatus(`Generating skybox: ${promptText}...`);

          // Small delay to ensure status is visible before long operation
          await new Promise((resolve) => setTimeout(resolve, 100));

          const result = await tool.execute(fc.args);
          const response = xb.SkyboxAgent.createToolResponse(
            fc.id,
            fc.name,
            result
          );
          functionResponses.push(response);
          if (result.success) {
            this.updateStatus('Skybox generated successfully!');
            this.transcription.addText(`‚úì ${result.data || 'Task completed'}`);
          } else {
            this.updateStatus(`Generation failed: ${result.error}`);
            this.transcription.addText(`‚úó Error: ${result.error}`);
          }
        } else {
          this.updateStatus(`Tool not found: ${fc.name}`);
          functionResponses.push({
            id: fc.id,
            name: fc.name,
            response: {error: `Tool ${fc.name} not found`},
          });
          this.transcription.addText(`‚úó Tool not found: ${fc.name}`);
        }
      }

      this.liveAgent.sendToolResponse({functionResponses});
    }
  }

  updateButtonState() {
    const isActive = this.liveAgent?.getSessionState().isActive;
    this.toggleButton?.setText(isActive ? '‚èπ Stop' : '‚ñ∂ Start');
  }

  updateStatus(message) {
    if (this.statusText) {
      this.statusText.text = message;
    }
  }

  async cleanup() {
    if (this.liveAgent?.getSessionState().isActive) {
      try {
        await this.liveAgent.stopLiveSession();
      } catch (e) {
        this.updateStatus(`Error stopping session: ${e.message}`);
      }
    }
    xb.core.sound?.disableAudio();
    xb.core.sound?.stopAIAudio();
  }

  async dispose() {
    await this.cleanup();
    super.dispose();
  }
}

async function requestAudioPermission() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: 16000,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true,
      },
    });
    stream.getTracks().forEach((track) => track.stop());
    return stream;
  } catch (error) {
    this.transcription.addText(
      `‚úó Error requesting audio permission: ${error.message}`
    );
    return null;
  }
}

async function start() {
  try {
    await requestAudioPermission();

    const options = new xb.Options();
    options.enableUI();
    options.enableHands();
    options.enableAI();
    options.setAppTitle('Generating Skybox with Gemini');

    xb.init(options);
    xb.add(new GeminiSkyboxGenerator());
  } catch (error) {
    this.transcription.addText(`‚úó Error initializing: ${error.message}`);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

(example: ../xrblocks/samples/skybox_agent/TranscriptionManager.js)
export class TranscriptionManager {
  constructor(responseDisplay) {
    this.responseDisplay = responseDisplay;
    this.currentInputText = '';
    this.currentOutputText = '';
    this.conversationHistory = [];
  }

  handleInputTranscription(text) {
    if (!text) return;
    this.currentInputText += text;
    this.updateLiveDisplay();
  }

  handleOutputTranscription(text) {
    if (!text) return;
    this.currentOutputText += text;
    this.updateLiveDisplay();
  }

  finalizeTurn() {
    if (this.currentInputText.trim()) {
      this.conversationHistory.push({
        speaker: 'You',
        text: this.currentInputText.trim(),
      });
    }
    if (this.currentOutputText.trim()) {
      this.conversationHistory.push({
        speaker: 'AI',
        text: this.currentOutputText.trim(),
      });
    }
    this.currentInputText = '';
    this.currentOutputText = '';
    this.updateFinalDisplay();
  }

  updateLiveDisplay() {
    let displayText = '';
    for (const entry of this.conversationHistory.slice(-2)) {
      displayText += `${entry.speaker}: ${entry.text}\n\n`;
    }
    if (this.currentInputText.trim()) {
      displayText += `You: ${this.currentInputText}`;
    }
    if (this.currentOutputText.trim()) {
      if (this.currentInputText.trim()) displayText += '\n\n';
      displayText += `AI: ${this.currentOutputText}`;
    }
    this.responseDisplay?.setText(displayText);
  }

  updateFinalDisplay() {
    let displayText = '';
    for (const entry of this.conversationHistory) {
      displayText += `${entry.speaker}: ${entry.text}\n\n`;
    }
    this.responseDisplay?.setText(displayText);
  }

  clear() {
    this.currentInputText = '';
    this.currentOutputText = '';
    this.conversationHistory = [];
  }

  addText(text) {
    this.responseDisplay?.addText(text + '\n\n');
  }

  setText(text) {
    this.responseDisplay?.setText(text);
  }
}

(example: ../xrblocks/samples/skybox_agent/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Gemini Live Skybox Agent | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="GeminiSkyboxGenerator.js"></script>
  </body>
</html>



Sample: sound
(example: ../xrblocks/samples/sound/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Sound Sample | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/sound/main.js)
/* eslint-env browser */
import * as THREE from 'three';
import * as xb from 'xrblocks';

class SoundDemoScript extends xb.Script {
  constructor() {
    super();
    this.soundBalls = [];
    this.mainPanel = null;
    this.recordedAudioBuffer = null;
    this.isRecording = false;
    this.recordBtn = null;
    this.statusText = null;
    this.volumeText = null;
    this.recordingStartTime = 0;
    this.currentVolume = 1.0;
    this.ballJumpPhase = 0;
  }

  init() {
    this.createSoundBalls();
    this.createDemoUI();

    const light = new THREE.DirectionalLight(0xffffff, 1.5);
    light.position.set(0, 3, 0);
    this.add(light);

    const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
    this.add(ambientLight);
  }

  createSoundBalls() {
    const ballPositions = [
      {x: -1.0, y: xb.user.height * 0.5, z: -1.5, color: 0xff6b6b},
      {x: 0.0, y: xb.user.height * 0.5, z: -1.5, color: 0x4ecdc4},
      {x: 1.0, y: xb.user.height * 0.5, z: -1.5, color: 0xffe66d},
    ];

    ballPositions.forEach((pos, index) => {
      const geometry = new THREE.SphereGeometry(0.1, 32, 32);
      const material = new THREE.MeshStandardMaterial({
        color: pos.color,
        metalness: 0.3,
        roughness: 0.4,
      });
      const ball = new THREE.Mesh(geometry, material);
      ball.position.set(pos.x, pos.y, pos.z);
      ball.userData.soundIndex = index;
      ball.name = `SoundBall${index}`;
      this.add(ball);
      this.soundBalls.push(ball);
    });
  }

  createDemoUI() {
    this.mainPanel = new xb.SpatialPanel({
      backgroundColor: '#1a1a1aF0',
      useDefaultPosition: false,
      showEdge: true,
      width: 1.0,
      height: 0.8,
    });
    this.mainPanel.isRoot = true;
    this.mainPanel.position.set(
      0,
      xb.user.height + 0.2,
      -xb.user.panelDistance
    );
    this.add(this.mainPanel);

    const mainGrid = this.mainPanel.addGrid();

    const titleRow = mainGrid.addRow({weight: 0.18});
    titleRow.addText({
      text: 'Sound Recorder',
      fontSize: 0.08,
      fontColor: '#4ecdc4',
    });

    const statusRow = mainGrid.addRow({weight: 0.15});
    this.statusText = statusRow.addText({
      text: 'Click mic to record',
      fontSize: 0.05,
      fontColor: '#ffe66d',
    });

    mainGrid.addRow({weight: 0.1});

    const controlRow = mainGrid.addRow({weight: 0.35});

    {
      const recordCol = controlRow.addCol({weight: 0.4});
      this.recordBtn = recordCol.addIconButton({
        text: 'mic',
        fontSize: 0.5,
      });

      this.recordBtn.onTriggered = () => {
        this.toggleRecording();
      };
    }

    {
      const volDownCol = controlRow.addCol({weight: 0.2});
      const volDownBtn = volDownCol.addIconButton({
        text: 'remove',
        fontSize: 0.5,
      });

      volDownBtn.onTriggered = () => {
        this.adjustVolume(-0.1);
      };
    }

    {
      const volDisplayCol = controlRow.addCol({weight: 0.2});
      this.volumeText = volDisplayCol.addText({
        text: '100%',
        fontSize: 0.5,
        fontColor: '#4ecdc4',
      });
    }

    {
      const volUpCol = controlRow.addCol({weight: 0.2});
      const volUpBtn = volUpCol.addIconButton({
        text: 'add',
        fontSize: 0.5,
      });

      volUpBtn.onTriggered = () => {
        this.adjustVolume(0.1);
      };
    }

    const bottomRow = mainGrid.addRow({weight: 0.2});
    bottomRow.addText({
      text: 'Click jumping balls to play',
      fontSize: 0.045,
      fontColor: '#888888',
    });

    if (this.mainPanel) {
      this.mainPanel.updateLayouts();
    }
  }

  async toggleRecording() {
    if (this.isRecording) {
      this.isRecording = false;
      this.updateStatus('Stopping recording...');
      await new Promise((resolve) => setTimeout(resolve, 300));
      this.recordedAudioBuffer = xb.core.sound.stopRecording();

      if (this.recordedAudioBuffer && this.recordedAudioBuffer.byteLength > 0) {
        const duration = (
          (Date.now() - this.recordingStartTime) /
          1000
        ).toFixed(1);
        this.updateStatus(`Recorded ${duration}s - Click balls to play`);
      } else {
        this.recordedAudioBuffer = null;
        this.updateStatus('Recording failed - no data captured');
      }

      this.recordBtn.text = 'mic';
    } else {
      // Start recording using SDK
      try {
        await xb.core.sound.startRecording();

        this.isRecording = true;
        this.recordingStartTime = Date.now();
        this.updateStatus('Recording... Click mic again to stop');
        this.recordBtn.text = 'mic_off';
      } catch (error) {
        this.updateStatus('Recording failed - ' + error);
        this.isRecording = false;
      }
    }
  }

  async playRecording() {
    if (!this.recordedAudioBuffer) {
      this.updateStatus('No recording - click mic first!');
      return;
    }

    try {
      this.updateStatus('Playing recording...');

      const sampleRate = xb.core.sound.getRecordingSampleRate();
      await xb.core.sound.playRecordedAudio(
        this.recordedAudioBuffer,
        sampleRate
      );

      setTimeout(() => {
        if (!this.isRecording) {
          this.updateStatus('Click mic to record');
        }
      }, 2000);
    } catch (error) {
      this.updateStatus('Playback failed: ' + error);
    }
  }

  adjustVolume(delta) {
    this.currentVolume = Math.max(0, Math.min(1, this.currentVolume + delta));
    const volumePercent = Math.round(this.currentVolume * 100);

    xb.core.sound.setMasterVolume(this.currentVolume);

    if (this.volumeText) {
      this.volumeText.text = `${volumePercent}%`;
    }

    this.updateStatus(`Volume: ${volumePercent}%`);
  }

  updateStatus(message) {
    if (this.statusText) {
      this.statusText.text = message;
    }
  }

  onSelectStart(event) {
    const controller = event.target;

    this.soundBalls.forEach((ball) => {
      const intersection = xb.core.user.select(ball, controller);
      if (intersection) {
        if (this.recordedAudioBuffer) {
          this.playRecordingFromBall(ball);
          this.updateStatus(
            `Playing from ball ${ball.userData.soundIndex + 1}`
          );
        } else {
          this.updateStatus('Record something first!');
        }

        this.pulseBall(ball);
      }
    });
  }

  async playRecordingFromBall(ball) {
    if (!this.recordedAudioBuffer) return;

    try {
      const sampleRate = xb.core.sound.getRecordingSampleRate();
      const audioListener = xb.core.sound.getAudioListener();

      const audioContext = new AudioContext({sampleRate: sampleRate});

      const int16Data = new Int16Array(this.recordedAudioBuffer);
      const audioBuffer = audioContext.createBuffer(
        1,
        int16Data.length,
        sampleRate
      );
      const channelData = audioBuffer.getChannelData(0);
      for (let i = 0; i < int16Data.length; i++) {
        channelData[i] = int16Data[i] / 32768.0;
      }

      const positionalAudio = new THREE.PositionalAudio(audioListener);
      positionalAudio.setBuffer(audioBuffer);
      positionalAudio.setRefDistance(0.5);
      positionalAudio.setRolloffFactor(2.0);
      positionalAudio.setVolume(this.currentVolume);

      ball.add(positionalAudio);
      positionalAudio.play();

      positionalAudio.onEnded = () => {
        ball.remove(positionalAudio);
        audioContext.close();
      };
    } catch (error) {
      this.updateStatus('Play recording from ball failed: ' + error);
    }
  }

  pulseBall(ball) {
    const originalScale = ball.scale.clone();
    const targetScale = originalScale.clone().multiplyScalar(1.3);
    const startTime = Date.now();
    const duration = 200;

    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);

      if (progress < 0.5) {
        const t = progress * 2;
        ball.scale.lerpVectors(originalScale, targetScale, t);
      } else {
        const t = (progress - 0.5) * 2;
        ball.scale.lerpVectors(targetScale, originalScale, t);
      }

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        ball.scale.copy(originalScale);
      }
    };

    animate();
  }

  update() {
    this.soundBalls.forEach((ball, index) => {
      ball.rotation.y += 0.01 * (index + 1);

      if (this.recordedAudioBuffer) {
        this.ballJumpPhase += 0.01;
        const jumpHeight = 0.08;
        const baseHeight = xb.user.height * 0.5;
        const jumpOffset =
          Math.abs(Math.sin(this.ballJumpPhase + (index * Math.PI) / 3)) *
          jumpHeight;
        ball.position.y = baseHeight + jumpOffset;

        const targetScale = 1.1;
        ball.scale.lerp(
          new THREE.Vector3(targetScale, targetScale, targetScale),
          0.1
        );
      } else {
        const baseHeight = xb.user.height * 0.5;
        ball.position.y = baseHeight;
        ball.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
      }
    });
  }

  destroy() {
    if (this.isRecording) {
      xb.core.sound.disableAudio();
    }
    super.destroy();
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.reticles.enabled = true;
  options.controllers.visualizeRays = true;
  options.setAppTitle('XR Sound');

  xb.add(new SoundDemoScript());
  xb.init(options);
});



Sample: ui
(example: ../xrblocks/samples/ui/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>UI Panels Showcase | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js"
        }
      }
    </script>
  </head>

  <body>
    <canvas
      id="barChartCanvas"
      width="512"
      height="340"
      style="display: none"
    ></canvas>
    <script type="module">
      import * as THREE from 'three';
      import * as xb from 'xrblocks';

      class MainScript extends xb.Script {
        createProfilePanel() {
          const profilePanel = new xb.SpatialPanel({
            width: 0.8,
            height: 1.0,
            backgroundColor: '#282c3488',
          });
          profilePanel.rotation.set(0, 45, 0);
          profilePanel.position.set(-1.5, 1.5, -2.0);
          this.add(profilePanel);

          const profileGrid = profilePanel.addGrid();
          profileGrid.addRow({weight: 0.1}).addText({
            text: 'UI Samples',
            fontSize: 0.07,
            fontColor: '#61dafb',
          });

          const avatarRow = profileGrid.addRow({weight: 0.4});
          avatarRow.addCol({weight: 0.15});
          const avatarCol = avatarRow.addCol({weight: 0.7});
          avatarCol.addImage({
            src: 'https://placehold.co/256x128/61dafb/282c34.png?text=XRBlocks',
          });

          profileGrid
            .addRow({weight: 0.15})
            .addText({text: 'Spatial Panel', fontSize: 0.08});
          profileGrid.addRow({weight: 0.25}).addText({
            text: 'You may drag borders of this spatial panel to move it around.',
            fontSize: 0.07,
            fontColor: '#abb2bf',
          });
        }

        createProfilePanelFromJSON() {
          const profilePanelJson = {
            type: 'Panel',
            options: {
              name: 'JSON Panel',
              width: 1.0,
              height: 1.2,
              backgroundColor: '#282c3488',
            },
            position: {x: 1.5, y: 1.5, z: -2.0},
            rotation: {x: 0, y: -45, z: 0},
            children: [
              {
                name: 'JSON Grid',
                type: 'Grid',
                children: [
                  {
                    // Padding Row
                    type: 'Row',
                    options: {weight: 0.1},
                  },
                  {
                    // Title Row
                    type: 'Row',
                    options: {weight: 0.1},
                    children: [
                      {
                        type: 'Text',
                        options: {
                          text: 'Panel',
                          fontSize: 0.07,
                          fontColor: '#61dafb',
                        },
                      },
                    ],
                  },
                  {
                    // Avatar Row
                    type: 'Row',
                    options: {weight: 0.4, name: 'AvatarRow'},
                    children: [
                      {
                        type: 'Col',
                        options: {weight: 0.15},
                      }, // Left spacer
                      {
                        type: 'Col',
                        options: {weight: 0.7},
                        children: [
                          {
                            type: 'Image',
                            options: {
                              name: 'PlaceHolderImage',
                              src: 'https://placehold.co/256x128/61dafb/282c34.png?text=XRBlocks',
                            },
                          },
                        ],
                      },
                      {
                        type: 'Col',
                        options: {weight: 0.15},
                      }, // Right spacer
                    ],
                  },
                  {
                    // Name Row
                    type: 'Row',
                    options: {weight: 0.15},
                    children: [
                      {
                        type: 'Text',
                        options: {text: 'Panel from JSON', fontSize: 0.08},
                      },
                    ],
                  },
                  {
                    // Subtitle Row
                    type: 'Row',
                    options: {weight: 0.25},
                    children: [
                      {
                        type: 'Text',
                        options: {
                          text: 'This panel cannot be dragged around.',
                          fontSize: 0.07,
                          fontColor: '#abb2bf',
                        },
                      },
                    ],
                  },
                ],
              },
            ],
          };

          const profileUI = xb.core.ui.compose(profilePanelJson);
          this.add(profileUI);
        }

        createPlayerPanel() {
          // Panel 2: Interactive Media Player (Top-Center)
          const panel = new xb.SpatialPanel({
            width: 1.3,
            height: 1.25,
            backgroundColor: '#00000000',
          });
          panel.position.set(
            0,
            xb.user.height * 2.0,
            -xb.user.panelDistance - 1.0
          );
          panel.isRoot = true;
          this.add(panel);
          const grid = panel.addGrid();
          // Space for orbiter
          grid.addRow({weight: 0.0});
          // player row
          const playerRow = grid.addRow({weight: 1.0});
          const playerPanel = playerRow.addPanel({
            width: 1.2,
            height: 1.2,
            backgroundColor: '#21252baa',
          });
          const playerGrid = playerPanel.addGrid();
          {
            // video row
            playerGrid.addRow({weight: 0.1});
            const videoRow = playerGrid.addRow({weight: 0.5});
            videoRow.addVideo({
              src: 'https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
            });
            // progress row
            const progressRow = playerGrid.addRow({weight: 0.05});
            // controls row
            const controlsRow = playerGrid.addRow({weight: 0.35});
            controlsRow.addCol({weight: 0.2});
            controlsRow
              .addCol({weight: 0.2})
              .addIconButton({text: 'skip_previous', fontSize: 0.4});
            controlsRow
              .addCol({weight: 0.2})
              .addIconButton({text: 'play_arrow', fontSize: 0.6});
            controlsRow
              .addCol({weight: 0.2})
              .addIconButton({text: 'skip_next', fontSize: 0.4});
            controlsRow.addCol({weight: 0.2});
          }
          const orbiter = playerGrid.addOrbiter({
            orbiterScale: 0.1,
          });
          orbiter.addExitButton();
          panel.updateLayouts();
        }

        createSettingsPanel() {
          // Panel 3: Settings Menu (Top-Right)
          const settingsPanel = new xb.SpatialPanel({
            width: 1.0,
            height: 1.2,
            backgroundColor: '#282c3488',
          });
          settingsPanel.position.set(
            1.5,
            xb.user.height,
            -xb.user.panelDistance + 2.0
          );
          settingsPanel.rotation.set(0, -Math.PI / 2.0, 0);

          this.add(settingsPanel);
          const settingsGrid = settingsPanel.addGrid();
          settingsGrid.addRow({weight: 0.15}).addText({
            text: 'Fake Settings',
            fontSize: 0.1,
            fontColor: '#61dafb',
          });

          const addSettingRow = (grid, label, type) => {
            const row = grid.addRow({weight: 0.2});
            row.addCol({weight: 0.6}).addText({
              text: label,
              anchorX: 'left',
              textAlign: 'left',
              fontSize: 0.07,
            });
            const controlCol = row.addCol({weight: 0.4});
            if (type === 'toggle') {
              const toggleBg = controlCol.addPanel({
                backgroundColor: '#61dafb',
                width: 0.3,
                height: 0.06,
              });
              toggleBg.addGrid().addPanel({
                backgroundColor: '#ffffff',
                width: 0.05,
                height: 0.05,
                x: 0.04,
              });
            } else if (type === 'slider') {
              const sliderBg = controlCol.addPanel({
                backgroundColor: '#3a3f4b',
                width: 0.35,
                height: 0.02,
              });
              sliderBg.addGrid().addPanel({
                backgroundColor: '#61dafb',
                width: 0.04,
                height: 0.04,
                x: 0.05,
              });
            }
          };

          addSettingRow(settingsGrid, 'Enable Hand Tracking', 'toggle');
          addSettingRow(settingsGrid, 'Show Notifications', 'toggle');
          addSettingRow(settingsGrid, 'Master Volume', 'slider');
          addSettingRow(settingsGrid, 'UI Scale', 'slider');
        }

        createGalleryPanel() {
          // Panel 4: Photo Gallery (Bottom-Right)
          const galleryPanel = new xb.SpatialPanel({
            width: 1.5,
            height: 1.0,
            backgroundColor: '#21252b88',
          });
          galleryPanel.position.set(
            0.0,
            xb.user.height,
            -xb.user.panelDistance - 1.0
          );
          this.add(galleryPanel);
          const galleryGrid = galleryPanel.addGrid();
          galleryGrid.addRow({weight: 0.25}).addText({
            text: 'Photo Gallery',
            fontSize: 0.07,
            fontColor: '#61dafb',
          });
          const photoRow1 = galleryGrid.addRow({weight: 0.375});
          photoRow1.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/92c5fd/333?text=Img1',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          photoRow1.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/6ee7b7/333?text=Img2',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          photoRow1.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/fca5a5/333?text=Img3',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          galleryGrid.addRow({weight: 0.05});
          const photoRow2 = galleryGrid.addRow({weight: 0.375});
          photoRow2.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/fde047/333?text=Img4',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          photoRow2.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/c4b5fd/333?text=Img5',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          photoRow2.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/f9a8d4/333?text=Img6',
            paddingX: 0.02,
            paddingY: 0.02,
          });
        }

        createFormPanel() {
          // Panel 5: Complex Form (Bottom-Left)
          const formPanel = new xb.SpatialPanel({
            width: 1.2,
            height: 1.4,
            backgroundColor: '#282c34',
          });
          formPanel.position.set(-1.8, 0.7, -2.5);
          this.add(formPanel);
          const formGrid = formPanel.addGrid();
          formGrid.addRow({weight: 0.1}).addText({
            text: 'Feedback Form',
            fontSize: 0.07,
            fontColor: '#61dafb',
          });
          const addFormField = (grid, label) => {
            const row = grid.addRow({weight: 0.12});
            row
              .addCol({weight: 0.3})
              .addText({text: label, anchorX: 'left', fontSize: 0.05});
            row
              .addCol({weight: 0.7})
              .addPanel({backgroundColor: '#3a3f4b', height: 0.06});
          };
          addFormField(formGrid, 'Name');
          addFormField(formGrid, 'Email');
          const categoryRow = formGrid.addRow({weight: 0.12});
          categoryRow
            .addCol({weight: 0.3})
            .addText({text: 'Category', anchorX: 'left', fontSize: 0.05});
          const dropdown = categoryRow
            .addCol({weight: 0.7})
            .addPanel({backgroundColor: '#3a3f4b', height: 0.06});
          dropdown
            .addGrid()
            .addText({text: 'General Feedback  ‚ñº', fontSize: 0.045});

          const messageRow = formGrid.addRow({weight: 0.3});
          messageRow.addCol({weight: 0.3}).addText({
            text: 'Message',
            anchorX: 'left',
            anchorY: 'top',
            fontSize: 0.05,
          });
          messageRow
            .addCol({weight: 0.7})
            .addPanel({backgroundColor: '#3a3f4b', height: 0.2});

          formGrid.addRow({weight: 0.18}).addTextButton({
            text: 'Submit',
            backgroundColor: '#61dafb',
            fontColor: '#282c34',
            height: 0.08,
            width: 0.3,
          });
        }

        createChartPanel() {
          // Panel 6: Dynamic Chart with Canvas (Bottom-Center)
          const chartPanel = new xb.SpatialPanel({
            width: 0.8,
            height: 0.6,
            backgroundColor: '#21252b88',
          });
          chartPanel.position.set(
            -1.5,
            xb.user.height,
            -xb.user.panelDistance + 2.0
          );
          chartPanel.rotation.set(0, Math.PI / 2.0, 0);

          this.add(chartPanel);
          const chartGrid = chartPanel.addGrid();
          chartGrid.addRow({weight: 0.15}).addText({
            text: 'Performance Metrics',
            fontSize: 0.07,
            fontColor: '#61dafb',
          });

          // --- Canvas Chart ---
          const canvas = document.getElementById('barChartCanvas');
          const ctx = canvas.getContext('2d');
          const barData = [0.4, 0.7, 0.5, 0.8, 0.6];
          const colors = [
            '#92c5fd',
            '#6ee7b7',
            '#fca5a5',
            '#fde047',
            '#c4b5fd',
          ];
          const padding = 40;
          const barWidth =
            (canvas.width - padding * (barData.length + 1)) / barData.length;
          const maxBarHeight = canvas.height - padding * 2;

          ctx.fillStyle = '#282c34'; // background
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          barData.forEach((value, index) => {
            const barHeight = value * maxBarHeight;
            const x = padding + index * (barWidth + padding);
            const y = canvas.height - padding - barHeight;
            ctx.fillStyle = colors[index];
            ctx.fillRect(x, y, barWidth, barHeight);
          });

          const canvasTexture = new THREE.CanvasTexture(canvas);
          canvasTexture.needsUpdate = true;
          const chartCol = chartGrid.addCol();
          chartCol.addRow({weight: 0.15});
          const chartArea = chartCol.addRow({weight: 0.85});
          const chartMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(1, 1),
            new THREE.MeshBasicMaterial({map: canvasTexture})
          );
          chartArea.add(chartMesh);

          const tmpRow = chartGrid.addCol();
          tmpRow.addRow({weight: 0.3});
          const okButton = tmpRow.addRow().addTextButton({
            text: 'OK',
            backgroundColor: '#22aa33',
            opacity: 0.5,
            fontColor: '#66ccff',
            fontSizeDp: 50,
          });
        }

        init() {
          this.add(new THREE.HemisphereLight(0xffffff, 0x666666, 3));

          this.createProfilePanel();
          this.createProfilePanelFromJSON();
          this.createPlayerPanel();
          this.createGalleryPanel();
          this.createChartPanel();
          this.createSettingsPanel();
        }
      }

      document.addEventListener('DOMContentLoaded', function () {
        const options = new xb.Options();
        options.enableUI();
        options.setAppTitle('Spatial UI');
        xb.add(new MainScript());
        xb.init(options);
      });
    </script>
  </body>
</html>



Sample: virtual-screens
(example: ../xrblocks/samples/virtual-screens/index.html)
<!doctype html>
<html lang="en">
  <head>
    <title>Virtual Screen Viewer | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="js/main_receive.js"></script>
  </body>
</html>

(example: ../xrblocks/samples/virtual-screens/js/StreamManager.js)
/**
 * Manages the lifecycle of screen sharing for multiple windows by
 * encoding/decoding video streams using the WebCodecs API and communicating
 * with the server.
 */
export class StreamManager {
  /**
   * @param {WebSocketManager} webSocketManager An instance for communication.
   */
  constructor(webSocketManager) {
    this.webSocketManager = webSocketManager;
    // This map holds the state for each stream, whether sending or receiving.
    this.streams = new Map();
    this.onStreamAvailable = null;
    this.onStreamEnded = null;
    this.pollInterval = null;

    // Bind `this` to ensure the methods have the correct context when called.
    this.webSocketManager.setRequestHandler(
      this.handleServerRequest.bind(this)
    );
    this.webSocketManager.setBinaryHandler(this.onStreamData.bind(this));
  }

  /**
   * Handles a JSON-RPC request from the server.
   * @param {object} request The parsed request object from the server.
   * @private
   */
  async handleServerRequest(request) {
    const {target, func, args} = request.params;
    if (target !== 'streamManager') return;

    if (func === 'onStreamEnded') {
      this._handleStreamEnded(args[0]);
      return;
    }

    if (typeof this[func] === 'function') {
      this[func].apply(this, args);
    }
  }

  /**
   * Sends a JSON-RPC request to the server's StreamManager.
   * @param {string} func The name of the method to call.
   * @param {Array<any>=} args The arguments for the method.
   * @returns {Promise<any>} A promise that resolves with the server's response.
   */
  request(func, args = []) {
    return this.webSocketManager.request('streamManager', func, args);
  }

  // ===================================================================
  // Sender-Side Logic
  // ===================================================================

  /**
   * Starts sharing a screen capture MediaStream.
   * @param {string} streamId A unique identifier for this stream.
   * @param {MediaStream} stream The media stream to be shared.
   * @param {string} displaySurface The type of surface ('window', 'monitor').
   */
  async shareStream(streamId, stream, displaySurface) {
    const videoTrack = stream.getVideoTracks()[0];
    // eslint-disable-next-line no-undef
    const trackProcessor = new MediaStreamTrackProcessor({track: videoTrack});
    const reader = trackProcessor.readable.getReader();

    const streamState = {
      encoder: null,
      reader,
      isStreaming: true,
      isKeyFrameRequested: true,
      cropRect: null,
      displaySurface: displaySurface,
    };
    this.streams.set(streamId, streamState);

    videoTrack.onended = () => this.stopStream(streamId);
    this.processFrames(streamId, videoTrack);
  }

  /**
   * Stops a specific stream from being shared.
   * @param {string} streamId The ID of the stream to stop.
   */
  async stopStream(streamId) {
    const streamState = this.streams.get(streamId);
    if (!streamState) return;

    streamState.isStreaming = false;
    if (streamState.reader) streamState.reader.cancel();

    if (streamState.encoder && streamState.encoder.state !== 'closed') {
      await streamState.encoder.flush();
      streamState.encoder.close();
    }
    this.streams.delete(streamId);
    await this.request('stop_stream', [streamId]);
  }

  /**
   * Continuously reads frames from a MediaStreamTrack and encodes them.
   * @param {string} streamId The ID of the stream to process frames for.
   * @param {MediaStreamVideoTrack} videoTrack The video track being streamed.
   * @private
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async processFrames(streamId, videoTrack) {
    const streamState = this.streams.get(streamId);
    if (!streamState) return;

    const {reader} = streamState;
    let {encoder} = streamState;

    while (streamState.isStreaming) {
      try {
        const {value: frame, done} = await reader.read();
        if (done) break;

        // On the first frame, configure the encoder with the right dimensions.
        if (!encoder) {
          // const trackSettings = videoTrack.getSettings();
          let rect = {
            x: 0,
            y: 0,
            width: frame.codedWidth,
            height: frame.codedHeight,
          };

          // For window captures, the browser may provide a full-screen frame
          // with the window content inside; `visibleRect` gives the true size.
          if (streamState.displaySurface === 'window' && frame.visibleRect) {
            rect = frame.visibleRect;
          }

          // Ensure dimensions are even numbers, as required by many codecs.
          const codedWidth = rect.width - (rect.width % 2);
          const codedHeight = rect.height - (rect.height % 2);

          if (codedWidth === 0 || codedHeight === 0) {
            frame.close();
            this.stopStream(streamId);
            return;
          }

          // This cropRect is used on all subsequent frames for this stream.
          streamState.cropRect = {
            x: rect.x,
            y: rect.y,
            width: codedWidth,
            height: codedHeight,
          };

          // eslint-disable-next-line no-undef
          encoder = new VideoEncoder({
            output: (chunk) => this._outputHandler(chunk, streamId),
            error: (e) =>
              console.error(`VideoEncoder error for stream ${streamId}:`, e),
          });

          await encoder.configure({
            codec: 'vp8',
            width: codedWidth,
            height: codedHeight,
            bitrate: 2_000_000,
            latencyMode: 'realtime',
          });

          // Now that the true dimensions are known, notify the server.
          await this.request('start_stream', [
            streamId,
            {width: codedWidth, height: codedHeight},
          ]);
          streamState.encoder = encoder;
        }

        // Clone the frame using the calculated cropRect to ensure only the
        // relevant part of the frame is encoded.
        const frameToEncode = frame.clone({rect: streamState.cropRect});

        if (encoder.encodeQueueSize < 30) {
          const needsKeyFrame = streamState.isKeyFrameRequested;
          if (needsKeyFrame) streamState.isKeyFrameRequested = false;
          encoder.encode(frameToEncode, {keyFrame: needsKeyFrame});
        }

        frame.close();
        frameToEncode.close();
      } catch {
        break; // Loop will terminate if reader is cancelled.
      }
    }
  }

  /**
   * Handles the output of the video encoder, wrapping chunks with stream
   * metadata before sending them over the WebSocket.
   * @param {EncodedVideoChunk} chunk The encoded video data.
   * @param {string} streamId The ID of the stream this chunk belongs to.
   * @private
   */
  _outputHandler(chunk, streamId) {
    const streamIdBytes = new TextEncoder().encode(streamId);
    // [1 byte for streamId length] + [streamId] + [1 byte for frame type].
    const headerSize = 1 + streamIdBytes.length + 1;
    const buffer = new ArrayBuffer(chunk.byteLength + headerSize);
    const view = new DataView(buffer);
    let offset = 0;

    view.setUint8(offset, streamIdBytes.length);
    offset += 1;
    new Uint8Array(buffer, offset, streamIdBytes.length).set(streamIdBytes);
    offset += streamIdBytes.length;

    // 0 for key frame, 1 for delta frame.
    view.setUint8(offset, chunk.type === 'key' ? 0 : 1);
    offset += 1;

    chunk.copyTo(new Uint8Array(buffer, offset));
    this.webSocketManager.sendBinary(buffer);
  }

  /**
   * Called via RPC from the server to request a key frame.
   * @param {string} streamId The ID of the stream to trigger.
   * @private
   */
  triggerKeyFrame(streamId) {
    const streamState = this.streams.get(streamId);
    if (!streamState) return;
    streamState.isKeyFrameRequested = true;
  }

  // ===================================================================
  // Receiver-Side Logic
  // ===================================================================

  /**
   * Sets up the client to receive incoming window share streams.
   * @param {function(string, MediaStream, object): void} onStreamAvailable
   * Callback for new streams.
   * @param {function(string): void} onStreamEnded Callback for ended streams.
   */
  startReceiving(onStreamAvailable, onStreamEnded) {
    this.onStreamAvailable = onStreamAvailable;
    this.onStreamEnded = onStreamEnded;

    this.pollInterval = setInterval(async () => {
      const activeStreams = await this.request('get_active_streams');
      const activeStreamIds = new Set(Object.keys(activeStreams));

      for (const streamId of activeStreamIds) {
        if (!this.streams.has(streamId)) {
          this._handleNewStream(streamId, activeStreams[streamId]);
        }
      }

      for (const streamId of this.streams.keys()) {
        if (!activeStreamIds.has(streamId)) {
          this._handleStreamEnded(streamId);
        }
      }
    }, 1000);
  }

  /**
   * Cleans up all receiver-side resources for a stream.
   * @param {string} streamId The ID of the stream.
   * @private
   */
  _handleStreamEnded(streamId) {
    const streamState = this.streams.get(streamId);
    if (!streamState) return;

    if (streamState.decoder && streamState.decoder.state !== 'closed') {
      streamState.decoder.close();
    }
    this.streams.delete(streamId);
    if (this.onStreamEnded) this.onStreamEnded(streamId);
  }

  /**
   * Initializes local state for a new stream and tells the server to start
   * sending data.
   * @param {string} streamId The ID of the stream.
   * @param {object} streamInfo Metadata about the stream.
   * @private
   */
  async _handleNewStream(streamId, streamInfo) {
    this.streams.set(streamId, {
      decoder: null,
      streamInfo: streamInfo,
      isWaitingForKeyFrame: true,
    });
    await this.request('subscribe_to_stream', [streamId]);
  }

  /**
   * Handles incoming multiplexed binary video data from the WebSocket.
   * @param {ArrayBuffer} data The raw binary data.
   * @private
   */
  onStreamData(data) {
    try {
      const view = new DataView(data);
      const streamIdLength = view.getUint8(0);
      let offset = 1;
      const streamId = new TextDecoder().decode(
        new Uint8Array(data, offset, streamIdLength)
      );
      offset += streamIdLength;
      const frameType = view.getUint8(offset);
      offset += 1;

      const streamState = this.streams.get(streamId);
      if (!streamState) return;

      // eslint-disable-next-line no-undef
      const chunk = new EncodedVideoChunk({
        type: frameType === 0 ? 'key' : 'delta',
        timestamp: performance.now(),
        data: data.slice(offset),
      });

      if (streamState.isWaitingForKeyFrame) {
        if (chunk.type === 'key') {
          streamState.isWaitingForKeyFrame = false;
          this.initializeDecoder(streamId);
        } else {
          // Discard delta frames until the first key frame is received.
          return;
        }
      }

      if (streamState.decoder?.state === 'configured') {
        streamState.decoder.decode(chunk);
      }
    } catch (e) {
      console.error('Error processing incoming stream data:', e);
    }
  }

  /**
   * Initializes the video decoder and the canvas for rendering.
   * @param {string} streamId The ID of the stream to initialize.
   * @private
   */
  initializeDecoder(streamId) {
    const streamState = this.streams.get(streamId);
    if (!streamState) return;

    const {streamInfo} = streamState;
    const canvas = document.createElement('canvas');
    canvas.width = streamInfo.width;
    canvas.height = streamInfo.height;
    const ctx = canvas.getContext('2d');

    // eslint-disable-next-line no-undef
    streamState.decoder = new VideoDecoder({
      output: (frame) => {
        ctx.drawImage(frame, 0, 0);
        frame.close();
      },
      error: (e) =>
        console.error(`VideoDecoder error for stream ${streamId}:`, e),
    });

    streamState.decoder.configure({
      codec: 'vp8',
      width: streamInfo.width,
      height: streamInfo.height,
    });

    const mediaStream = canvas.captureStream();
    this.onStreamAvailable(streamId, mediaStream, streamInfo);
  }
}

(example: ../xrblocks/samples/virtual-screens/js/WebSocketManager.js)
/**
 * Manages the WebSocket connection, including connection logic, message
 * queueing, and handling both JSON-RPC and binary messages.
 */
export class WebSocketManager {
  /**
   * @param {number} port The port for the WebSocket server.
   */
  constructor(port) {
    this.port = port;
    this.ws = null;
    this.requestHandler = null;
    this.binaryHandler = null;
    this.messageQueue = [];
    this.pendingRequests = new Map();
    this.onConnectionError = null;
    this.hasConnectedSuccessfully = false;
    this.shouldReconnect = true;
    this.connect();
  }

  setRequestHandler(handler) {
    this.requestHandler = handler;
  }

  setBinaryHandler(handler) {
    this.binaryHandler = handler;
  }

  /**
   * Establishes a WebSocket connection and sets up event handlers.
   */
  connect() {
    this.ws = new WebSocket(`ws://localhost:${this.port}`);
    // This is required to receive binary data as an ArrayBuffer.
    this.ws.binaryType = 'arraybuffer';

    this.ws.onopen = () => {
      console.log('WebSocketManager connected.');
      this.hasConnectedSuccessfully = true;
      this._flushMessageQueue();
    };

    this.ws.onmessage = (event) => {
      // Route message based on its type (binary or text).
      if (event.data instanceof ArrayBuffer) {
        if (this.binaryHandler) {
          this.binaryHandler(event.data);
        }
      } else {
        this._handleTextMessage(event.data);
      }
    };

    this.ws.onclose = () => {
      if (!this.hasConnectedSuccessfully && this.onConnectionError) {
        // Only trigger the error if we've never connected successfully.
        this.onConnectionError();
      }
      if (this.shouldReconnect) {
        console.log('WebSocketManager disconnected. Reconnecting...');
        setTimeout(() => this.connect(), 2000);
      }
    };

    this.ws.onerror = (error) => {
      console.error('WebSocketManager error:', error);
      // The onclose event will be fired next, which handles the error logic.
      this.ws.close();
    };
  }

  /**
   * Stops the WebSocket connection and prevents it from reconnecting.
   */
  stopReconnecting() {
    this.shouldReconnect = false;
    if (this.ws) {
      this.ws.close();
    }
  }

  /**
   * Processes an incoming JSON-RPC message.
   * @param {string} message The raw message string from the server.
   * @private
   */
  _handleTextMessage(message) {
    try {
      const data = JSON.parse(message);

      // Check if this message is a response to a client-side request.
      if (this.pendingRequests.has(data.id)) {
        const promise = this.pendingRequests.get(data.id);
        if (data.error) {
          promise.reject(new Error(data.error));
        } else {
          promise.resolve(data.result);
        }
        this.pendingRequests.delete(data.id);
        return;
      }

      // Otherwise, assume it is a request from the server to this client.
      if (data.params && data.params.target && this.requestHandler) {
        this.requestHandler(data);
      }
    } catch (error) {
      console.error('Error handling server message:', error);
    }
  }

  /**
   * Sends a JSON message, queueing it if the connection is not yet open.
   * @param {object} message The message object to send.
   */
  send(message) {
    const serializedMessage = JSON.stringify(message);
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(serializedMessage);
    } else {
      this.messageQueue.push(serializedMessage);
    }
  }

  /**
   * Sends binary data directly over the WebSocket.
   * @param {ArrayBuffer} data The binary data to send.
   */
  sendBinary(data) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(data);
    } else {
      // In a real-time stream, frames are dropped if the connection is down.
      console.warn('WebSocket not open. Dropping binary data packet.');
    }
  }

  /**
   * Sends any queued text messages.
   * @private
   */
  _flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      this.ws.send(this.messageQueue.shift());
    }
  }

  /**
   * Sends a JSON-RPC request to the server.
   * @param {string} target The name of the registered manager on the server.
   * @param {string} func The name of the function to call.
   * @param {Array<any>} args The parameters to pass to the function.
   * @returns {Promise<any>} A promise that resolves with the server's response.
   */
  request(target, func, args = []) {
    return new Promise((resolve, reject) => {
      const id = `${Date.now()}-${Math.random()}`;
      this.pendingRequests.set(id, {resolve, reject});
      this.send({id, params: {target, func, args}});
    });
  }
}

(example: ../xrblocks/samples/virtual-screens/js/WindowStream.js)
import * as xb from 'xrblocks';

/**
 * Handles a remote video stream provided by an external source, rather than
 * capturing from a local device.
 */
export class WindowStream extends xb.VideoStream {
  constructor() {
    // Disabling 'willCaptureFrequently' uses a hardware-accelerated canvas.
    super({willCaptureFrequently: false});
    this.setState_(xb.StreamState.INITIALIZING);
  }

  /**
   * Sets the remote MediaStream as the source for this video stream.
   * @param {MediaStream} stream The remote MediaStream, typically from a
   * canvas rendering decoded video frames.
   */
  setStream(stream) {
    if (!stream) {
      console.error('WindowStream: Provided stream is null or undefined.');
      this.setState_(xb.StreamState.ERROR, {error: 'Invalid stream provided.'});
      return;
    }

    this.stream_ = stream;
    this.video_.srcObject = stream;

    // Must wait for the video metadata to load to get the stream's dimensions.
    this.video_.onloadedmetadata = () => {
      this.handleVideoStreamLoadedMetadata(
        () => {
          // Once metadata is loaded, the stream is ready to be displayed.
          this.setState_(xb.StreamState.STREAMING, {
            aspectRatio: this.aspectRatio,
          });
        },
        (error) => {
          console.error('WindowStream: Failed to load video metadata.', error);
          this.setState_(xb.StreamState.ERROR, {error});
        },
        true
      ); // Allow one retry.
    };

    this.video_
      .play()
      .catch((e) => console.warn('WindowStream: Autoplay was prevented.', e));
  }
}

(example: ../xrblocks/samples/virtual-screens/js/WindowView.js)
import * as THREE from 'three';
import * as xb from 'xrblocks';

/**
 * A video view for displaying window streams with high-quality rendering
 * settings, an option for a curved display, and a shader for sharpness control.
 */
export class WindowView extends xb.VideoView {
  /**
   * @param {object} options - Configuration options.
   * @param {boolean} [options.isCurved=false] - If true, displays the video on
   * a curved surface.
   * @param {number} [options.curvature=0.5] - The amount of curvature, from 0
   * (flat) to 1 (a full semicircle).
   * @param {number} [options.sharpness=0.1] - Controls the texture sharpness.
   * Lower values (e.g., 0.1) produce a sharper image by tricking the
   * renderer into using higher-resolution mipmaps. 1.0 is normal.
   */
  constructor(options = {}) {
    super(options);
    this.isCurved = this.isCurved ?? false;
    this.curvature = this.curvature ?? 0.5;
    this.sharpness = this.sharpness ?? 0.3;

    // Create a custom material with a shader that controls sharpness.
    const customMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
    });

    this._curvedGeoAspectRatio = 0;
    customMaterial.onBeforeCompile = (shader) => {
      shader.uniforms.sharpness = {value: this.sharpness};
      shader.fragmentShader = `
        uniform float sharpness;
        ${shader.fragmentShader}
      `;

      // Replace the standard texture lookup with textureGrad, which provides
      // direct control over the mipmap level selection.
      shader.fragmentShader = shader.fragmentShader.replace(
        'vec4 texelColor = texture2D( map, vMapUv );',
        `
          // Calculate the original screen-space derivatives.
          vec2 ddx = dFdx(vMapUv);
          vec2 ddy = dFdy(vMapUv);

          // Scale the derivatives by the sharpness factor. A smaller
          // factor tricks the GPU into thinking the texture is changing
          // very slowly (i.e., is very close to the camera), prompting
          // it to select a higher-resolution mipmap.
          vec4 texelColor = textureGrad( map, vMapUv, ddx * sharpness, ddy * sharpness );
          `
      );
    };

    // Dispose of the original material created by the parent and replace it
    // with our custom one.
    this.material.dispose();
    this.material = customMaterial;
    this.mesh.material = this.material;
  }

  /**
   * Extends the default layout update to handle the curved geometry correctly.
   * For curved surfaces, it creates a cylinder with the proper aspect ratio and
   * applies a uniform scale, avoiding the texture distortion caused by the
   * parent class's non-uniform scaling.
   * @override
   */
  updateLayout() {
    super.updateLayout();

    if (isNaN(this.rangeY) || this.rangeY <= 0) {
      this.mesh.visible = false;
      console.error(
        '[WindowView] Invalid parent dimensions detected. Hiding view.'
      );
      return;
    }
    this.mesh.visible = true;

    // If the view isn't meant to be curved, or has no actual curvature, then
    // the parent's default scaling logic is sufficient.
    if (!this.isCurved || this.curvature <= 0) {
      return;
    }

    if (this.videoAspectRatio <= 0) {
      return;
    }

    // Recreate the curved geometry only when the aspect ratio changes.
    if (this._curvedGeoAspectRatio !== this.videoAspectRatio) {
      this._curvedGeoAspectRatio = this.videoAspectRatio;
      const aspectRatio = this.videoAspectRatio;

      // Curvature is a value from 0 (flat) to 1 (a semicircle).
      const thetaLength = this.curvature * Math.PI;

      // To preserve the video's aspect ratio, the arc length of the
      // geometry's surface must be proportional to its height.
      // Arc Length = radius * thetaLength.
      const radius = aspectRatio / thetaLength;

      const cylinderGeometry = new THREE.CylinderGeometry(
        radius,
        radius,
        1,
        64,
        1,
        true,
        -thetaLength / 2,
        thetaLength
      );

      // Translate the geometry's vertices instead of the mesh's position.
      cylinderGeometry.translate(0, 0, -radius);

      this.mesh.geometry.dispose();
      this.mesh.geometry = cylinderGeometry;

      // Configure the mesh for displaying the inside of the cylinder.
      this.mesh.position.z = 0;
      this.mesh.rotation.y = Math.PI;
      this.material.side = THREE.BackSide;
      this.mesh.frustumCulled = false;
    }

    // The SpatialPanel's `updateLayout` sets a non-uniform scale, which we
    // override. The geometry has height=1, so the scale is the final height.
    const scale = this.rangeY;
    this.mesh.scale.set(scale, scale, scale);
  }

  /**
   * Overrides the default load method to attach the custom quality-setting
   * logic after the stream has been initialized by the parent class.
   * @param {xb.VideoStream} source The video stream source.
   */
  load(source) {
    super.load(source);
    if (source instanceof xb.VideoStream) {
      this.qualitySetupCallback_ = this.qualitySetupCallback_.bind(this);
      this.stream_.addEventListener('statechange', this.qualitySetupCallback_);
    }
  }

  /**
   * Callback that applies high-quality settings to the video texture once the
   * stream is active.
   * @private
   */
  qualitySetupCallback_() {
    if (this.stream_?.state === xb.StreamState.STREAMING && this.material.map) {
      const texture = this.material.map;
      texture.generateMipmaps = true;
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.colorSpace = THREE.SRGBColorSpace;
      if (this.isCurved) {
        texture.wrapS = THREE.RepeatWrapping;
        texture.repeat.x = -1;
      }
      const maxAnisotropy = xb.core.renderer.capabilities.getMaxAnisotropy();
      texture.anisotropy = maxAnisotropy;
      texture.needsUpdate = true;
      this.material.needsUpdate = true;
      this.stream_.removeEventListener(
        'statechange',
        this.qualitySetupCallback_
      );
    }
  }

  /**
   * Overrides the dispose method to also clean up the event listener.
   */
  dispose() {
    if (this.stream_ && this.qualitySetupCallback_) {
      this.stream_.removeEventListener(
        'statechange',
        this.qualitySetupCallback_
      );
    }
    super.dispose();
  }
}

(example: ../xrblocks/samples/virtual-screens/js/main_receive.js)
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as THREE from 'three';
import * as xb from 'xrblocks';

import {StreamManager} from './StreamManager.js';
import {WebSocketManager} from './WebSocketManager.js';
import {WindowStream} from './WindowStream.js';
import {WindowView} from './WindowView.js';

/**
 * Manages the XR Blocks scene, creating video panels for incoming streams.
 */
export class WindowReceiver extends xb.Script {
  constructor() {
    super();
    this.sharedWindows = new Map();
    this.panels = [];
    this.screenDistance = -0.4;
    this.screenHeight = 0.4; // Fixed height (width defined relative to this)
    this.screenCurvature = 0.2;
    this.curveScreens = true;
    this.layerOffset = new THREE.Vector3(0.1, 0.1, 0.1);
    this.frameBufferScaleFactor = 1.0; // Increase to improve rendering quality at the cost of
    // performance (default 1.0 for normal rendering)

    // Variables for tracking simulator behavior
    this.simulatorRunning = false;
    this.localPreviewStarted = false;
  }

  init() {
    const isLocalhost =
      window.location.hostname === 'localhost' ||
      window.location.hostname === '127.0.0.1';

    if (isLocalhost) {
      this.webSocketManager = new WebSocketManager(8765);
      this.streamManager = new StreamManager(this.webSocketManager);

      // Set up callbacks to handle new and ended streams.
      this.streamManager.startReceiving(
        (streamId, mediaStream, streamInfo) =>
          this.onNewStream(streamId, mediaStream, streamInfo),
        (streamId) => this.onStreamEnded(streamId)
      );
    } else {
      console.log('Not running on localhost, WebSocket connection disabled.');
      // Create a dummy manager to prevent errors.
      this.webSocketManager = {
        hasConnectedSuccessfully: false,
        stopReconnecting: () => {},
      };
    }

    xb.core.renderer.setPixelRatio(window.devicePixelRatio);
    xb.core.renderer.xr.setFramebufferScaleFactor(this.frameBufferScaleFactor);
  }

  /**
   * Called by the StreamManager when a new stream is available.
   * @param {string} streamId The unique ID for the stream.
   * @param {MediaStream} mediaStream The remote MediaStream.
   * @param {object} streamInfo Metadata about the stream, like width and
   * height.
   */
  onNewStream(streamId, mediaStream, streamInfo) {
    if (this.sharedWindows.has(streamId)) {
      console.warn(`Stream with ID ${streamId} already exists. Ignoring.`);
      return;
    }

    // Use streamInfo for dimensions, not the mediaStream's track, which can
    // have timing issues.
    const {width, height} = streamInfo;
    if (!width || !height) {
      console.error(`Stream ${streamId} has invalid video dimensions.`);
      return;
    }

    console.log(
      `New stream received: ${streamId} with resolution ${width}x${height}.`
    );

    // Calculate panel width based on fixed height to maintain aspect ratio.
    const aspectRatio = width / height;
    const panelWidth = this.screenHeight * aspectRatio;

    const windowStream = new WindowStream();
    windowStream.setStream(mediaStream);

    let position;
    let rotation = null;

    if (this.panels.length > 0) {
      // If panels already exist, layer the new one relative to the last one.
      const lastPanel = this.panels[this.panels.length - 1];
      const rotatedOffset = this.layerOffset
        .clone()
        .applyQuaternion(lastPanel.quaternion);
      position = lastPanel.position.clone().add(rotatedOffset);
      rotation = lastPanel.quaternion.clone();
    } else {
      // Otherwise, use the default position for the first panel.
      position = new THREE.Vector3(0, xb.core.user.height, this.screenDistance);
    }

    const panel = new xb.SpatialPanel({
      width: panelWidth,
      height: this.screenHeight,
      isDraggable: true,
      isClosable: true,
      showEdge: true,
      backgroundColor: '#ffffff00',
      onClose: () => this.onStreamEnded(streamId),
    });
    panel.position.set(position.x, position.y, position.z);

    if (rotation) {
      panel.quaternion.copy(rotation);
    }

    const videoView = new WindowView({
      isCurved: this.curveScreens,
      curvature: this.screenCurvature,
    });
    panel.add(videoView);
    videoView.load(windowStream);

    this.add(panel);
    this.sharedWindows.set(streamId, {panel, stream: windowStream});
    this.panels.push(panel);
    panel.fadeOut(0);
    panel.show();
    panel.fadeIn();
  }

  /**
   * Manages the creation of local preview streams for usage in the simulator.
   * @private
   */
  async _manageLocalStreamCreation() {
    let addAnother = window.confirm(
      'This sample requires a server to run on localhost, which cannot be found. Would you like to share a local screen for simulation?'
    );

    while (addAnother) {
      const success = await this._addLocalStream();
      if (success) {
        addAnother = window.confirm('Would you like to share another screen?');
      } else {
        addAnother = false;
      }
    }
  }

  /**
   * Prompts the user for a screen to share locally and adds it to the scene.
   * @private
   * @return {Promise<boolean>} True if a stream was successfully added.
   */
  async _addLocalStream() {
    try {
      const mediaStream = await navigator.mediaDevices.getDisplayMedia({
        audio: false,
        video: {width: {max: 2560}, height: {max: 1440}},
      });

      const videoTrack = mediaStream.getVideoTracks()[0];
      if (!videoTrack) {
        console.error('No video track found in the selected stream.');
        return false;
      }

      const {width, height} = videoTrack.getSettings();
      const streamInfo = {width, height};
      const streamId = `local-preview-${crypto.randomUUID()}`;
      this.onNewStream(streamId, mediaStream, streamInfo);
      videoTrack.onended = () => {
        this.onStreamEnded(streamId);
      };
      return true;
    } catch (err) {
      console.log('Could not start local screen preview:', err.name);
      return false;
    }
  }

  /**
   * Cleans up the resources for a stream that has ended.
   * @param {string} streamId The unique ID for the stream to remove.
   */
  onStreamEnded(streamId) {
    if (!this.sharedWindows.has(streamId)) {
      return;
    }
    console.log(`Cleaning up stream: ${streamId}`);
    const {panel, stream} = this.sharedWindows.get(streamId);
    this.sharedWindows.delete(streamId);
    this.panels = this.panels.filter((p) => p !== panel);

    panel.fadeOut(1, () => {
      this.remove(panel);
      panel.dispose();
      stream.dispose();
      console.log(`Cleanup complete for stream: ${streamId}`);
    });
  }

  onSimulatorStarted() {
    this.simulatorRunning = true;
    if (!this.webSocketManager.hasConnectedSuccessfully) {
      this.webSocketManager.stopReconnecting();
      if (!this.localPreviewStarted) {
        this.localPreviewStarted = true;
        this._manageLocalStreamCreation();
      }
    }
  }
}

/**
 * Initializes the XR Blocks application.
 */
document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.enableUI();

  xb.add(new WindowReceiver());
  xb.init(options);
});

(example: ../xrblocks/samples/virtual-screens/js/main_send.js)
import {StreamManager} from './StreamManager.js';
import {WebSocketManager} from './WebSocketManager.js';

const webSocketManager = new WebSocketManager(8765);
const streamManager = new StreamManager(webSocketManager);
const sharedWindowsContainer = document.getElementById(
  'sharedWindowsContainer'
);
const selectScreenButton = document.getElementById('selectScreenButton');

/**
 * Adds a preview tile for a newly shared stream to the UI.
 * @param {string} streamId The ID of the stream.
 * @param {MediaStream} stream The stream to preview.
 */
function addStreamPreview(streamId, stream) {
  const videoTrack = stream.getVideoTracks()[0];
  if (!videoTrack) return;

  const wrapper = document.createElement('div');
  wrapper.className =
    'relative bg-gray-700 rounded-lg overflow-hidden shadow-lg aspect-video';
  wrapper.dataset.streamId = streamId;

  const video = document.createElement('video');
  video.srcObject = stream;
  video.className = 'w-full h-full object-contain';
  video.autoplay = true;
  video.muted = true;

  const closeButton = document.createElement('button');
  closeButton.innerHTML = '&times;';
  closeButton.className =
    'absolute top-2 right-2 bg-blue-600 text-white rounded-full w-7 h-7 flex items-center justify-center text-xl font-bold leading-none opacity-80 hover:opacity-100 transition-opacity duration-300';
  closeButton.onclick = () => {
    videoTrack.stop();
    streamManager.stopStream(streamId);
    wrapper.remove();
  };

  wrapper.appendChild(video);
  wrapper.appendChild(closeButton);
  sharedWindowsContainer.appendChild(wrapper);
}

selectScreenButton.addEventListener('click', async () => {
  try {
    const stream = await navigator.mediaDevices.getDisplayMedia({
      audio: false,
      video: {width: {max: 2560}, height: {max: 1440}},
    });

    const streamId = crypto.randomUUID();
    const videoTrack = stream.getVideoTracks()[0];
    const displaySurface = videoTrack.getSettings().displaySurface || 'unknown';

    await streamManager.shareStream(streamId, stream, displaySurface);
    addStreamPreview(streamId, stream);

    // When the user clicks the browser's "Stop sharing" button.
    videoTrack.onended = () => {
      streamManager.stopStream(streamId);
      const previewToRemove = sharedWindowsContainer.querySelector(
        `[data-stream-id="${streamId}"]`
      );
      if (previewToRemove) {
        previewToRemove.remove();
      }
    };
  } catch (err) {
    console.error('Error starting screen share:', err);
  }
});

// Clean up all streams when the page is closed or reloaded.
window.addEventListener('beforeunload', () => {
  for (const streamId of streamManager.streams.keys()) {
    streamManager.stopStream(streamId);
  }
});

(example: ../xrblocks/samples/virtual-screens/send.html)
<!doctype html>
<html lang="en" class="h-full bg-gray-50 text-gray-800">
  <head>
    <title>Screen Viewer</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
      {
        "imports": {
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.8.2/build/addons/"
        }
      }
    </script>
  </head>

  <body class="h-full font-sans p-4">
    <div
      class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-2xl text-center border border-gray-100 flex flex-col mx-auto"
    >
      <h1 class="text-3xl font-bold text-gray-800 mb-2">Share a Window</h1>
      <p class="text-gray-400 mb-6">
        Select a window or screen to begin sharing to your AndroidXR device.
      </p>
      <div
        id="sharedWindowsContainer"
        class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6 items-start w-full"
      ></div>
      <div class="mt-auto">
        <button
          id="selectScreenButton"
          class="inline-block bg-gradient-to-r from-[#346bf1] to-[#4fa0ff] text-white font-semibold px-8 py-3 rounded-full transition-all duration-300 shadow-md hover:shadow-lg transform hover:-translate-y-0.5 hover:brightness-105"
        >
          Select Window or Screen to Share
        </button>
      </div>
    </div>
    <script type="module" src="js/main_send.js"></script>
  </body>
</html>

