"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9967],{597:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"manual/Depth","title":"Depth","description":"Getting started","source":"@site/docs/manual/Depth.md","sourceDirName":"manual","slug":"/manual/Depth","permalink":"/docs/manual/Depth","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Inputs","permalink":"/docs/manual/Inputs"},"next":{"title":"Physics","permalink":"/docs/manual/Physics"}}');var d=n(4848),o=n(8453);const i={sidebar_position:5},r=void 0,h={},c=[{value:"Getting started",id:"getting-started",level:2},{value:"Depth",id:"depth",level:2},{value:"Depth Mesh",id:"depth-mesh",level:2},{value:"Depth Texture",id:"depth-texture",level:2},{value:"Transparency-based Occlusion",id:"transparency-based-occlusion",level:2},{value:"Model Viewer",id:"model-viewer",level:3},{value:"Other objects",id:"other-objects",level:3}];function a(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,d.jsxs)(t.p,{children:["To use depth, initiailize ",(0,d.jsx)(t.code,{children:"core"})," with ",(0,d.jsx)(t.code,{children:"options.depth"})," set to a new ",(0,d.jsx)(t.code,{children:"xb.DepthOptions"})," based on ",(0,d.jsx)(t.code,{children:"xrDepthMeshOptions"})," or ",(0,d.jsx)(t.code,{children:"xrDepthMeshPhysicsOptions"}),":"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-js",children:"const options = new xb.Options();\noptions.depth = new xb.DepthOptions(xrDepthMeshOptions);\nxb.init(options);\n"})}),"\n",(0,d.jsxs)(t.p,{children:["Each object by access request to enable depth by calling ",(0,d.jsx)(t.code,{children:"core.depth.resumeDepth(this)"})," and request to stop depth with ",(0,d.jsx)(t.code,{children:"core.depth.pauseDepth(this)"}),".\nWhen supported by the browser, ",(0,d.jsx)(t.code,{children:"Depth"})," will automatically pause depth sensing when no objects are using depth."]}),"\n",(0,d.jsx)(t.h2,{id:"depth",children:"Depth"}),"\n",(0,d.jsxs)(t.p,{children:["When depth is enabled, a ",(0,d.jsx)(t.code,{children:"Depth"})," controller will be added to ",(0,d.jsx)(t.code,{children:"core.depth"})," and will call ",(0,d.jsx)(t.code,{children:"getDepthInformation"})," and cache the depth array every frame.\nIf the depth mesh or depth texture are enabled, these will also be updated every frame."]}),"\n",(0,d.jsxs)(t.p,{children:["The depth can be accessed using the following properties and methods in ",(0,d.jsx)(t.code,{children:"Depth"})," object available from ",(0,d.jsx)(t.code,{children:"core.depth"}),":"]}),"\n",(0,d.jsxs)(t.ol,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"depthData"})," - An array containing the left and right depth data objects. Each object has ",(0,d.jsx)(t.code,{children:"data"}),", ",(0,d.jsx)(t.code,{children:"width"}),", ",(0,d.jsx)(t.code,{children:"height"}),", and ",(0,d.jsx)(t.code,{children:"rawValueToMeters"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"depthArray"})," - An array containing the left and right depth arrays."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"rawValueToMeters"})," - the factor to convert the depth into meters."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"getDepth(u, v)"})," - Gets the depth value of the left camera from normalized u, v coordinates."]}),"\n"]}),"\n",(0,d.jsx)(t.h2,{id:"depth-mesh",children:"Depth Mesh"}),"\n",(0,d.jsxs)(t.p,{children:["A depth mesh is a 3D mesh created by projecting depth values from the depth texture.\nTo enable the depth mesh, initiailize ",(0,d.jsx)(t.code,{children:"core"})," with ",(0,d.jsx)(t.code,{children:"options.depth"})," set to ",(0,d.jsx)(t.code,{children:"xrDepthMeshOptions"})," or ",(0,d.jsx)(t.code,{children:"xrDepthMeshPhysicsOptions"}),".\nThe depth mesh will use the left camera depth and attach itself as a child of the left camera."]}),"\n",(0,d.jsxs)(t.p,{children:["By default, the depth will use a downsampled 40x40 mesh for raycasts and collisions.\nTo disable this behavior and use a 160x160 full resolution mesh for raycasts and collisions, set ",(0,d.jsx)(t.code,{children:"useDownsampledGeometry"})," to ",(0,d.jsx)(t.code,{children:"false"})," in the depth options.\nTo continuously update the full resolution mesh, set ",(0,d.jsx)(t.code,{children:"updateFullResolutionGeometry"})," to ",(0,d.jsx)(t.code,{children:"true"})," in the depth options."]}),"\n",(0,d.jsxs)(t.p,{children:["When physics is enabled, the depth mesh will create a mesh collider in the RAPIER world and update it at a fixed rate.\nTo configure the collider update rate, set ",(0,d.jsx)(t.code,{children:"options.depth.depthMesh.colliderUpdateFps"}),"."]}),"\n",(0,d.jsx)(t.h2,{id:"depth-texture",children:"Depth Texture"}),"\n",(0,d.jsxs)(t.p,{children:["A depth texture is a depth array stored on GPU which can be used for shaders such as occlusion or depth visualizations.\nTo enable the depth mesh, initiailize ",(0,d.jsx)(t.code,{children:"core"})," with ",(0,d.jsx)(t.code,{children:"options.depth.depthTexture.enabled = true"}),";"]}),"\n",(0,d.jsx)(t.h2,{id:"transparency-based-occlusion",children:"Transparency-based Occlusion"}),"\n",(0,d.jsx)(t.p,{children:"Our SDK supports per-object transparency-based occlusion."}),"\n",(0,d.jsx)(t.p,{children:"Transparency-baesd occlusion works by computing an occlusion map blurring the difference between the depth of virtual contents and the environment depth.\nThis occlusion map is interpreted by each virtual object to set their transparency value within the fragment shader."}),"\n",(0,d.jsx)(t.h3,{id:"model-viewer",children:"Model Viewer"}),"\n",(0,d.jsxs)(t.p,{children:["Our ",(0,d.jsx)(t.code,{children:"ModelViewer"})," class supports loading GLTF objects and enabling transparency on them. To do this, add ",(0,d.jsx)(t.code,{children:"addOcclusionToShader: true"})," when calling ",(0,d.jsx)(t.code,{children:"loadGLTFModel"}),"."]}),"\n",(0,d.jsx)(t.h3,{id:"other-objects",children:"Other objects"}),"\n",(0,d.jsxs)(t.p,{children:["To enable occlusion on other objects, their fragment shader needs to interpret the occlusion map.\nFor built-in THREE.js materials, XR Blocks provides a helper function to inject the logic using ",(0,d.jsx)(t.code,{children:"onBeforeCompile"}),":"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-js",children:"material.onBeforeCompile = (shader) => {\n  OcclusionUtils.addOcclusionToShader(shader);\n  shader.uniforms.occlusionEnabled.value = true;\n  material.userData.shader = shader;\n  xb.core.depth.occludableShaders.add(shader);\n};\n"})}),"\n",(0,d.jsxs)(t.p,{children:["Occlusion can be enabled and disabled at runtime by setting the value for the ",(0,d.jsx)(t.code,{children:"occlusionEnabled"})," uniform of the shader."]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var s=n(6540);const d={},o=s.createContext(d);function i(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);