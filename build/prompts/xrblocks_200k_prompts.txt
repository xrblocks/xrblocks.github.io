
# Role
Act as an expert Creative Technologist specialized in three.js, WebXR, and the **XR Blocks (xrblocks)** library.

# Context
You are authoring single-file WebXR experiences. You must strictly adhere to the XR Blocks framework architecture.

# User Request
Create the following experience: <my_xr_experience>

# Engineering Guidelines (Strict)

1. **Architecture (Single File):**
   - Output a SINGLE `index.html` file.
   - Logic must be inside a class extending `xb.Script` within `<script type="module">`.
   - CSS must use: `https://xrblocks.github.io/css/xr.css`.

2. **Dependency Management (Critical):**
   - Use the specific versions below. Do NOT hallucinate newer versions.
   - Only include imports required for the specific request (e.g., do not import TensorFlow unless using gestures).
   - **Reference Map:**
     - "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js"
     - "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
     - "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js"
     - "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
     - "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
     - "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
     - "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",    
     - "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
     - "lit/": "https://esm.run/lit@3/",
     - "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js"
     - "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"

3. **Coding Standards:**
   - **Class Structure:** logic must be inside `class MyScript extends xb.Script`.
   - **Lifecycle:** Use `init()` for setup and `update()` for the loop. Do NOT use `requestAnimationFrame` manually; `xb.Script` handles this.
   - **Interactions:** Use `onSelectStart`, `onSelectEnd`, `onSelecting` methods within the class.
   - **Coordinates:** `y` is up. `z` is forward/backward. Initialize objects at `z = -this.user.objectDistance`.

4. **Specific XR Features:**
   - **Text:** Use `troika-three-text` (Pattern: `1_ui`).
   - **Models:** Wrap 3D models in `xb.ModelViewer`.
   - **AI:** If using Gemini/AI, use const API_KEY = "", and link the API key to the `ai` module so Gemini Canvas auto-populates it.

5. **Planning:**
   - Before generating code, briefly outline the `xb.Script` class structure, member variables needed, and the `init()` vs `update()` logic flow.

# Reference Examples
Here are some XRBlocks **templates, samples, demos, and gallery examples**...


### Template: 0_basic
File: `templates/0_basic/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Basic: Pinch to Set Color | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import * as THREE from 'three';
import * as xb from 'xrblocks';

/**
 * A basic example of XRBlocks to render a cylinder and pinch to change color.
 */
class MainScript extends xb.Script {
  init() {
    this.add(new THREE.HemisphereLight(0xffffff, 0x666666, /*intensity=*/ 3));

    const geometry = new THREE.CylinderGeometry(
      0.2,
      0.2,
      0.4,
      /*segments=*/ 32
    );
    const material = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
    });
    this.player = new THREE.Mesh(geometry, material);
    this.player.position.set(0, xb.user.height - 0.5, -xb.user.objectDistance);
    this.add(this.player);
  }

  /**
   * Changes the color of the mesh on a pinch in XR.
   * @param {SelectEvent} event event.target holds controler / hand data.
   */
  onSelectEnd(event) {
    this.player.material.color.set(Math.random() * 0xffffff);
  }

  /**
   * Changes the color of the mesh to blue during pinching in XR.
   * @param {SelectEvent} event The controller / hand event.
   */
  onSelecting(event) {
    this.player.material.color.set(0x66ccff);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  xb.add(new MainScript());
  xb.init(new xb.Options());
});

</script>
  </body>
</html>

```


### Template: 1_ui
File: `templates/1_ui/UIManager.js`
```javascript
import * as xb from 'xrblocks';

/**
 * Rending a draggable spatial UI panel with SDF font libraries, and icons
 * buttons using XR Blocks.
 */
export class UIManager extends xb.Script {
  constructor() {
    super();

    // Adds an interactive SpatialPanel as a container for UI elements.
    const panel = new xb.SpatialPanel({backgroundColor: '#2b2b2baa'});
    this.add(panel);

    const grid = panel.addGrid();
    // `weight` defines the perentage of a view's dimension to its parent.
    // Here, question occupies 70% of the height of the panel.
    const question = grid.addRow({weight: 0.7}).addText({
      text: 'Welcome to UI Playground! Is it your first time here?',
      fontColor: '#ffffff',
      fontSize: 0.08,
    });
    this.question = question;

    // ctrlRow occupies 30% of the height of the panel.
    const ctrlRow = grid.addRow({weight: 0.3});

    // The `text` field defines the icon of the button from Material Icons in
    // https://fonts.google.com/icons
    const yesButton = ctrlRow
      .addCol({weight: 0.5})
      .addIconButton({text: 'check_circle', fontSize: 0.5});

    // onTriggered defines unified behavior for `onSelected`, `onClicked`,
    // `onPinched`, `onTouched` for buttons.
    yesButton.onTriggered = () => {
      this._onYes();
    };

    const noButton = ctrlRow
      .addCol({weight: 0.5})
      .addIconButton({text: 'cancel', fontSize: 0.5});

    noButton.onTriggered = () => {
      this._onNo();
    };
  }

  _onYes() {
    console.log('yes');
  }

  _onNo() {
    console.log('no');
  }
}

```
File: `templates/1_ui/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>UI: Spatial Panels | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js?version=2"></script>
  </body>
</html>

```
File: `templates/1_ui/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {UIManager} from './UIManager.js';

const options = new xb.Options();
options.enableUI();

document.addEventListener('DOMContentLoaded', function () {
  xb.add(new UIManager());
  xb.init(options);
});

```


### Template: 2_hands
File: `templates/2_hands/HandsInteraction.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';

export class HandsInteraction extends xb.Script {
  init() {
    // Touch state.
    this.leftHandTouching = false;
    this.rightHandTouching = false;

    // Grab state.
    this.isGrabbing = false;
    this._handToObject = null;

    // Add a cylinder to touch and grab.
    this.originalColor = new THREE.Color(0xfbbc05);
    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 32).translate(
      0,
      1.45,
      -0.4
    );
    const material = new THREE.MeshPhongMaterial({color: this.originalColor});
    this.target = new THREE.Mesh(geometry, material);
    this.add(this.target);

    // Add a light.
    this.add(new THREE.HemisphereLight(0xbbbbbb, 0x888888, 3));
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(1, 1, 1).normalize();
    this.add(light);
  }

  _updateColor() {
    if (this.leftHandTouching && this.rightHandTouching) {
      this.target.material.color.setHex(0xdb4437); // Red
    } else if (this.leftHandTouching) {
      this.target.material.color.setHex(0x34a853); // Green
    } else if (this.rightHandTouching) {
      this.target.material.color.setHex(0x4285f4); // Blue
    } else {
      this.target.material.color.copy(this.originalColor); // Yellow
    }
  }

  onObjectTouchStart(event) {
    const handName = event.handIndex === xb.Handedness.LEFT ? 'left' : 'right';
    console.log(`Touch started with ${handName} hand!`);

    if (event.handIndex === xb.Handedness.LEFT) {
      this.leftHandTouching = true;
    } else if (event.handIndex === xb.Handedness.RIGHT) {
      this.rightHandTouching = true;
    }
    this._updateColor();
  }

  onObjectTouchEnd(event) {
    const handName = event.handIndex === xb.Handedness.LEFT ? 'left' : 'right';
    console.log(`Touch ended with ${handName} hand!`);

    if (event.handIndex === xb.Handedness.LEFT) {
      this.leftHandTouching = false;
    } else if (event.handIndex === xb.Handedness.RIGHT) {
      this.rightHandTouching = false;
    }
    this._updateColor();
  }

  onObjectGrabStart(event) {
    if (this.isGrabbing) return;
    this.isGrabbing = true;

    const handName = event.handIndex === xb.Handedness.LEFT ? 'left' : 'right';
    console.log(`Grab started with ${handName} hand!`);

    // Make sure matrices are fresh.
    this.target.updateMatrixWorld(true);
    event.hand.updateMatrixWorld(true);

    // Save the initial hand to object delta transform.
    const H0 = new THREE.Matrix4().copy(event.hand.matrixWorld);
    const O0 = new THREE.Matrix4().copy(this.target.matrixWorld);
    this._handToObject = new THREE.Matrix4().copy(H0).invert().multiply(O0);
  }

  onObjectGrabbing(event) {
    if (!this.isGrabbing || !this._handToObject) return;

    event.hand.updateMatrixWorld(true);
    const H = new THREE.Matrix4().copy(event.hand.matrixWorld);
    const O = new THREE.Matrix4().multiplyMatrices(H, this._handToObject);
    const parent = this.target.parent;
    if (parent) parent.updateMatrixWorld(true);
    const parentInv = parent
      ? new THREE.Matrix4().copy(parent.matrixWorld).invert()
      : new THREE.Matrix4().identity();

    const Olocal = new THREE.Matrix4().multiplyMatrices(parentInv, O);
    const pos = new THREE.Vector3();
    const quat = new THREE.Quaternion();
    const scl = new THREE.Vector3();
    Olocal.decompose(pos, quat, scl);

    this.target.position.copy(pos);
    this.target.quaternion.copy(quat);

    this.target.updateMatrix();
  }

  onObjectGrabEnd(event) {
    if (!this.isGrabbing) return;
    const handName = event.handIndex === xb.Handedness.LEFT ? 'left' : 'right';
    console.log(`Grab ended with ${handName} hand!`);

    this.isGrabbing = false;
    this._handToObject = null;
  }
}

```
File: `templates/2_hands/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Hands: Mesh and Touch | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js?version=2"></script>
  </body>
</html>

```
File: `templates/2_hands/main.js`
```javascript
// Provides optional 2D UIs for simulator on desktop.
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {HandsInteraction} from './HandsInteraction.js';

const options = new xb.Options();
options.enableReticles();
options.enableHands();

options.hands.enabled = true;
options.hands.visualization = true;
// Visualize hand joints.
options.hands.visualizeJoints = true;
// Visualize hand meshes.
options.hands.visualizeMeshes = true;

options.simulator.defaultMode = xb.SimulatorMode.POSE;

function start() {
  xb.add(new HandsInteraction());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Template: 3_depth
File: `templates/3_depth/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Depth | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as THREE from 'three';
import * as xb from 'xrblocks';

const pawnModelPath =
  'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/models/arcore_pawn_compressed.glb';

class PawnPlacer extends xb.Script {
  async init() {
    this.addLights();
    await this.loadPawnModel();
  }

  async loadPawnModel() {
    const pawnGltf = await new xb.ModelLoader().load({
      url: pawnModelPath,
      renderer: xb.core.renderer,
    });
    pawnGltf.scene.scale.setScalar(0.5);
    this.pawnModel = pawnGltf.scene;
  }

  addLights() {
    const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
    directionalLight.position.set(0, 1, 0);
    this.add(directionalLight);
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    this.add(ambientLight);
  }

  onSelectStart(event) {
    const intersection = xb.user.select(xb.core.depth.depthMesh, event.target);
    if (intersection) {
      this.add(
        xb.placeObjectAtIntersectionFacingTarget(
          this.pawnModel.clone(),
          intersection,
          xb.core.camera
        )
      );
    }
  }
}

document.addEventListener('DOMContentLoaded', async function () {
  const options = new xb.Options();
  options.reticles.enabled = true;
  options.depth = new xb.DepthOptions(xb.xrDepthMeshOptions);
  await xb.init(options);
  xb.showReticleOnDepthMesh(true);
  xb.add(new PawnPlacer());
});

</script>
  </body>
</html>

```


### Template: 4_stereo
File: `templates/4_stereo/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Stereo | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as THREE from 'three';
import * as xb from 'xrblocks';

const stereoTextureFile = 'SV_20241216_144600.webp';

class StereoImage extends xb.Script {
  async init() {
    await this.addStereoQuad();
  }

  async addStereoQuad() {
    const stereoObject = new THREE.Group();
    const [leftTexture, rightTexture] =
      await xb.loadStereoImageAsTextures(stereoTextureFile);
    const geometry = new THREE.PlaneGeometry(1, 1);
    const leftMesh = new THREE.Mesh(
      geometry,
      new THREE.MeshBasicMaterial({
        map: leftTexture,
        side: THREE.DoubleSide,
      })
    );

    xb.showOnlyInLeftEye(leftMesh);
    stereoObject.add(leftMesh);
    const rightMesh = new THREE.Mesh(
      geometry,
      new THREE.MeshBasicMaterial({
        map: rightTexture,
        side: THREE.DoubleSide,
      })
    );

    xb.showOnlyInRightEye(rightMesh);
    stereoObject.add(rightMesh);
    stereoObject.position.set(0.0, 1.5, -1.5);
    this.add(stereoObject);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.simulator.stereo.enabled = true;
  xb.add(new StereoImage());
  xb.init(options);
});

</script>
  </body>
</html>

```


### Template: 5_camera
File: `templates/5_camera/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Camera | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

/**
 * A class that provides UI to display and cycle through device cameras.
 */
export class CameraViewManager extends xb.Script {
  /** @private {XRDeviceCamera|null} */
  cameraStream_ = null;

  constructor() {
    super();
    this.panel = new xb.SpatialPanel({
      backgroundColor: '#2b2b2baa',
      useDefaultPosition: true,
    });
    const grid = this.panel.addGrid();
    this.videoView = grid.addRow({weight: 0.7}).addVideo();
    const txtRow = grid.addRow({weight: 0.15});
    this.cameraLabel = txtRow
      .addCol({weight: 1})
      .addText({text: 'Camera', fontColor: '#ffffff', fontSize: 0.05});
    const ctrlRow = grid.addRow({weight: 0.2});
    this.prevCameraButton = ctrlRow.addCol({weight: 0.5}).addIconButton({
      text: 'skip_previous',
      fontSize: 0.5,
    });
    this.nextCameraButton = ctrlRow.addCol({weight: 0.5}).addIconButton({
      text: 'skip_next',
      fontSize: 0.5,
    });

    this.prevCameraButton.onTriggered = () => this.cycleCamera_(-1);
    this.nextCameraButton.onTriggered = () => this.cycleCamera_(1);

    this.add(this.panel);
  }

  async init() {
    this.cameraStream_ = xb.core.deviceCamera;

    // Listen for camera state changes to update UI
    this.cameraStream_.addEventListener('statechange', (event) => {
      this.cameraLabel.setText(event.device?.label || event.state || 'Camera');
      if (event.state === 'streaming') {
        this.videoView.load(this.cameraStream_);
      }
    });
    this.cameraLabel.setText(
      this.cameraStream_.getCurrentDevice()?.label || 'Camera'
    );
    this.videoView.load(this.cameraStream_);
  }

  /**
   * Cycle to the next or previous device.
   * @param {number} offset - The direction to cycle (-1 for prev, 1 for next).
   */
  async cycleCamera_(offset) {
    const devices = this.cameraStream_.getAvailableDevices();
    if (devices.length <= 1) return;
    const newIndex =
      (this.cameraStream_.getCurrentDeviceIndex() + offset + devices.length) %
      devices.length;
    await this.cameraStream_.setDeviceId(devices[newIndex].deviceId);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.enableUI();
  options.enableCamera();
  xb.add(new CameraViewManager());
  xb.init(options);
});

</script>
  </body>
</html>

```


### Template: 6_ai
File: `templates/6_ai/GeminiQueryManager.js`
```javascript
import * as xb from 'xrblocks';

export class GeminiQueryManager extends xb.Script {
  constructor() {
    super();
    this.panel = null;
    this.isProcessing = false;
    this.responseDisplay = null;
  }

  init() {
    this.ai = xb.core.ai;

    this.createPanel();
  }

  createPanel() {
    this.panel = new xb.SpatialPanel({
      width: 2.5,
      height: 1.5,
      backgroundColor: '#1a1a1abb',
    });
    this.panel.position.set(0, 1.6, -2);
    this.add(this.panel);

    const grid = this.panel.addGrid();

    // Response area
    const responseRow = grid.addRow({weight: 0.8});
    this.responseDisplay = new xb.ScrollingTroikaTextView({
      text: '',
      fontSize: 0.04,
    });
    responseRow.add(this.responseDisplay);

    const buttonRow = grid.addRow({weight: 0.2});
    const textCol = buttonRow.addCol({weight: 0.5});
    const textButton = textCol.addTextButton({
      text: 'Ask about WebXR',
      fontColor: '#ffffff',
      backgroundColor: '#4285f4',
      fontSize: 0.24,
    });

    const imageCol = buttonRow.addCol({weight: 0.5});
    const imageButton = imageCol.addTextButton({
      text: 'Send Sample Image',
      fontColor: '#ffffff',
      backgroundColor: '#34a853',
      fontSize: 0.24,
    });

    textButton.onTriggered = () => this.askText();
    imageButton.onTriggered = () => this.askImage();
  }

  async ask(parts, displayText) {
    if (this.isProcessing || !this.ai?.isAvailable()) return;

    this.isProcessing = true;
    this.responseDisplay.addText(displayText);

    try {
      const response = await this.ai.query({
        type: 'multiPart',
        parts: parts,
      });
      this.responseDisplay.addText(`ü§ñ AI: ${response.text}\n\n`);
    } catch (error) {
      this.responseDisplay.addText(`‚ùå Error: ${error.message}\n\n`);
    }

    this.isProcessing = false;
  }

  askText() {
    const question = 'Hello! What is WebXR?';
    const parts = [{text: question + ' reply succinctly.'}];
    const displayText = `üí¨ You: ${question}\n\n`;
    this.ask(parts, displayText);
  }

  askImage() {
    const question = 'What do you see in this image?';
    const image = {
      inlineData: {
        data: 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==',
        mimeType: 'image/png',
      },
    };
    const parts = [image, {text: question}];
    const displayText = `üí¨ You: ${question}\nüì∏ [Sample image sent]\n\n`;
    this.ask(parts, displayText);
  }
}

```
File: `templates/6_ai/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    
    
    <title>XR Blocks - AI Query Demo</title>
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `templates/6_ai/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {GeminiQueryManager} from './GeminiQueryManager.js';

const options = new xb.Options();
options.enableUI();
options.enableAI();

function start() {
  try {
    xb.init(options);
    xb.add(new GeminiQueryManager());
  } catch (error) {
    console.error('Failed to initialize XR app:', error);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Template: 7_ai_live
File: `templates/7_ai_live/GeminiManager.js`
```javascript
import * as xb from 'xrblocks';
import {GeminiManager as CoreGeminiManager} from 'xrblocks/addons/ai/GeminiManager.js';

import {TranscriptionManager} from './TranscriptionManager.js';

export class GeminiManager extends CoreGeminiManager {
  constructor() {
    super();
    this.defaultText = 'Say "Start" to begin...';
  }

  init() {
    super.init();
    this.createTextDisplay();

    // Hook into events from the base class
    this.addEventListener('inputTranscription', (event) => {
      this.transcription?.handleInputTranscription(event.message);
    });
    this.addEventListener('outputTranscription', (event) => {
      this.transcription?.handleOutputTranscription(event.message);
    });
    this.addEventListener('turnComplete', () => {
      this.transcription?.finalizeTurn();
    });
    this.addEventListener('interrupted', () => {
      // Optional: handle interruption visual cues if needed
    });
  }

  async toggleGeminiLive() {
    return this.isAIRunning ? this.stopGeminiLive() : this.startGeminiLive();
  }

  async startGeminiLive() {
    try {
      await super.startGeminiLive();
      this.updateButtonState();
    } catch (error) {
      console.error('Failed to start AI session:', error);
      this.transcription?.addText(
        'Error: Failed to start AI session - ' + error.message
      );
      this.cleanup(); // Clean up on failure
      this.updateButtonState();
    }
  }

  async stopGeminiLive() {
    await super.stopGeminiLive();
    this.updateButtonState();
    this.transcription?.clear();
    this.transcription?.setText(this.defaultText);
  }

  createTextDisplay() {
    this.textPanel = new xb.SpatialPanel({
      width: 3,
      height: 1.5,
      backgroundColor: '#1a1a1abb',
    });
    const grid = this.textPanel.addGrid();

    const responseDisplay = new xb.ScrollingTroikaTextView({
      text: this.defaultText,
      fontSize: 0.03,
      textAlign: 'left',
    });
    grid.addRow({weight: 0.7}).add(responseDisplay);
    this.transcription = new TranscriptionManager(responseDisplay);

    this.toggleButton = grid.addRow({weight: 0.3}).addTextButton({
      text: '‚ñ∂ Start',
      fontColor: '#ffffff',
      backgroundColor: '#006644',
      fontSize: 0.2,
    });
    this.toggleButton.onTriggered = () => this.toggleGeminiLive();

    this.textPanel.position.set(0, 1.2, -2);
    this.add(this.textPanel);
  }

  updateButtonState() {
    this.toggleButton?.setText(this.isAIRunning ? '‚èπ Stop' : '‚ñ∂ Start');
  }
}

```
File: `templates/7_ai_live/TranscriptionManager.js`
```javascript
export class TranscriptionManager {
  constructor(responseDisplay) {
    this.responseDisplay = responseDisplay;
    this.currentInputText = '';
    this.currentOutputText = '';
    this.conversationHistory = [];
  }

  handleInputTranscription(text) {
    if (!text) return;
    this.currentInputText += text;
    this.updateLiveDisplay();
  }

  handleOutputTranscription(text) {
    if (!text) return;
    this.currentOutputText += text;
    this.updateLiveDisplay();
  }

  finalizeTurn() {
    if (this.currentInputText.trim()) {
      this.conversationHistory.push({
        speaker: 'You',
        text: this.currentInputText.trim(),
      });
    }
    if (this.currentOutputText.trim()) {
      this.conversationHistory.push({
        speaker: 'AI',
        text: this.currentOutputText.trim(),
      });
    }
    this.currentInputText = '';
    this.currentOutputText = '';
    this.updateFinalDisplay();
  }

  updateLiveDisplay() {
    let displayText = '';
    for (const entry of this.conversationHistory.slice(-2)) {
      displayText += `${entry.speaker}: ${entry.text}\n\n`;
    }
    if (this.currentInputText.trim()) {
      displayText += `You: ${this.currentInputText}`;
    }
    if (this.currentOutputText.trim()) {
      if (this.currentInputText.trim()) displayText += '\n\n';
      displayText += `AI: ${this.currentOutputText}`;
    }
    this.responseDisplay?.setText(displayText);
  }

  updateFinalDisplay() {
    let displayText = '';
    for (const entry of this.conversationHistory) {
      displayText += `${entry.speaker}: ${entry.text}\n\n`;
    }
    this.responseDisplay?.setText(displayText);
  }

  clear() {
    this.currentInputText = '';
    this.currentOutputText = '';
    this.conversationHistory = [];
  }

  addText(text) {
    this.responseDisplay?.addText(text + '\n\n');
  }

  setText(text) {
    this.responseDisplay?.setText(text);
  }
}

```
File: `templates/7_ai_live/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    
    
    <title>XR Blocks - Gemini Live AI Demo</title>
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `templates/7_ai_live/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {GeminiManager} from './GeminiManager.js';

const options = new xb.Options();
options.enableUI();
options.enableHands();
options.enableAI();
options.enableCamera();
options.deviceCamera = new xb.DeviceCameraOptions({
  enabled: true,
  videoConstraints: {
    width: {ideal: 1280},
    height: {ideal: 720},
    facingMode: 'environment',
  },
});

async function requestAudioPermission() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: 16000,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true,
      },
    });
    stream.getTracks().forEach((track) => track.stop());
    return stream;
  } catch (error) {
    console.error('Audio permission denied or not available:', error);
    alert(
      'Audio permission is required for Gemini Live AI features. Please enable microphone access and refresh the page.'
    );
    return null;
  }
}

async function start() {
  try {
    await requestAudioPermission();
    xb.init(options);
    xb.add(new GeminiManager());
  } catch (error) {
    console.error('Failed to initialize XR app:', error);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Template: 8_objects
File: `templates/8_objects/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>World Component: Object Detection | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import * as THREE from 'three';
import * as xb from 'xrblocks';

/**
 * A basic example of using the XR Blocks SDK's world component to detect
 * objects in the real world using Gemini.
 */
class MainScript extends xb.Script {
  init() {
    this.add(new THREE.HemisphereLight(0xffffff, 0x666666, /*intensity=*/ 3));
  }

  /**
   * Runs object detection on select (click in simulator, pinch in XR device).
   * The results of the detection are automatically handled by the
   * ObjectDetector, which will create debug visuals for each detected object.
   * This behavior is enabled when `showDebugVisualizations` is set to true.
   * @param {XRInputSourceEvent} event event.target holds controller or hand
   * data.
   */
  async onSelectEnd() {
    console.log('Running object detection...');
    const detectedObjects = await xb.world.objects.runDetection();

    // `detectedObjects` is an array of THREE.Object3D instances, each
    // representing a detected object. These objects contain the 3D world
    // position and other metadata returned by the detection model.
    if (detectedObjects.length > 0) {
      console.log('Detected objects:', detectedObjects);
    } else {
      console.log('No objects detected.');
    }
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();

  // AI is required for the object detection backend. Please set your
  options.enableAI();

  // Enable the environment camera to provide the video feed to the AI module.
  options.enableCamera('environment');

  // Depth is required to project the 2D detections from the AI module into 3D.
  options.enableDepth();

  // Enable the object detection feature and its debug visualizations.
  options.world.enableObjectDetection();
  options.world.objects.showDebugVisualizations = true;

  xb.add(new MainScript());
  xb.init(options);
});

</script>
  </body>
</html>

```


### Template: 9_xr-toggle
File: `templates/9_xr-toggle/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Transition between AR and VR | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import * as THREE from 'three';
import * as xb from 'xrblocks';

/**
 * Demonstrates how to use the XRTransition component to smoothly switch
 * between AR and VR backgrounds.
 */
class MainScript extends xb.Script {
  init() {
    this.add(new THREE.HemisphereLight(0xffffff, 0x666666, /*intensity=*/ 3));

    const geometry = new THREE.CylinderGeometry(
      0.2,
      0.2,
      0.4,
      /*segments=*/ 32
    );
    const material = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
    });
    this.cylinder = new THREE.Mesh(geometry, material);
    this.cylinder.position.set(
      0,
      xb.core.user.height - 0.5,
      -xb.core.user.objectDistance
    );
    this.add(this.cylinder);
  }

  /**
   * On pinch, toggle between AR and VR modes and update cylinder color.
   */
  onSelectEnd() {
    if (!xb.core.transition) {
      console.warn('XRTransition not enabled.');
      return;
    }
    this.cylinder.material.color.set(Math.random() * 0xffffff);

    // Toggle between AR and VR based on the current mode.
    if (xb.core.transition.currentMode === 'AR') {
      xb.core.transition.toVR({color: Math.random() * 0xffffff});
    } else {
      xb.core.transition.toAR();
    }
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options().enableXRTransitions();
  xb.add(new MainScript());
  xb.init(options);
});

</script>
  </body>
</html>

```


### Template: heuristic_hand_gestures
File: `templates/heuristic_hand_gestures/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Gestures: Heuristic Logging | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

const options = new xb.Options();
options.enableReticles();
options.enableGestures();

options.gestures.setGestureEnabled('point', true);
options.gestures.setGestureEnabled('spread', true);

options.hands.enabled = true;
options.hands.visualization = true;
options.hands.visualizeJoints = true;
options.hands.visualizeMeshes = true;

options.simulator.defaultMode = xb.SimulatorMode.POSE;

class GestureLogger extends xb.Script {
  init() {
    const gestures = xb.core.gestureRecognition;
    if (!gestures) {
      console.warn(
        '[GestureLogger] GestureRecognition is unavailable. ' +
          'Make sure options.enableGestures() is called before xb.init().'
      );
      return;
    }
    this._onGestureStart = (event) => {
      const {hand, name, confidence = 0} = event.detail;
      console.log(
        `[gesture] ${hand} hand started ${name} (${confidence.toFixed(2)})`
      );
    };
    this._onGestureEnd = (event) => {
      const {hand, name} = event.detail;
      console.log(`[gesture] ${hand} hand ended ${name}`);
    };
    gestures.addEventListener('gesturestart', this._onGestureStart);
    gestures.addEventListener('gestureend', this._onGestureEnd);
  }

  dispose() {
    const gestures = xb.core.gestureRecognition;
    if (!gestures) return;
    if (this._onGestureStart) {
      gestures.removeEventListener('gesturestart', this._onGestureStart);
    }
    if (this._onGestureEnd) {
      gestures.removeEventListener('gestureend', this._onGestureEnd);
    }
  }
}

function start() {
  xb.add(new GestureLogger());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', () => {
  start();
});

</script>
  </body>
</html>

```


### Template: meshes
File: `templates/meshes/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Meshes | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

document.addEventListener('DOMContentLoaded', async function () {
  const options = new xb.Options();
  options.reticles.enabled = true;
  options.world.enableMeshDetection();
  options.world.meshes.showDebugVisualizations = true;
  await xb.init(options);
});

</script>
  </body>
</html>

```


### Template: planes
File: `templates/planes/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Planes | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

document.addEventListener('DOMContentLoaded', async function () {
  const options = new xb.Options();
  options.reticles.enabled = true;
  options.world.enablePlaneDetection();
  options.world.planes.showDebugVisualizations = true;
  await xb.init(options);
});

</script>
  </body>
</html>

```


### Template: uikit
File: `templates/uikit/MaterialSymbolsIcon.js`
```javascript
import {Svg} from '@pmndrs/uikit';
import {computed} from '@preact/signals-core';

const SVG_BASE_PATH =
  'https://cdn.jsdelivr.net/gh/marella/material-symbols@v0.38.0/svg/{{weight}}/{{style}}/{{icon}}.svg';

export class MaterialSymbolsIcon extends Svg {
  name = 'Material Symbols Icon';
  constructor(properties, initialClasses, config) {
    const icon = properties?.icon ?? config?.defaultOverrides?.icon;
    const iconStyle =
      properties?.iconStyle ?? config?.defaultOverrides?.iconStyle;
    const iconWeight =
      properties?.iconWeight ?? config?.defaultOverrides?.iconWeight;

    const svgPath = computed(() => {
      const finalIcon = icon?.value ?? icon ?? 'question_mark';
      const finalStyle = iconStyle?.value ?? iconStyle ?? 'outlined';
      const finalWeight = iconWeight?.value ?? iconWeight ?? 400;

      return SVG_BASE_PATH.replace('{{style}}', finalStyle)
        .replace('{{icon}}', finalIcon)
        .replace('{{weight}}', String(finalWeight));
    });

    super(properties, initialClasses, {
      ...config,
      defaultOverrides: {
        src: svgPath,
        ...config?.defaultOverrides,
      },
    });
  }
}

```
File: `templates/uikit/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>XR Blocks x @pmndrs/uikit Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/": "https://cdn.jsdelivr.net/npm/three@0.182.0/",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "@pmndrs/uikit": "https://cdn.jsdelivr.net/npm/@pmndrs/uikit@1.0.56/dist/index.min.js",
          "@pmndrs/uikit-pub-sub": "https://cdn.jsdelivr.net/npm/@pmndrs/uikit-pub-sub@1.0.56/dist/index.min.js",
          "@pmndrs/msdfonts": "https://cdn.jsdelivr.net/npm/@pmndrs/msdfonts@1.0.56/dist/index.min.js",
          "@preact/signals-core": "https://cdn.jsdelivr.net/npm/@preact/signals-core@1.12.1/dist/signals-core.mjs",
          "yoga-layout/load": "https://cdn.jsdelivr.net/npm/yoga-layout@3.2.1/dist/src/load.js",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js?version=2"></script>
  </body>
</html>

```
File: `templates/uikit/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';
import * as uikit from '@pmndrs/uikit';
import * as xb from 'xrblocks';

import {MaterialSymbolsIcon} from './MaterialSymbolsIcon.js';

class UikitPanel extends xb.Script {
  dragFacingCamera = true;
  draggable = true;
  draggingMode = xb.DragMode.TRANSLATING;
  container;

  constructor() {
    super();
    const panelSize = 0.5;
    this.container = new uikit.Container({
      sizeX: (panelSize * 16) / 9,
      sizeY: panelSize,
      pixelSize: panelSize / 512,
      flexDirection: 'column',
      textAlign: 'center',
      color: 'white',
      fontSize: 64,
      backgroundColor: 'gray',
      borderRadius: 64,
      padding: 16,
    });
    this.add(this.container);
  }

  update() {
    this.container?.update(xb.getDeltaTime());
  }

  onObjectSelectStart(event) {
    this.dispatchEventRecursively(event.target, 'click', this.container);
  }

  dispatchEventRecursively(controller, eventType, object) {
    const intersections = xb.core.input.intersectObjectByController(
      controller,
      object
    );
    if (intersections.length == 0 || !(object instanceof uikit.Component)) {
      return;
    }
    for (const child of object.children) {
      this.dispatchEventRecursively(controller, eventType, child);
    }
    const intersection = intersections[0];
    object.dispatchEvent({
      type: 'click',
      distance: intersection.distance,
      nativeEvent: {},
      object: intersection.object,
      point: intersection.point,
      pointerId: controller.userData.id,
    });
  }
}

/**
 * UIKit Template
 */
class UikitTemplate extends xb.Script {
  constructor() {
    super();

    const spatialPanel = new UikitPanel();
    spatialPanel.position.set(0, 1.5, -1);
    this.add(spatialPanel);

    const topRow = new uikit.Text({
      text: 'XR Blocks x @pmndrs/uikit',
      flexGrow: 2,
    });
    spatialPanel.container.add(topRow);

    const bottomRow = new uikit.Container({
      flexDirection: 'row',
      flexGrow: 1,
      justifyContent: 'space-evenly',
      gap: 64,
    });
    spatialPanel.container.add(bottomRow);

    const yesButton = new MaterialSymbolsIcon({
      icon: 'check_circle',
    });
    yesButton.addEventListener('click', () => {
      console.log('yes button clicked');
    });
    bottomRow.add(yesButton);

    const noButton = new MaterialSymbolsIcon({
      icon: 'x_circle',
    });
    noButton.addEventListener('click', () => {
      console.log('no button clicked');
    });
    bottomRow.add(noButton);
  }
}

const options = new xb.Options();
options.enableUI();

document.addEventListener('DOMContentLoaded', async function () {
  xb.add(new UikitTemplate());
  options.simulator.instructions.enabled = false;
  await xb.init(options);
  const renderer = xb.core.renderer;
  renderer.localClippingEnabled = true;
  renderer.setTransparentSort(uikit.reversePainterSortStable);
});

```


### Sample: depthmap
File: `samples/depthmap/DepthMapScene.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';

import {DepthVisualizationPass} from './DepthVisualizationPass.js';

export class DepthMapScene extends xb.Script {
  init() {
    if (xb.core.effects) {
      this.depthVisPass = new DepthVisualizationPass(xb.scene, xb.core.camera);
      xb.core.effects.addPass(this.depthVisPass);
    } else {
      console.error(
        'This sample needs post processing for adding the depth visualization pass. Please enable options.usePostprocessing'
      );
    }

    this.depthMeshAlphaSlider = new xb.FreestandingSlider(
      /*start=*/ 1.0,
      /*min=*/ 0.0,
      /*max=*/ 1.0,
      /*scale*/ 5.0
    );
    // Which controller is currently selecting depthMeshAlphaSlider.
    this.currentSliderController = null;

    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
    light.position.set(0.5, 1, 0.25);
    this.add(light);
  }

  onSelectStart(event) {
    const controller = event.target;
    controller.userData.selected = true;
    this.currentSliderController = controller;
    this.depthMeshAlphaSlider.setInitialPose(
      controller.position,
      controller.quaternion
    );
  }

  onSelectEnd(event) {
    const controller = event.target;
    controller.userData.selected = false;
    if (this.currentSliderController == controller) {
      const opacity = this.depthMeshAlphaSlider.getValueFromController(
        this.currentSliderController
      );
      this.depthVisPass.setAlpha(opacity);
      this.depthMeshAlphaSlider.updateValue(opacity);
    }
    this.currentSliderController = null;
  }

  update() {
    if (this.currentSliderController) {
      const opacity = this.depthMeshAlphaSlider.getValueFromController(
        this.currentSliderController
      );
      this.depthVisPass.setAlpha(opacity);
    }
    this.depthVisPass.updateEnvironmentalDepthTexture(xb.core.depth);
  }
}

```
File: `samples/depthmap/DepthVisualizationPass.js`
```javascript
import * as THREE from 'three';
import {FullScreenQuad} from 'three/addons/postprocessing/Pass.js';
import * as xb from 'xrblocks';

import {DepthMapShader} from './depthmap.glsl.js';

/**
 * Depth map visualization postprocess pass.
 */
export class DepthVisualizationPass extends xb.XRPass {
  constructor() {
    super();
    this.depthTextures = [null, null];
    this.uniforms = {
      uDepthTexture: {value: null},
      uDepthTextureArray: {value: null},
      uRawValueToMeters: {value: 8.0 / 65536.0},
      uAlpha: {value: 1.0},
      tDiffuse: {value: null},
      uView: {value: 0},
      uIsTextureArray: {value: 0},
      // Used to interpret Quest 3 depth.
      uDepthNear: {value: 0},
    };
    this.depthMapQuad = new FullScreenQuad(
      new THREE.ShaderMaterial({
        name: 'DepthMapShader',
        uniforms: this.uniforms,
        vertexShader: DepthMapShader.vertexShader,
        fragmentShader: DepthMapShader.fragmentShader,
      })
    );
  }

  setAlpha(value) {
    this.uniforms.uAlpha.value = value;
  }

  updateEnvironmentalDepthTexture(xrDepth) {
    this.depthTextures[0] = xrDepth.getTexture(0);
    this.depthTextures[1] = xrDepth.getTexture(1);
    this.uniforms.uRawValueToMeters.value = xrDepth.rawValueToMeters;
    if (this.depthTextures[0]) {
      this.uniforms.uIsTextureArray.value = this.depthTextures[0]
        .isExternalTexture
        ? 1.0
        : 0;
    }
  }

  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive, viewId) {
    const texture = this.depthTextures[viewId];
    if (!texture) return;
    if (texture.isExternalTexture) {
      this.uniforms.uDepthTextureArray.value = texture;
      const depthNear = xb.core.depth.gpuDepthData[0].depthNear;
      this.uniforms.uDepthNear.value = depthNear;
    } else {
      this.uniforms.uDepthTexture.value = texture;
    }
    this.uniforms.tDiffuse.value = readBuffer.texture;
    this.uniforms.uView.value = viewId;
    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
    this.depthMapQuad.render(renderer);
  }

  dispose() {
    this.depthMapQuad.dispose();
  }
}

```
File: `samples/depthmap/depthmap.glsl.js`
```javascript
export const DepthMapShader = {
  name: 'DepthMapShader',
  defines: {},

  vertexShader: /* glsl */ `
  varying vec2 vTexCoord;

  void main() {
      vTexCoord = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
`,

  fragmentShader: /* glsl */ `
  #include <packing>

  precision mediump float;

  uniform sampler2D uDepthTexture;
  uniform sampler2DArray uDepthTextureArray;
  uniform float uRawValueToMeters;
  uniform float uAlpha;
  uniform float uIsTextureArray;
  uniform int uView;
  uniform float uDepthNear;

  uniform sampler2D tDiffuse;
  uniform float cameraNear;
  uniform float cameraFar;

  varying vec2 vTexCoord;

  float DepthGetMeters(in sampler2D depth_texture, in vec2 depth_uv) {
    // Assume we're using floating point depth.
    return uRawValueToMeters * texture2D(depth_texture, depth_uv).r;
  }

  float DepthArrayGetMeters(in sampler2DArray depth_texture, in vec2 depth_uv) {
    float textureValue = texture(depth_texture, vec3(depth_uv.x, depth_uv.y, uView)).r;
    return uRawValueToMeters * uDepthNear / (1.0 - textureValue);
  }

  vec3 TurboColormap(in float x) {
    const vec4 kRedVec4 = vec4(0.55305649, 3.00913185, -5.46192616, -11.11819092);
    const vec4 kGreenVec4 = vec4(0.16207513, 0.17712472, 15.24091500, -36.50657960);
    const vec4 kBlueVec4 = vec4(-0.05195877, 5.18000081, -30.94853351, 81.96403246);
    const vec2 kRedVec2 = vec2(27.81927491, -14.87899417);
    const vec2 kGreenVec2 = vec2(25.95549545, -5.02738237);
    const vec2 kBlueVec2 = vec2(-86.53476570, 30.23299484);

    // Adjusts color space via 6 degree poly interpolation to avoid pure red.
    x = clamp(x * 0.9 + 0.03, 0.0, 1.0);
    vec4 v4 = vec4( 1.0, x, x * x, x * x * x);
    vec2 v2 = v4.zw * v4.z;
    return vec3(
      dot(v4, kRedVec4)   + dot(v2, kRedVec2),
      dot(v4, kGreenVec4) + dot(v2, kGreenVec2),
      dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)
    );
  }

  void main(void) {
    vec4 texCoord = vec4(vTexCoord, 0, 1);
    vec2 uv = texCoord.xy;

    vec4 diffuse = texture2D( tDiffuse, texCoord.xy );
    highp float real_depth;
    if (uIsTextureArray < 0.5) {
      uv.y = 1.0 - uv.y;
      real_depth = DepthGetMeters(uDepthTexture, uv);
    } else
      real_depth = DepthArrayGetMeters(uDepthTextureArray, uv);
    vec4 depth_visualization = vec4(
      TurboColormap(clamp(real_depth / 8.0, 0.0, 1.0)), 1.0);
    gl_FragColor = mix(diffuse, depth_visualization, uAlpha);
  }
`,
};

```
File: `samples/depthmap/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Depth Map | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `samples/depthmap/main.js`
```javascript
import 'xrblocks/addons/simulator/instructions/SimulatorInstructions.js';

import * as xb from 'xrblocks';

import {DepthMapScene} from './DepthMapScene.js';

const options = new xb.Options();
options.depth.enabled = true;
options.depth.depthTexture.enabled = true;
options.depth.depthTypeRequest = [xb.getUrlParameter('depthType') ?? 'raw'];
options.usePostprocessing = true;
options.setAppTitle('Depth Map');

function start() {
  xb.add(new DepthMapScene());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Sample: depthmesh
File: `samples/depthmesh/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Depth Mesh | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import * as THREE from 'three';
import * as xb from 'xrblocks';

class DepthMeshVisualizer extends xb.Script {
  currentSliderController = null;
  depthMeshAlphaSlider = new xb.FreestandingSlider(
    /*start=*/ 1.0,
    /*min=*/ 0.0,
    /*max=*/ 1.0,
    /*scale*/ 5.0
  );

  constructor() {
    super();
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
    light.position.set(0.5, 1, 0.25);
    this.add(light);
  }

  init() {
    xb.core.depth.depthMesh.material.uniforms.uOpacity.value =
      this.depthMeshAlphaSlider.startingValue;
  }

  onSelectStart(event) {
    this.currentSliderController = event.target;
    this.depthMeshAlphaSlider.setInitialPoseFromController(
      this.currentSliderController
    );
  }

  onSelectEnd(event) {
    const controller = event.target;
    if (this.currentSliderController == controller) {
      const opacity = this.depthMeshAlphaSlider.getValueFromController(
        this.currentSliderController
      );
      xb.core.depth.depthMesh.material.uniforms.uOpacity.value = opacity;
      this.depthMeshAlphaSlider.updateValue(opacity);
    }
    this.currentSliderController = null;
  }

  update() {
    if (this.currentSliderController) {
      const opacity = this.depthMeshAlphaSlider.getValueFromController(
        this.currentSliderController
      );
      xb.core.depth.depthMesh.material.uniforms.uOpacity.value = opacity;
      console.log('opacity:' + opacity);
    }
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.setAppTitle('Depth Mesh');
  options.depth = new xb.DepthOptions(xb.xrDepthMeshVisualizationOptions);
  options.depth.depthTypeRequest = [xb.getUrlParameter('depthType') ?? 'raw'];
  xb.add(new DepthMeshVisualizer());
  xb.init(options);
});

</script>
  </body>
</html>

```


### Sample: gestures_custom
File: `samples/gestures_custom/CustomGestureDemo.js`
```javascript
// Imports LiteRt: https://ai.google.dev/edge/litert/web/get_started
import {loadLiteRt, setWebGpuDevice} from '@litertjs/core';
import {runWithTfjsTensors} from '@litertjs/tfjs-interop';
// TensorFlow.js + WebGPU backend
import * as tf from '@tensorflow/tfjs';
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import {WebGPUBackend} from '@tensorflow/tfjs-backend-webgpu';
import * as THREE from 'three';
import * as xb from 'xrblocks';

const GESTURE_LABELS = [
  'OTHER',
  'FIST',
  'THUMB UP',
  'THUMB DOWN',
  'POINT',
  'VICTORY',
  'ROCK',
  'SHAKA',
  'GESTURE_LABEL_MAX_ENUM',
];

const GESTURE_IMAGES = [
  'images/empty.png',
  'images/fist.png',
  'images/thumb.png',
  'images/thumb_down.png',
  'images/point.png',
  'images/victory.png',
  'images/rock.png',
  'images/shaka.png',
  'images/error.png',
];

const LEFT_HAND_INDEX = 0;
const RIGHT_HAND_INDEX = 1;

const UNKNOWN_GESTURE = 8;

/**
 * A demo scene that uses a custom ML model to detect and display static hand
 * gestures for both hands in real-time.
 */
export class CustomGestureDemo extends xb.Script {
  constructor() {
    super();

    // Initializes UI.
    {
      // Make a root panel>grid>row>controlPanel>grid
      const panel = new xb.SpatialPanel({backgroundColor: '#00000000'});
      this.add(panel);

      const grid = panel.addGrid();

      // Show user data
      const dataRow = grid.addRow({weight: 0.3});
      // Left hand image and text
      const leftCol = dataRow.addCol({weight: 0.5});
      const leftHandRow = leftCol.addRow({weight: 0.5});
      // Indentation
      leftHandRow.addCol({weight: 0.4});
      this.leftHandImage = leftHandRow.addCol({weight: 0.2}).addImage({
        src: GESTURE_IMAGES[0],
        scaleFactor: 0.3,
      });
      this.leftHandLabel = leftCol.addRow({weight: 0.5}).addText({
        text: 'Loading...',
        fontColor: '#ffffff',
      });
      const rightCol = dataRow.addCol({weight: 0.5});
      const rightHandRow = rightCol.addRow({weight: 0.5});
      // Indentation
      rightHandRow.addCol({weight: 0.4});
      // Image
      this.rightHandImage = rightHandRow.addCol({weight: 0.2}).addImage({
        src: GESTURE_IMAGES[0],
        scaleFactor: 0.3,
      });
      this.rightHandLabel = rightCol.addRow({weight: 0.4}).addText({
        text: 'Loading...',
        fontColor: '#ffffff',
      });

      // Indentation
      grid.addRow({weight: 0.1});

      // Control row
      const controlRow = grid.addRow({weight: 0.6});
      const ctrlPanel = controlRow.addPanel({backgroundColor: '#00000055'});
      const ctrlGrid = ctrlPanel.addGrid();
      {
        // Left indentation
        ctrlGrid.addCol({weight: 0.1});

        // Middle column
        const midColumn = ctrlGrid.addCol({weight: 0.8});

        midColumn.addRow({weight: 0.1});
        midColumn.addRow({weight: 0.2}).addText({
          text: 'Perform one of these gestures',
          fontColor: '#ffffff',
        });
        midColumn
          .addRow({weight: 0.2})
          .addText({text: '(either hand):', fontColor: '#ffffff'});
        const gesturesRow = midColumn.addRow({weight: 0.5});
        gesturesRow.addCol({weight: 0.1});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/fist.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/thumb.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/thumb_down.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/point.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/victory.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/rock.png', scaleFactor: 0.3});
        gesturesRow
          .addCol({weight: 0.1})
          .addImage({src: 'images/shaka.png', scaleFactor: 0.3});

        // Vertical alignment on the description text element.
        midColumn.addRow({weight: 0.1});

        // Right indentation.
        ctrlGrid.addCol({weight: 0.1});
      }

      const orbiter = ctrlGrid.addOrbiter();
      orbiter.addExitButton();

      panel.updateLayouts();

      this.panel = panel;
    }

    // Model
    this.modelPath = './custom_gestures_model.tflite';
    this.modelState = 'None';

    this.frameId = 0;

    setTimeout(() => {
      this.setBackendAndLoadModel();
    }, 1);
  }

  init() {
    // Adds light.
    this.add(new THREE.HemisphereLight(0x888877, 0x777788, 3));
    const light = new THREE.DirectionalLight(0xffffff, 1.5);
    light.position.set(0, 4, 0);
    this.add(light);
  }

  async setBackendAndLoadModel() {
    this.modelState = 'Loading';
    try {
      await tf.setBackend('webgpu');
      await tf.ready();

      // Initializes LiteRT.js's WASM files.
      const wasmPath = 'https://unpkg.com/@litertjs/core@0.2.1/wasm/';
      const liteRt = await loadLiteRt(wasmPath);

      // Makes LiteRt use the same GPU device as TF.js (for tensor conversion).
      const backend = tf.backend();
      setWebGpuDevice(backend.device);

      // Loads model via LiteRt.
      await this.loadModel(liteRt);

      if (this.model) {
        // Prints model details to the log.
        console.log('Model Details: ', this.model.getInputDetails());
      }
      this.modelState = 'Ready';
    } catch (error) {
      console.error('Failed to load model or backend:', error);
    }
  }

  async loadModel(liteRt) {
    try {
      this.model = await liteRt.loadAndCompile(this.modelPath, {
        // Currently, only 'webgpu' is supported.
        accelerator: 'webgpu',
      });
    } catch (error) {
      this.model = null;
      console.error('Error loading model:', error);
    }
  }

  calculateRelativeHandBoneAngles(jointPositions) {
    // Reshape jointPositions
    let jointPositionsReshaped = [];

    jointPositionsReshaped = jointPositions.reshape([xb.HAND_JOINT_COUNT, 3]);

    // Calculate bone vectors
    const boneVectors = [];
    xb.HAND_JOINT_IDX_CONNECTION_MAP.forEach(([joint1, joint2]) => {
      const boneVector = jointPositionsReshaped
        .slice([joint2, 0], [1, 3])
        .sub(jointPositionsReshaped.slice([joint1, 0], [1, 3]))
        .squeeze();
      const norm = boneVector.norm();
      const normalizedBoneVector = boneVector.div(norm);
      boneVectors.push(normalizedBoneVector);
    });

    // Calculate relative hand bone angles
    const relativeHandBoneAngles = [];
    xb.HAND_BONE_IDX_CONNECTION_MAP.forEach(([bone1, bone2]) => {
      const angle = boneVectors[bone1].dot(boneVectors[bone2]);
      relativeHandBoneAngles.push(angle);
    });

    // Stack the angles into a tensor.
    return tf.stack(relativeHandBoneAngles);
  }

  async detectGesture(handJoints) {
    if (!this.model || !handJoints || handJoints.length !== 25 * 3) {
      console.log('Invalid hand joints or model load error.');
      return UNKNOWN_GESTURE;
    }

    try {
      const tensor = this.calculateRelativeHandBoneAngles(
        tf.tensor1d(handJoints)
      );

      let tensorReshaped = tensor.reshape([
        1,
        xb.HAND_BONE_IDX_CONNECTION_MAP.length,
        1,
      ]);
      var result = -1;

      result = runWithTfjsTensors(this.model, tensorReshaped);

      let integerLabel = result[0].as1D().arraySync();
      if (integerLabel.length == 7) {
        let x = integerLabel[0];
        let idx = 0;
        for (let t = 0; t < 7; ++t) {
          if (integerLabel[t] > x) {
            idx = t;
            x = integerLabel[t];
          }
        }
        return idx;
      }
    } catch (error) {
      console.error('Error:', error);
    }
    return UNKNOWN_GESTURE;
  }

  async #detectHandGestures(joints) {
    if (Object.keys(joints).length !== 25) {
      return UNKNOWN_GESTURE;
    }

    let handJointPositions = [];
    for (const i in joints) {
      handJointPositions.push(joints[i].position.x);
      handJointPositions.push(joints[i].position.y);
      handJointPositions.push(joints[i].position.z);
    }

    if (handJointPositions.length !== 25 * 3) {
      return UNKNOWN_GESTURE;
    }

    let result = await this.detectGesture(handJointPositions);
    return result;
  }

  #shiftIndexIfNeeded(joints, result) {
    // no need to shift before thumb which is 2
    result += result > 2 ? 1 : 0;
    // check thumb direction
    if (result === 2) {
      // console.log(joints["thumb-phalanx-distal"], joints["thumb-tip"]);
      let tmp = this.isThumbUpOrDown(
        joints['thumb-phalanx-distal'].position,
        joints['thumb-tip'].position
      );
      // 1 -up; -1 down; 0 - other
      result = tmp === 0 ? 0 : tmp < 0 ? result + 1 : result;
    }
    return result;
  }

  async update() {
    if (this.frameId % 5 === 0) {
      const hands = xb.user.hands;
      if (hands != null && hands.hands && hands.hands.length == 2) {
        // Left hand.
        const leftJoints = hands.hands[LEFT_HAND_INDEX].joints;
        let leftHandResult = await this.#detectHandGestures(leftJoints);
        leftHandResult = this.#shiftIndexIfNeeded(leftJoints, leftHandResult);

        // Update image and label.
        this.leftHandImage.load(GESTURE_IMAGES[leftHandResult]);
        this.leftHandLabel.setText(GESTURE_LABELS[leftHandResult]);

        // Right hand.
        const rightJoints = hands.hands[RIGHT_HAND_INDEX].joints;
        let rightHandResult = await this.#detectHandGestures(rightJoints);
        rightHandResult = this.#shiftIndexIfNeeded(
          rightJoints,
          rightHandResult
        );

        // Update image and label.
        this.rightHandImage.load(GESTURE_IMAGES[rightHandResult]);
        this.rightHandLabel.setText(GESTURE_LABELS[rightHandResult]);
      }
    }
    this.frameId++;
  }

  isThumbUpOrDown(p1, p2) {
    // Assuming p1 is the base of the thumb and p2 is the tip.

    // Vector from base to tip.
    const vector = {
      x: p2.x - p1.x,
      y: p2.y - p1.y,
      z: p2.z - p1.z,
    };

    // Calculate the magnitude of the vector.
    const magnitude = Math.sqrt(
      vector.x * vector.x + vector.y * vector.y + vector.z * vector.z
    );

    // If the magnitude is very small, it's likely not a significant gesture
    if (magnitude < 0.001) {
      return 0; // Otherwise
    }

    // Normalize the vector to get its direction.
    const normalizedVector = {
      x: vector.x / magnitude,
      y: vector.y / magnitude,
      z: vector.z / magnitude,
    };

    // Define the "up" and "down" direction vectors (positive and negative
    // Y-axis)
    const upVector = {x: 0, y: 1, z: 0};
    const downVector = {x: 0, y: -1, z: 0};

    // Angle threshold (cosine) for "up" (within 45 degrees of vertical)
    const cosUpThreshold = Math.cos((45 * Math.PI) / 180); // Approximately 0.707

    // Angle threshold (cosine) for "down" (within 45 degrees of negative
    // vertical) We need the dot product with the *down* vector to be >= cos(45
    // degrees)
    const dotDownThreshold = cosUpThreshold;

    // Calculates the dot product with the "up" vector.
    const dotUp =
      normalizedVector.x * upVector.x +
      normalizedVector.y * upVector.y +
      normalizedVector.z * upVector.z;

    // Calculates the dot product with the "down" vector (negate the y component
    // of normalized vector).
    const dotDown =
      normalizedVector.x * downVector.x +
      normalizedVector.y * downVector.y +
      normalizedVector.z * downVector.z;

    if (dotUp >= cosUpThreshold) {
      return 1; // Thumb up
    } else if (dotDown >= dotDownThreshold) {
      return -1; // Thumb down
    } else {
      return 0; // Otherwise
    }
  }
}

```
File: `samples/gestures_custom/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Custom Hand Gestures | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "@tensorflow/tfjs-core": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core/+esm",
          "@tensorflow/tfjs": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/+esm",
          "@tensorflow/tfjs-backend-webgpu": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu/+esm",
          "@litertjs/core": "https://unpkg.com/@litertjs/core@0.2.1",
          "@litertjs/tfjs-interop": "https://unpkg.com/@litertjs/tfjs-interop@1.0.1",
          "@litertjs/wasm-utils": "https://unpkg.com/@litertjs/wasm-utils@0.2.1",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `samples/gestures_custom/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {CustomGestureDemo} from './CustomGestureDemo.js';

const options = new xb.Options({
  antialias: true,
  reticles: {enabled: true},
  visualizeRays: false,
  hands: {enabled: true, visualization: false},
  simulator: {defaultMode: xb.SimulatorMode.POSE},
});

async function start() {
  options.setAppTitle('Custom Gestures');
  xb.add(new CustomGestureDemo());
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  setTimeout(function () {
    start();
  }, 200);
});

```


### Sample: lighting
File: `samples/lighting/LightingScene.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';
import {ModelManager} from 'xrblocks/addons/ui/ModelManager.js';

import {ANIMALS_DATA} from './animals_data.js';

export class LightingScene extends xb.Script {
  constructor() {
    super();
    this.pointer = new THREE.Vector3();
    this.raycaster = new THREE.Raycaster();
    this.modelManager = new ModelManager(
      ANIMALS_DATA,
      /*enableOcclusion=*/ true
    );
    this.modelManager.layers.enable(xb.OCCLUDABLE_ITEMS_LAYER);
    this.add(this.modelManager);
  }
  init() {
    xb.core.input.addReticles();
    xb.showReticleOnDepthMesh(true);
  }
  updatePointerPosition(event) {
    // (-1 to +1) for both components
    this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // scale pointer.x from [-1, 0] to [-1, 1]
    this.pointer.x = 1 + 2 * this.pointer.x;
  }
  onSelectStart(event) {
    const controller = event.target;
    if (xb.core.input.intersectionsForController.get(controller).length > 0) {
      const intersection =
        xb.core.input.intersectionsForController.get(controller)[0];
      if (intersection.handleSelectRaycast) {
        intersection.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object.handleSelectRaycast) {
        intersection.object.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object == xb.core.depth.depthMesh) {
        this.onDepthMeshSelectStart(intersection);
        return;
      }
    }
  }
  onDepthMeshSelectStart(intersection) {
    console.log('Depth mesh select intersection:', intersection.point);
    this.modelManager.positionModelAtIntersection(intersection, xb.core.camera);
  }
  onPointerDown(event) {
    this.updatePointerPosition(event);
    const cameras = xb.core.renderer.xr.getCamera().cameras;
    if (cameras.length == 0) return;
    const camera = cameras[0];
    this.raycaster.setFromCamera(this.pointer, camera);
    const intersections = this.raycaster.intersectObjects(
      xb.core.input.reticleTargets
    );
    for (let intersection of intersections) {
      if (intersection.handleSelectRaycast) {
        intersection.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object.handleSelectRaycast) {
        intersection.object.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object == xb.core.depth.depthMesh) {
        this.modelManager.positionModelAtIntersection(intersection, camera);
        return;
      }
    }
  }
}

```
File: `samples/lighting/animals_data.js`
```javascript
export const ANIMALS_DATA = [
  {
    path: 'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/',
    model: 'models/Cat/cat.gltf',
    thumbnail: 'thumbnail.png',
  },
];

```
File: `samples/lighting/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Lighting Estimation | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "@material/web/": "https://esm.run/@material/web/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `samples/lighting/main.js`
```javascript
import * as xb from 'xrblocks';

import {LightingScene} from './LightingScene.js';

// Set up depth mesh optinos. Need depth mesh to render shadows to.
let options = new xb.Options();
options.depth = new xb.DepthOptions(xb.xrDepthMeshOptions);
options.depth.enabled = true;
options.depth.depthMesh.enabled = true;
options.depth.depthTexture.enabled = true;
options.depth.depthMesh.updateFullResolutionGeometry = true;
options.depth.depthMesh.renderShadow = true;
options.depth.depthMesh.shadowOpacity = 0.6;
options.depth.occlusion.enabled = true;

// Set up lighting options.
options.lighting = new xb.LightingOptions(xb.xrLightingOptions);
options.lighting.enabled = true;
options.lighting.useAmbientSH = true;
options.lighting.useDirectionalLight = true;
options.lighting.castDirectionalLightShadow = true;
options.lighting.useDynamicSoftShadow = false;

options.xrButton = {
  ...options.xrButton,
  startText: '<i id="xrlogo"></i> BRING IT TO LIFE',
  endText: '<i id="xrlogo"></i> MISSION COMPLETE',
};
async function start() {
  const lightingScene = new LightingScene();
  options.setAppTitle('Lighting Estimation');
  await xb.init(options);
  xb.add(lightingScene);
  window.addEventListener(
    'pointerdown',
    lightingScene.onPointerDown.bind(lightingScene)
  );
}
document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Sample: mesh_detection
File: `samples/mesh_detection/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Mesh Detection | XR Blocks Template</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

document.addEventListener('DOMContentLoaded', async function () {
  const options = new xb.Options();
  options.world.enableMeshDetection();
  options.world.meshes.showDebugVisualizations = true;
  await xb.init(options);
});

</script>
  </body>
</html>

```


### Sample: modelviewer
File: `samples/modelviewer/ModelViewerScene.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';

const kLightX = xb.getUrlParamFloat('lightX', 0);
const kLightY = xb.getUrlParamFloat('lightY', 500);
const kLightZ = xb.getUrlParamFloat('lightZ', -10);

const ASSETS_BASE_URL = 'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/';
const PROPRIETARY_ASSETS_BASE_URL =
  'https://cdn.jsdelivr.net/gh/xrblocks/proprietary-assets@main/';

export class ModelViewerScene extends xb.Script {
  constructor() {
    super();
  }

  async init() {
    xb.core.input.addReticles();
    this.addLights();
    this.createModelFromObject();
    await Promise.all([
      this.createModelFromGLTF(),
      this.createModelFromAnimatedGLTF(),
      this.createModelFromSplat(),
      this.createModelInPanel(),
    ]);
  }

  addLights() {
    this.add(new THREE.HemisphereLight(0xbbbbbb, 0x888888, 3));
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(kLightX, kLightY, kLightZ);
    this.add(light);
  }

  createModelFromObject() {
    const model = new xb.ModelViewer({});
    model.add(
      new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 0.4),
        new THREE.MeshPhongMaterial({color: 0xdb5461})
      )
    );
    model.setupBoundingBox();
    model.setupRaycastCylinder();
    model.setupPlatform();
    model.position.set(-0.15, 0.75, -1.65);
    this.add(model);
  }

  async createModelFromGLTF() {
    const model = new xb.ModelViewer({});
    this.add(model);
    await model.loadGLTFModel({
      data: {
        scale: {x: 0.009, y: 0.009, z: 0.009},
        path: PROPRIETARY_ASSETS_BASE_URL,
        model: 'chess/chess_compressed.glb',
      },
      renderer: xb.core.renderer,
    });
    model.position.set(0, 0.78, -1.1);
  }

  async createModelFromAnimatedGLTF() {
    const model = new xb.ModelViewer({});
    this.add(model);
    await model.loadGLTFModel({
      data: {
        scale: {x: 1.0, y: 1.0, z: 1.0},
        path: ASSETS_BASE_URL,
        model: 'models/Cat/cat.gltf',
      },
      renderer: xb.core.renderer,
    });
    model.position.set(0.9, 0.68, -0.95);
  }

  async createModelFromSplat() {
    const model = new xb.ModelViewer({castShadow: false, receiveShadow: false});
    this.add(model);
    await model.loadSplatModel({
      data: {
        model: PROPRIETARY_ASSETS_BASE_URL + 'lego/lego.spz',
        scale: {x: 0.6, y: 0.6, z: 0.6},
        rotation: {x: 0, y: 180, z: 0},
      },
    });
    model.position.set(0.4, 0.78, -1.1);
    model.rotation.set(0, -Math.PI / 6, 0);
  }

  async createModelInPanel() {
    const panel = new xb.SpatialPanel({
      backgroundColor: '#00000000',
      width: 0.5,
      height: 0.25,
      useDefaultPosition: false,
    });
    panel.isRoot = true;
    this.add(panel);
    panel.position.set(0, 1.5, -2.0);

    panel.updateLayouts();

    const model = new xb.ModelViewer({});
    panel.add(model);
    await model.loadGLTFModel({
      data: {
        scale: {x: 0.002, y: 0.002, z: 0.002},
        rotation: {x: 0, y: 180, z: 0},
        path: PROPRIETARY_ASSETS_BASE_URL,
        model: 'earth/Earth_1_12756.glb',
      },
      setupPlatform: false,
      renderer: xb.core.renderer,
    });
  }
}

```
File: `samples/modelviewer/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Model Viewer | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/",
          "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js"
        }
      }
    </script>
  </head>

  <body>
    <div class="background-image" style="background-color: #000000"></div>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `samples/modelviewer/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import {html} from 'lit';
import * as xb from 'xrblocks';

import {ModelViewerScene} from './ModelViewerScene.js';

document.addEventListener('DOMContentLoaded', async () => {
  const modelViewerScene = new ModelViewerScene();
  xb.add(modelViewerScene);
  const options = new xb.Options();
  options.simulator.instructions.customInstructions = [
    {
      header: html`<h1>Model Viewer</h1>`,
      videoSrc: 'model_viewer_simulator_usage.webm',
      description: html`Click or pinch the object to rotate. Drag the platform
      to move.`,
    },
  ];
  options.setAppTitle('Model Viewer');
  await xb.init(options);
});

```


### Sample: paint
File: `samples/paint/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Paint | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as THREE from 'three';
import {TubePainter} from 'three/addons/misc/TubePainter.js';
import * as xb from 'xrblocks';

/**
 * A remixed version of three.js's examples/webxr_xr_paint.html in XR Blocks.
 * PaintDemo is an example script for using pinch to paint in Android XR and
 * using clicks to draw in desktop simulated environments.
 */
class PaintDemo extends xb.Script {
  init() {
    this.add(new THREE.HemisphereLight(0xffffff, 0x666666, /*intensity=*/ 3));

    // Painting setup.
    this.painters = [];
    this.user = xb.core.user;

    for (let i = 0; i < this.user.controllers.length; ++i) {
      const painter = new TubePainter();
      this.painters.push(painter);
      this.add(painter.mesh);
    }

    // Adds pivotal points to indicate user's intents.
    this.user.enablePivots();
  }

  /**
   * Moves the painter to the pivot position when select starts.
   * @param {XRInputSourceEvent} event
   */
  onSelectStart(event) {
    const id = event.target.userData.id;
    const painter = this.painters[id];
    const cursor = this.user.getPivotPosition(id);
    painter.moveTo(cursor);
  }

  /**
   * Updates the painter's line to the current pivot position during selection.
   * @param {XRInputSourceEvent} event
   */
  onSelecting(event) {
    const id = event.target.userData.id;
    const painter = this.painters[id];
    const cursor = this.user.getPivotPosition(id);
    painter.lineTo(cursor);
    painter.update();
  }

  /**
   * Stores the initial position and scale of the controller when squeeze
   * starts.
   * @param {XRInputSourceEvent} event
   */
  onSqueezeStart(event) {
    const controller = event.target;
    const id = controller.userData.id;
    const data = this.user.data[id].squeeze;

    data.positionOnStart = controller.position.y;
    data.scaleOnStart = controller.position.y;
  }

  /**
   * Updates the scale of the controller's pivot based on the squeeze amount.
   * @param {XRInputSourceEvent} event
   */
  onSqueezing(event) {
    const controller = event.target;
    const id = controller.userData.id;
    const pivot = this.user.getPivot(id);
    const data = this.user.data[id].squeeze;

    const delta = (controller.position.y - data.positionOnStart) * 5;
    const scale = Math.max(0.1, data.scaleOnStart + delta);
    pivot.scale.setScalar(scale);
  }
}

/**
 * Entry point for the application.
 */
function start() {
  const options = new xb.Options();
  options.setAppTitle('XR Paint');
  xb.add(new PaintDemo());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', start);

</script>
  </body>
</html>

```


### Sample: reticle
File: `samples/reticle/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Reticle | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
import * as xb from 'xrblocks';
import {TextBillboard} from 'xrblocks/addons/ui/TextBillboard.js';

class ReticleVisualizer extends xb.Script {
  activeControllerToBillboardMap = new Map();

  init() {
    xb.showReticleOnDepthMesh(true);
  }

  onSelectStart(event) {
    const controller = event.target;
    const intersection = xb.core.user.select(
      xb.core.depth.depthMesh,
      controller
    );
    if (!intersection) return;
    const billboard = new TextBillboard();
    this.add(billboard);
    this.activeControllerToBillboardMap.set(controller, billboard);
    this.updateBillboard(controller, billboard);
  }

  onSelectEnd(event) {
    this.activeControllerToBillboardMap.delete(event.target);
  }

  update() {
    this.activeControllerToBillboardMap.forEach((billboard, controller) => {
      this.updateBillboard(controller, billboard);
    });
  }

  updateBillboard(controller, billboard) {
    const intersection = xb.core.user.select(
      xb.core.depth.depthMesh,
      controller
    );
    if (intersection) {
      const reticleHeight = intersection.point.y;
      billboard.position.copy(intersection.point);
      billboard.lookAt(xb.core.camera.position);
      billboard.updateText(
        `Distance: ${intersection.distance.toFixed(2)} m\n` +
          `Height: ${reticleHeight.toFixed(2)} m`
      );
    }
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.depth = new xb.DepthOptions(xb.xrDepthMeshOptions);
  options.setAppTitle('XR Reticle');
  xb.add(new ReticleVisualizer());
  xb.init(options);
});

</script>
  </body>
</html>

```


### Sample: sound
File: `samples/sound/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Sound Sample | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../main.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js"
        }
      }
    </script>
  </head>

  <body>
    <script type="module">
/* eslint-env browser */
import * as THREE from 'three';
import * as xb from 'xrblocks';

class SoundDemoScript extends xb.Script {
  constructor() {
    super();
    this.soundBalls = [];
    this.mainPanel = null;
    this.recordedAudioBuffer = null;
    this.isRecording = false;
    this.recordBtn = null;
    this.statusText = null;
    this.volumeText = null;
    this.recordingStartTime = 0;
    this.currentVolume = 1.0;
    this.ballJumpPhase = 0;
  }

  init() {
    this.createSoundBalls();
    this.createDemoUI();

    const light = new THREE.DirectionalLight(0xffffff, 1.5);
    light.position.set(0, 3, 0);
    this.add(light);

    const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
    this.add(ambientLight);
  }

  createSoundBalls() {
    const ballPositions = [
      {x: -1.0, y: xb.user.height * 0.5, z: -1.5, color: 0xff6b6b},
      {x: 0.0, y: xb.user.height * 0.5, z: -1.5, color: 0x4ecdc4},
      {x: 1.0, y: xb.user.height * 0.5, z: -1.5, color: 0xffe66d},
    ];

    ballPositions.forEach((pos, index) => {
      const geometry = new THREE.SphereGeometry(0.1, 32, 32);
      const material = new THREE.MeshStandardMaterial({
        color: pos.color,
        metalness: 0.3,
        roughness: 0.4,
      });
      const ball = new THREE.Mesh(geometry, material);
      ball.position.set(pos.x, pos.y, pos.z);
      ball.userData.soundIndex = index;
      ball.name = `SoundBall${index}`;
      this.add(ball);
      this.soundBalls.push(ball);
    });
  }

  createDemoUI() {
    this.mainPanel = new xb.SpatialPanel({
      backgroundColor: '#1a1a1aF0',
      useDefaultPosition: false,
      showEdge: true,
      width: 1.0,
      height: 0.8,
    });
    this.mainPanel.isRoot = true;
    this.mainPanel.position.set(
      0,
      xb.user.height + 0.2,
      -xb.user.panelDistance
    );
    this.add(this.mainPanel);

    const mainGrid = this.mainPanel.addGrid();

    const titleRow = mainGrid.addRow({weight: 0.18});
    titleRow.addText({
      text: 'Sound Recorder',
      fontSize: 0.08,
      fontColor: '#4ecdc4',
    });

    const statusRow = mainGrid.addRow({weight: 0.15});
    this.statusText = statusRow.addText({
      text: 'Click mic to record',
      fontSize: 0.05,
      fontColor: '#ffe66d',
    });

    mainGrid.addRow({weight: 0.1});

    const controlRow = mainGrid.addRow({weight: 0.35});

    {
      const recordCol = controlRow.addCol({weight: 0.4});
      this.recordBtn = recordCol.addIconButton({
        text: 'mic',
        fontSize: 0.5,
      });

      this.recordBtn.onTriggered = () => {
        this.toggleRecording();
      };
    }

    {
      const volDownCol = controlRow.addCol({weight: 0.2});
      const volDownBtn = volDownCol.addIconButton({
        text: 'remove',
        fontSize: 0.5,
      });

      volDownBtn.onTriggered = () => {
        this.adjustVolume(-0.1);
      };
    }

    {
      const volDisplayCol = controlRow.addCol({weight: 0.2});
      this.volumeText = volDisplayCol.addText({
        text: '100%',
        fontSize: 0.5,
        fontColor: '#4ecdc4',
      });
    }

    {
      const volUpCol = controlRow.addCol({weight: 0.2});
      const volUpBtn = volUpCol.addIconButton({
        text: 'add',
        fontSize: 0.5,
      });

      volUpBtn.onTriggered = () => {
        this.adjustVolume(0.1);
      };
    }

    const bottomRow = mainGrid.addRow({weight: 0.2});
    bottomRow.addText({
      text: 'Click jumping balls to play',
      fontSize: 0.045,
      fontColor: '#888888',
    });

    if (this.mainPanel) {
      this.mainPanel.updateLayouts();
    }
  }

  async toggleRecording() {
    if (this.isRecording) {
      this.isRecording = false;
      this.updateStatus('Stopping recording...');
      await new Promise((resolve) => setTimeout(resolve, 300));
      this.recordedAudioBuffer = xb.core.sound.stopRecording();

      if (this.recordedAudioBuffer && this.recordedAudioBuffer.byteLength > 0) {
        const duration = (
          (Date.now() - this.recordingStartTime) /
          1000
        ).toFixed(1);
        this.updateStatus(`Recorded ${duration}s - Click balls to play`);
      } else {
        this.recordedAudioBuffer = null;
        this.updateStatus('Recording failed - no data captured');
      }

      this.recordBtn.text = 'mic';
    } else {
      // Start recording using SDK
      try {
        await xb.core.sound.startRecording();

        this.isRecording = true;
        this.recordingStartTime = Date.now();
        this.updateStatus('Recording... Click mic again to stop');
        this.recordBtn.text = 'mic_off';
      } catch (error) {
        this.updateStatus('Recording failed - ' + error);
        this.isRecording = false;
      }
    }
  }

  async playRecording() {
    if (!this.recordedAudioBuffer) {
      this.updateStatus('No recording - click mic first!');
      return;
    }

    try {
      this.updateStatus('Playing recording...');

      const sampleRate = xb.core.sound.getRecordingSampleRate();
      await xb.core.sound.playRecordedAudio(
        this.recordedAudioBuffer,
        sampleRate
      );

      setTimeout(() => {
        if (!this.isRecording) {
          this.updateStatus('Click mic to record');
        }
      }, 2000);
    } catch (error) {
      this.updateStatus('Playback failed: ' + error);
    }
  }

  adjustVolume(delta) {
    this.currentVolume = Math.max(0, Math.min(1, this.currentVolume + delta));
    const volumePercent = Math.round(this.currentVolume * 100);

    xb.core.sound.setMasterVolume(this.currentVolume);

    if (this.volumeText) {
      this.volumeText.text = `${volumePercent}%`;
    }

    this.updateStatus(`Volume: ${volumePercent}%`);
  }

  updateStatus(message) {
    if (this.statusText) {
      this.statusText.text = message;
    }
  }

  onSelectStart(event) {
    const controller = event.target;

    this.soundBalls.forEach((ball) => {
      const intersection = xb.core.user.select(ball, controller);
      if (intersection) {
        if (this.recordedAudioBuffer) {
          this.playRecordingFromBall(ball);
          this.updateStatus(
            `Playing from ball ${ball.userData.soundIndex + 1}`
          );
        } else {
          this.updateStatus('Record something first!');
        }

        this.pulseBall(ball);
      }
    });
  }

  async playRecordingFromBall(ball) {
    if (!this.recordedAudioBuffer) return;

    try {
      const sampleRate = xb.core.sound.getRecordingSampleRate();
      const audioListener = xb.core.sound.getAudioListener();

      const audioContext = new AudioContext({sampleRate: sampleRate});

      const int16Data = new Int16Array(this.recordedAudioBuffer);
      const audioBuffer = audioContext.createBuffer(
        1,
        int16Data.length,
        sampleRate
      );
      const channelData = audioBuffer.getChannelData(0);
      for (let i = 0; i < int16Data.length; i++) {
        channelData[i] = int16Data[i] / 32768.0;
      }

      const positionalAudio = new THREE.PositionalAudio(audioListener);
      positionalAudio.setBuffer(audioBuffer);
      positionalAudio.setRefDistance(0.5);
      positionalAudio.setRolloffFactor(2.0);
      positionalAudio.setVolume(this.currentVolume);

      ball.add(positionalAudio);
      positionalAudio.play();

      positionalAudio.onEnded = () => {
        ball.remove(positionalAudio);
        audioContext.close();
      };
    } catch (error) {
      this.updateStatus('Play recording from ball failed: ' + error);
    }
  }

  pulseBall(ball) {
    const originalScale = ball.scale.clone();
    const targetScale = originalScale.clone().multiplyScalar(1.3);
    const startTime = Date.now();
    const duration = 200;

    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);

      if (progress < 0.5) {
        const t = progress * 2;
        ball.scale.lerpVectors(originalScale, targetScale, t);
      } else {
        const t = (progress - 0.5) * 2;
        ball.scale.lerpVectors(targetScale, originalScale, t);
      }

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        ball.scale.copy(originalScale);
      }
    };

    animate();
  }

  update() {
    this.soundBalls.forEach((ball, index) => {
      ball.rotation.y += 0.01 * (index + 1);

      if (this.recordedAudioBuffer) {
        this.ballJumpPhase += 0.01;
        const jumpHeight = 0.08;
        const baseHeight = xb.user.height * 0.5;
        const jumpOffset =
          Math.abs(Math.sin(this.ballJumpPhase + (index * Math.PI) / 3)) *
          jumpHeight;
        ball.position.y = baseHeight + jumpOffset;

        const targetScale = 1.1;
        ball.scale.lerp(
          new THREE.Vector3(targetScale, targetScale, targetScale),
          0.1
        );
      } else {
        const baseHeight = xb.user.height * 0.5;
        ball.position.y = baseHeight;
        ball.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
      }
    });
  }

  destroy() {
    if (this.isRecording) {
      xb.core.sound.disableAudio();
    }
    super.destroy();
  }
}

document.addEventListener('DOMContentLoaded', function () {
  const options = new xb.Options();
  options.reticles.enabled = true;
  options.controllers.visualizeRays = true;
  options.setAppTitle('XR Sound');

  xb.add(new SoundDemoScript());
  xb.init(options);
});

</script>
  </body>
</html>

```


### Sample: ui
File: `samples/ui/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>UI Panels Showcase | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js"
        }
      }
    </script>
  </head>

  <body>
    <canvas
      id="barChartCanvas"
      width="512"
      height="340"
      style="display: none"
    ></canvas>
    <script type="module">
      import * as THREE from 'three';
      import * as xb from 'xrblocks';

      class MainScript extends xb.Script {
        createProfilePanel() {
          const profilePanel = new xb.SpatialPanel({
            width: 0.8,
            height: 1.0,
            backgroundColor: '#282c3488',
          });
          profilePanel.rotation.set(0, 45, 0);
          profilePanel.position.set(-1.5, 1.5, -2.0);
          this.add(profilePanel);

          const profileGrid = profilePanel.addGrid();
          profileGrid.addRow({weight: 0.1}).addText({
            text: 'UI Samples',
            fontSize: 0.07,
            fontColor: '#61dafb',
          });

          const avatarRow = profileGrid.addRow({weight: 0.4});
          avatarRow.addCol({weight: 0.15});
          const avatarCol = avatarRow.addCol({weight: 0.7});
          avatarCol.addImage({
            src: 'https://placehold.co/256x128/61dafb/282c34.png?text=XRBlocks',
          });

          profileGrid
            .addRow({weight: 0.15})
            .addText({text: 'Spatial Panel', fontSize: 0.08});
          profileGrid.addRow({weight: 0.25}).addText({
            text: 'You may drag borders of this spatial panel to move it around.',
            fontSize: 0.07,
            fontColor: '#abb2bf',
          });
        }

        createProfilePanelFromJSON() {
          const profilePanelJson = {
            type: 'Panel',
            options: {
              name: 'JSON Panel',
              width: 1.0,
              height: 1.2,
              backgroundColor: '#282c3488',
            },
            position: {x: 1.5, y: 1.5, z: -2.0},
            rotation: {x: 0, y: -45, z: 0},
            children: [
              {
                name: 'JSON Grid',
                type: 'Grid',
                children: [
                  {
                    // Padding Row
                    type: 'Row',
                    options: {weight: 0.1},
                  },
                  {
                    // Title Row
                    type: 'Row',
                    options: {weight: 0.1},
                    children: [
                      {
                        type: 'Text',
                        options: {
                          text: 'Panel',
                          fontSize: 0.07,
                          fontColor: '#61dafb',
                        },
                      },
                    ],
                  },
                  {
                    // Avatar Row
                    type: 'Row',
                    options: {weight: 0.4, name: 'AvatarRow'},
                    children: [
                      {
                        type: 'Col',
                        options: {weight: 0.15},
                      }, // Left spacer
                      {
                        type: 'Col',
                        options: {weight: 0.7},
                        children: [
                          {
                            type: 'Image',
                            options: {
                              name: 'PlaceHolderImage',
                              src: 'https://placehold.co/256x128/61dafb/282c34.png?text=XRBlocks',
                            },
                          },
                        ],
                      },
                      {
                        type: 'Col',
                        options: {weight: 0.15},
                      }, // Right spacer
                    ],
                  },
                  {
                    // Name Row
                    type: 'Row',
                    options: {weight: 0.15},
                    children: [
                      {
                        type: 'Text',
                        options: {text: 'Panel from JSON', fontSize: 0.08},
                      },
                    ],
                  },
                  {
                    // Subtitle Row
                    type: 'Row',
                    options: {weight: 0.25},
                    children: [
                      {
                        type: 'Text',
                        options: {
                          text: 'This panel cannot be dragged around.',
                          fontSize: 0.07,
                          fontColor: '#abb2bf',
                        },
                      },
                    ],
                  },
                ],
              },
            ],
          };

          const profileUI = xb.core.ui.compose(profilePanelJson);
          this.add(profileUI);
        }

        createPlayerPanel() {
          // Panel 2: Interactive Media Player (Top-Center)
          const panel = new xb.SpatialPanel({
            width: 1.3,
            height: 1.25,
            backgroundColor: '#00000000',
          });
          panel.position.set(
            0,
            xb.user.height * 2.0,
            -xb.user.panelDistance - 1.0
          );
          panel.isRoot = true;
          this.add(panel);
          const grid = panel.addGrid();
          // Space for orbiter
          grid.addRow({weight: 0.0});
          // player row
          const playerRow = grid.addRow({weight: 1.0});
          const playerPanel = playerRow.addPanel({
            width: 1.2,
            height: 1.2,
            backgroundColor: '#21252baa',
          });
          const playerGrid = playerPanel.addGrid();
          {
            // video row
            playerGrid.addRow({weight: 0.1});
            const videoRow = playerGrid.addRow({weight: 0.5});
            videoRow.addVideo({
              src: 'https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
            });
            // progress row
            const progressRow = playerGrid.addRow({weight: 0.05});
            // controls row
            const controlsRow = playerGrid.addRow({weight: 0.35});
            controlsRow.addCol({weight: 0.2});
            controlsRow
              .addCol({weight: 0.2})
              .addIconButton({text: 'skip_previous', fontSize: 0.4});
            controlsRow
              .addCol({weight: 0.2})
              .addIconButton({text: 'play_arrow', fontSize: 0.6});
            controlsRow
              .addCol({weight: 0.2})
              .addIconButton({text: 'skip_next', fontSize: 0.4});
            controlsRow.addCol({weight: 0.2});
          }
          const orbiter = playerGrid.addOrbiter({
            orbiterScale: 0.1,
          });
          orbiter.addExitButton();
          panel.updateLayouts();
        }

        createSettingsPanel() {
          // Panel 3: Settings Menu (Top-Right)
          const settingsPanel = new xb.SpatialPanel({
            width: 1.0,
            height: 1.2,
            backgroundColor: '#282c3488',
          });
          settingsPanel.position.set(
            1.5,
            xb.user.height,
            -xb.user.panelDistance + 2.0
          );
          settingsPanel.rotation.set(0, -Math.PI / 2.0, 0);

          this.add(settingsPanel);
          const settingsGrid = settingsPanel.addGrid();
          settingsGrid.addRow({weight: 0.15}).addText({
            text: 'Fake Settings',
            fontSize: 0.1,
            fontColor: '#61dafb',
          });

          const addSettingRow = (grid, label, type) => {
            const row = grid.addRow({weight: 0.2});
            row.addCol({weight: 0.6}).addText({
              text: label,
              anchorX: 'left',
              textAlign: 'left',
              fontSize: 0.07,
            });
            const controlCol = row.addCol({weight: 0.4});
            if (type === 'toggle') {
              const toggleBg = controlCol.addPanel({
                backgroundColor: '#61dafb',
                width: 0.3,
                height: 0.06,
              });
              toggleBg.addGrid().addPanel({
                backgroundColor: '#ffffff',
                width: 0.05,
                height: 0.05,
                x: 0.04,
              });
            } else if (type === 'slider') {
              const sliderBg = controlCol.addPanel({
                backgroundColor: '#3a3f4b',
                width: 0.35,
                height: 0.02,
              });
              sliderBg.addGrid().addPanel({
                backgroundColor: '#61dafb',
                width: 0.04,
                height: 0.04,
                x: 0.05,
              });
            }
          };

          addSettingRow(settingsGrid, 'Enable Hand Tracking', 'toggle');
          addSettingRow(settingsGrid, 'Show Notifications', 'toggle');
          addSettingRow(settingsGrid, 'Master Volume', 'slider');
          addSettingRow(settingsGrid, 'UI Scale', 'slider');
        }

        createGalleryPanel() {
          // Panel 4: Photo Gallery (Bottom-Right)
          const galleryPanel = new xb.SpatialPanel({
            width: 1.5,
            height: 1.0,
            backgroundColor: '#21252b88',
          });
          galleryPanel.position.set(
            0.0,
            xb.user.height,
            -xb.user.panelDistance - 1.0
          );
          this.add(galleryPanel);
          const galleryGrid = galleryPanel.addGrid();
          galleryGrid.addRow({weight: 0.25}).addText({
            text: 'Photo Gallery',
            fontSize: 0.07,
            fontColor: '#61dafb',
          });
          const photoRow1 = galleryGrid.addRow({weight: 0.375});
          photoRow1.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/92c5fd/333?text=Img1',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          photoRow1.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/6ee7b7/333?text=Img2',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          photoRow1.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/fca5a5/333?text=Img3',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          galleryGrid.addRow({weight: 0.05});
          const photoRow2 = galleryGrid.addRow({weight: 0.375});
          photoRow2.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/fde047/333?text=Img4',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          photoRow2.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/c4b5fd/333?text=Img5',
            paddingX: 0.02,
            paddingY: 0.02,
          });
          photoRow2.addCol({weight: 1 / 3}).addImage({
            src: 'https://placehold.co/150x150/f9a8d4/333?text=Img6',
            paddingX: 0.02,
            paddingY: 0.02,
          });
        }

        createFormPanel() {
          // Panel 5: Complex Form (Bottom-Left)
          const formPanel = new xb.SpatialPanel({
            width: 1.2,
            height: 1.4,
            backgroundColor: '#282c34',
          });
          formPanel.position.set(-1.8, 0.7, -2.5);
          this.add(formPanel);
          const formGrid = formPanel.addGrid();
          formGrid.addRow({weight: 0.1}).addText({
            text: 'Feedback Form',
            fontSize: 0.07,
            fontColor: '#61dafb',
          });
          const addFormField = (grid, label) => {
            const row = grid.addRow({weight: 0.12});
            row
              .addCol({weight: 0.3})
              .addText({text: label, anchorX: 'left', fontSize: 0.05});
            row
              .addCol({weight: 0.7})
              .addPanel({backgroundColor: '#3a3f4b', height: 0.06});
          };
          addFormField(formGrid, 'Name');
          addFormField(formGrid, 'Email');
          const categoryRow = formGrid.addRow({weight: 0.12});
          categoryRow
            .addCol({weight: 0.3})
            .addText({text: 'Category', anchorX: 'left', fontSize: 0.05});
          const dropdown = categoryRow
            .addCol({weight: 0.7})
            .addPanel({backgroundColor: '#3a3f4b', height: 0.06});
          dropdown
            .addGrid()
            .addText({text: 'General Feedback  ‚ñº', fontSize: 0.045});

          const messageRow = formGrid.addRow({weight: 0.3});
          messageRow.addCol({weight: 0.3}).addText({
            text: 'Message',
            anchorX: 'left',
            anchorY: 'top',
            fontSize: 0.05,
          });
          messageRow
            .addCol({weight: 0.7})
            .addPanel({backgroundColor: '#3a3f4b', height: 0.2});

          formGrid.addRow({weight: 0.18}).addTextButton({
            text: 'Submit',
            backgroundColor: '#61dafb',
            fontColor: '#282c34',
            height: 0.08,
            width: 0.3,
          });
        }

        createChartPanel() {
          // Panel 6: Dynamic Chart with Canvas (Bottom-Center)
          const chartPanel = new xb.SpatialPanel({
            width: 0.8,
            height: 0.6,
            backgroundColor: '#21252b88',
          });
          chartPanel.position.set(
            -1.5,
            xb.user.height,
            -xb.user.panelDistance + 2.0
          );
          chartPanel.rotation.set(0, Math.PI / 2.0, 0);

          this.add(chartPanel);
          const chartGrid = chartPanel.addGrid();
          chartGrid.addRow({weight: 0.15}).addText({
            text: 'Performance Metrics',
            fontSize: 0.07,
            fontColor: '#61dafb',
          });

          // --- Canvas Chart ---
          const canvas = document.getElementById('barChartCanvas');
          const ctx = canvas.getContext('2d');
          const barData = [0.4, 0.7, 0.5, 0.8, 0.6];
          const colors = [
            '#92c5fd',
            '#6ee7b7',
            '#fca5a5',
            '#fde047',
            '#c4b5fd',
          ];
          const padding = 40;
          const barWidth =
            (canvas.width - padding * (barData.length + 1)) / barData.length;
          const maxBarHeight = canvas.height - padding * 2;

          ctx.fillStyle = '#282c34'; // background
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          barData.forEach((value, index) => {
            const barHeight = value * maxBarHeight;
            const x = padding + index * (barWidth + padding);
            const y = canvas.height - padding - barHeight;
            ctx.fillStyle = colors[index];
            ctx.fillRect(x, y, barWidth, barHeight);
          });

          const canvasTexture = new THREE.CanvasTexture(canvas);
          canvasTexture.needsUpdate = true;
          const chartCol = chartGrid.addCol();
          chartCol.addRow({weight: 0.15});
          const chartArea = chartCol.addRow({weight: 0.85});
          const chartMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(1, 1),
            new THREE.MeshBasicMaterial({map: canvasTexture})
          );
          chartArea.add(chartMesh);

          const tmpRow = chartGrid.addCol();
          tmpRow.addRow({weight: 0.3});
          const okButton = tmpRow.addRow().addTextButton({
            text: 'OK',
            backgroundColor: '#22aa33',
            opacity: 0.5,
            fontColor: '#66ccff',
            fontSizeDp: 50,
          });
        }

        init() {
          this.add(new THREE.HemisphereLight(0xffffff, 0x666666, 3));

          this.createProfilePanel();
          this.createProfilePanelFromJSON();
          this.createPlayerPanel();
          this.createGalleryPanel();
          this.createChartPanel();
          this.createSettingsPanel();
        }
      }

      document.addEventListener('DOMContentLoaded', function () {
        const options = new xb.Options();
        options.enableUI();
        options.setAppTitle('Spatial UI');
        xb.add(new MainScript());
        xb.init(options);
      });
    </script>
  </body>
</html>

```


### Demo: balloonpop
File: `demos/balloonpop/BalloonPop.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';
import {playPopSound, playWhooshSound} from './audio.js';

// --- CONSTANTS ---
const DART_SPEED = 15.0;
const DART_GRAVITY_SCALE = 0.1;
const MENU_WIDTH = 0.85;
const PARTICLE_COUNT = 30;
const PARTICLE_LIFE = 1.0;
const BOUNDARY_RADIUS = 7.62;
const BOUNDARY_IMPULSE = 0.02;

// Physics Groups
export const GROUP_WORLD = (0x0001 << 16) | (0x0002 | 0x0004);
const GROUP_BALLOON = (0x0002 << 16) | (0x0001 | 0x0002 | 0x0004);
const GROUP_DART = (0x0004 << 16) | (0x0001 | 0x0002);

// --- UI HELPER ---
function createStepperControl(
  game,
  grid,
  labelText,
  valueRef,
  min,
  max,
  step,
  isCount
) {
  const H_BUTTON = 0.15;
  const H_VALUE_LABEL = 0.12;
  const menuHeight = game.menuPanel.height;
  const getW = (h) => h / menuHeight;

  grid.addRow({weight: getW(H_BUTTON)}).addTextButton({
    text: '+',
    fontColor: '#ffffff',
    backgroundColor: '#4285f4',
    fontSize: 0.7,
    width: 0.3,
    weight: 1.0,
  }).onTriggered = () => {
    const maxVal = isCount ? max : 0.1;
    game[valueRef] = Math.min(maxVal, game[valueRef] + step);
    game.renderMenu();
  };

  const displayValue = isCount
    ? game[valueRef]
    : Math.round(game[valueRef] * 100);
  const valueText = grid.addRow({weight: getW(H_VALUE_LABEL)}).addText({
    text: `${labelText}: ${displayValue}`,
    fontColor: '#ffffff',
    fontSize: 0.12,
    textAlign: 'center',
  });

  if (isCount) game.countValueText = valueText;
  else game.speedValueText = valueText;

  grid.addRow({weight: getW(H_BUTTON)}).addTextButton({
    text: '-',
    fontColor: '#ffffff',
    backgroundColor: '#4285f4',
    fontSize: 0.7,
    width: 0.3,
    weight: 1.0,
  }).onTriggered = () => {
    game[valueRef] = Math.max(min, game[valueRef] - step);
    game.renderMenu();
  };
  grid.addRow({weight: getW(0.01)});
}

export class BalloonGame extends xb.Script {
  constructor() {
    super();
    this.balloons = new Map();
    this.darts = new Map();
    this.particles = [];
    this.balloonCount = 10;
    this.balloonSpeed = 0.03;
    this.balloonsPopped = 0;
    this.activeDart = null;
    this.menuPanel = null;
    this.isMenuExpanded = true;
    this.physics = null;
    this.physicsWorld = null;
    this.RAPIER = null;
    this.balloonModel = null;
    this.dartModel = null;
    this.particleGeometry = null;
    this.particleMaterial = null;
    this.raycaster = new THREE.Raycaster();
    this.menuPos = new THREE.Vector3(0.6, 1.3, -1.0);
    this.menuRot = new THREE.Euler(0, -0.4, 0);
  }

  async init() {
    // Post-init Stable Activation of Depth Mesh Physics
    setTimeout(() => {
      const options = xb.core.registry.get(xb.Options);
      if (options && options.depth) {
        options.depth.enabled = true;
        if (options.depth.depthMesh) {
          options.depth.depthMesh.enabled = true;
          options.depth.depthMesh.physicsEnabled = true;
          options.depth.depthMesh.collisionGroups = GROUP_WORLD;
        }
      }
    }, 1000);

    this.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3));
    const dirLight = new THREE.DirectionalLight(0xffffff, 2);
    dirLight.position.set(1, 2, 1);
    this.add(dirLight);

    this.createPrefabs();
    this.renderMenu();
  }

  createPrefabs() {
    // --- DART ---
    this.dartModel = new THREE.Group();
    const needleMat = new THREE.MeshStandardMaterial({
      color: 0xaaaaaa,
      metalness: 1.0,
      roughness: 0.1,
    });
    const silverMat = new THREE.MeshStandardMaterial({
      color: 0xcccccc,
      metalness: 0.8,
      roughness: 0.3,
    });
    const redMat = new THREE.MeshStandardMaterial({
      color: 0xaa0000,
      roughness: 0.5,
    });
    const finMat = new THREE.MeshStandardMaterial({
      color: 0xcc0000,
      roughness: 0.6,
    });
    const needle = new THREE.Mesh(
      new THREE.ConeGeometry(0.002, 0.04, 6),
      needleMat
    );
    needle.position.y = 0.17;
    const tipHolder = new THREE.Mesh(
      new THREE.CylinderGeometry(0.008, 0.012, 0.03, 8),
      silverMat
    );
    tipHolder.position.y = 0.135;
    const body = new THREE.Mesh(
      new THREE.CylinderGeometry(0.01, 0.01, 0.18, 8),
      redMat
    );
    body.position.y = 0.03;
    const createFin = (rotationY) => {
      const fin = new THREE.Mesh(
        new THREE.BoxGeometry(0.07, 0.05, 0.002, 1, 1, 1),
        finMat
      );
      fin.position.set(0, -0.05, 0);
      fin.rotation.set(Math.PI, rotationY, 0);
      return fin;
    };
    this.dartModel.add(needle, tipHolder, body);
    this.dartModel.add(createFin(0));
    this.dartModel.add(createFin(Math.PI / 2));
    this.dartModel.add(createFin(Math.PI));
    this.dartModel.add(createFin(Math.PI * 1.5));

    // --- HIGH-FIDELITY BALLOON ---
    this.balloonModel = new THREE.Group();
    const balloonGeo = new THREE.SphereGeometry(0.5, 32, 32);
    const pos = balloonGeo.attributes.position;
    const v = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
      v.fromBufferAttribute(pos, i);
      if (v.y < 0) {
        const t = 1.0 - Math.abs(v.y) * 0.35;
        v.x *= t;
        v.z *= t;
      }
      pos.setXYZ(i, v.x, v.y, v.z);
    }
    balloonGeo.computeVertexNormals();
    const balloonMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.2,
      metalness: 0.1,
      transparent: true,
      opacity: 0.85,
      side: THREE.FrontSide,
    });
    this.balloonModel.add(new THREE.Mesh(balloonGeo, balloonMat));
    const knotGeo = new THREE.CylinderGeometry(0.03, 0.01, 0.12, 16);
    knotGeo.translate(0, -0.54, 0);
    this.balloonModel.add(new THREE.Mesh(knotGeo, balloonMat));
    const ringGeo = new THREE.TorusGeometry(0.035, 0.015, 8, 24);
    ringGeo.rotateX(Math.PI / 2);
    ringGeo.translate(0, -0.6, 0);
    this.balloonModel.add(new THREE.Mesh(ringGeo, balloonMat));

    this.particleGeometry = new THREE.PlaneGeometry(0.08, 0.08);
    this.particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 1.0,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
    });
  }

  initPhysics(physics) {
    this.physics = physics;
    this.physicsWorld = physics.blendedWorld;
    this.RAPIER = physics.RAPIER;
    this.spawnBalloons();
    this.renderMenu();
  }

  renderMenu() {
    if (this.menuPanel) {
      this.menuPos.copy(this.menuPanel.position);
      this.menuRot.copy(this.menuPanel.rotation);
      this.remove(this.menuPanel);
    }
    const H_TOGGLE = 0.1;
    const H_SCORE = 0.15;
    const H_RESET = 0.15;
    const H_SPACE = 0.03;
    const H_BUTTON = 0.15;
    const H_VALUE_LABEL = 0.12;
    const headerHeight = H_TOGGLE + H_SCORE + H_RESET + H_SPACE;
    const expandedControlsHeight =
      (H_BUTTON + H_VALUE_LABEL + H_BUTTON + H_SPACE) * 2;
    const menuHeight = this.isMenuExpanded
      ? headerHeight + expandedControlsHeight
      : headerHeight;
    const getW = (h) => h / menuHeight;

    this.menuPanel = new xb.SpatialPanel({
      width: MENU_WIDTH,
      height: menuHeight,
      backgroundColor: '#2b2b2baa',
      showEdge: true,
      edgeColor: 'white',
      edgeWidth: 0.001,
    });
    this.menuPanel.position.copy(this.menuPos);
    this.menuPanel.rotation.copy(this.menuRot);
    this.add(this.menuPanel);
    const grid = this.menuPanel.addGrid();
    grid.addRow({weight: getW(H_TOGGLE)}).addTextButton({
      text: this.isMenuExpanded ? '\u25B2' : '\u25BC',
      fontColor: '#ffffff',
      backgroundColor: '#444444',
      fontSize: 0.7,
      weight: 1.0,
    }).onTriggered = () => this.toggleMenu();
    this.scoreText = grid.addRow({weight: getW(H_SCORE)}).addText({
      text: `${this.balloonsPopped} / ${this.balloonCount}`,
      fontColor: '#ffffff',
      fontSize: 0.15,
      textAlign: 'center',
    });
    grid.addRow({weight: getW(H_RESET)}).addTextButton({
      text: '\u21BB',
      fontColor: '#ffffff',
      backgroundColor: '#d93025',
      fontSize: 0.7,
      weight: 1.0,
    }).onTriggered = () => this.resetGame();
    grid.addRow({weight: getW(H_SPACE)});
    if (this.isMenuExpanded) {
      createStepperControl(
        this,
        grid,
        'Balloons',
        'balloonCount',
        5,
        30,
        1,
        true
      );
      createStepperControl(
        this,
        grid,
        'Speed',
        'balloonSpeed',
        0.0,
        0.1,
        0.01,
        false
      );
    }
  }

  toggleMenu() {
    this.isMenuExpanded = !this.isMenuExpanded;
    this.renderMenu();
  }
  updateScoreDisplay() {
    if (this.scoreText)
      this.scoreText.text = `${this.balloonsPopped} / ${this.balloonCount}`;
  }
  resetGame() {
    this.spawnBalloons();
    this.renderMenu();
  }

  spawnBalloons() {
    if (!this.physicsWorld || !this.RAPIER || !this.balloonModel) return;
    this.clearBalloons();
    this.balloonsPopped = 0;
    this.updateScoreDisplay();
    const color = new THREE.Color();
    for (let i = 0; i < this.balloonCount; i++) {
      const grp = this.balloonModel.clone();
      const x = (Math.random() - 0.5) * 4,
        y = 1.5 + Math.random() * 1,
        z = -2 - Math.random() * 2;
      grp.position.set(x, y, z);
      const s = 0.7 + Math.random() * 0.6;
      grp.scale.set(s, s, s);
      color.setHSL(Math.random(), 0.95, 0.6);
      grp.traverse((c) => {
        if (c.isMesh) {
          c.material = c.material.clone();
          c.material.color.copy(color);
        }
      });
      const rb = this.physicsWorld.createRigidBody(
        this.RAPIER.RigidBodyDesc.dynamic()
          .setTranslation(x, y, z)
          .setGravityScale(-0.05 * s)
          .setLinearDamping(0.5)
          .setAngularDamping(0.5)
      );
      const col = this.physicsWorld.createCollider(
        this.RAPIER.ColliderDesc.ball(0.5 * s)
          .setActiveEvents(this.RAPIER.ActiveEvents.COLLISION_EVENTS)
          .setRestitution(0.85)
          .setDensity(0.1)
          .setCollisionGroups(GROUP_BALLOON),
        rb
      );
      this.balloons.set(col.handle, {
        mesh: grp,
        rigidBody: rb,
        collider: col,
        color: color.clone(),
      });
      this.add(grp);
    }
  }

  clearBalloons() {
    if (!this.physicsWorld) return;
    for (const [h, b] of this.balloons.entries()) {
      this.remove(b.mesh);
      this.physicsWorld.removeCollider(b.collider, false);
      this.physicsWorld.removeRigidBody(b.rigidBody);
    }
    this.balloons.clear();
  }

  spawnExplosion(position, color) {
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const mat = this.particleMaterial.clone();
      mat.color.copy(color);
      const mesh = new THREE.Mesh(this.particleGeometry, mat);
      mesh.position.copy(position);
      this.add(mesh);
      this.particles.push({
        mesh,
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 4.0,
          (Math.random() - 0.5) * 4.0,
          (Math.random() - 0.5) * 4.0
        ),
        life: PARTICLE_LIFE,
      });
    }
  }

  onSelectStart(event) {
    if (this.menuPanel && this.menuPanel.parent) {
      const ctrl = event.target,
        pos = new THREE.Vector3(),
        quat = new THREE.Quaternion();
      ctrl.getWorldPosition(pos);
      ctrl.getWorldQuaternion(quat);
      this.raycaster.set(
        pos,
        new THREE.Vector3(0, 0, -1).applyQuaternion(quat)
      );
      if (this.raycaster.intersectObject(this.menuPanel, true).length > 0)
        return;
    }
    if (this.activeDart) return;
    this.activeDart = this.dartModel.clone();
    this.activeDart.position.set(0, -0.05, -0.15);
    this.activeDart.rotation.set(-Math.PI / 2, 0, 0);
    event.target.add(this.activeDart);
  }

  onSelectEnd(event) {
    const ctrl = event.target;
    if (!this.activeDart || !this.physicsWorld) return;
    const dart = this.activeDart;
    this.activeDart = null;
    const wPos = new THREE.Vector3(),
      wQuat = new THREE.Quaternion();
    dart.getWorldPosition(wPos);
    dart.getWorldQuaternion(wQuat);
    ctrl.remove(dart);
    dart.position.copy(wPos);
    dart.quaternion.copy(wQuat);
    this.add(dart);
    playWhooshSound();
    const rb = this.physicsWorld.createRigidBody(
      this.RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(wPos.x, wPos.y, wPos.z)
        .setRotation(wQuat)
        .setGravityScale(DART_GRAVITY_SCALE)
        .setCcdEnabled(true)
    );
    const col = this.physicsWorld.createCollider(
      this.RAPIER.ColliderDesc.capsule(0.1, 0.015)
        .setActiveEvents(this.RAPIER.ActiveEvents.COLLISION_EVENTS)
        .setSensor(true)
        .setCollisionGroups(GROUP_DART),
      rb
    );
    rb.setLinvel(
      new THREE.Vector3(0, 1, 0)
        .applyQuaternion(wQuat)
        .multiplyScalar(DART_SPEED),
      true
    );
    this.darts.set(col.handle, {mesh: dart, rigidBody: rb, collider: col});
  }

  update(time, delta) {
    if (this.physicsWorld) {
      for (const [h, b] of this.balloons.entries()) {
        b.mesh.position.copy(b.rigidBody.translation());
        b.mesh.quaternion.copy(b.rigidBody.rotation());
      }
      for (const [h, d] of this.darts.entries()) {
        d.mesh.position.copy(d.rigidBody.translation());
        d.mesh.quaternion.copy(d.rigidBody.rotation());
        if (d.mesh.position.y < -5 || Math.abs(d.mesh.position.z) > 30)
          this.removeDart(h);
      }
    }
    const dt = delta || 1 / 60;
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.life -= dt;
      if (p.life <= 0) {
        this.remove(p.mesh);
        this.particles.splice(i, 1);
      } else {
        p.mesh.position.addScaledVector(p.velocity, dt);
        p.mesh.material.opacity = p.life / PARTICLE_LIFE;
        if (xb.core.camera) p.mesh.lookAt(xb.core.camera.position);
      }
    }
  }

  physicsStep() {
    if (!this.physics || !this.physicsWorld || !xb.core.camera) return;
    const camPos = xb.core.camera.position;
    const speedFactor = this.balloonSpeed / 10;
    for (const [h, b] of this.balloons.entries()) {
      const s = speedFactor;
      b.rigidBody.addForce(
        {
          x: (Math.random() - 0.5) * s,
          y: (Math.random() - 0.5) * (s * 0.5),
          z: (Math.random() - 0.5) * s,
        },
        true
      );
      const p = b.rigidBody.translation();
      const dx = p.x - camPos.x,
        dz = p.z - camPos.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      if (dist > BOUNDARY_RADIUS) {
        b.rigidBody.applyImpulse(
          {
            x: (-dx / dist) * BOUNDARY_IMPULSE,
            y: 0,
            z: (-dz / dist) * BOUNDARY_IMPULSE,
          },
          true
        );
      }
      if (p.y > 5.0)
        b.rigidBody.applyImpulse({x: 0, y: -BOUNDARY_IMPULSE, z: 0}, true);
      if (p.y < 0.5)
        b.rigidBody.applyImpulse({x: 0, y: BOUNDARY_IMPULSE, z: 0}, true);
    }
    this.physics.eventQueue.drainCollisionEvents((h1, h2, s) => {
      if (!s) return;
      if (this.darts.has(h1) && this.balloons.has(h2)) {
        this.popBalloon(h2);
        this.removeDart(h1);
      } else if (this.darts.has(h2) && this.balloons.has(h1)) {
        this.popBalloon(h1);
        this.removeDart(h2);
      }
    });
  }

  popBalloon(h) {
    const b = this.balloons.get(h);
    if (b) {
      this.spawnExplosion(b.mesh.position.clone(), b.color);
      playPopSound();
    }
    this.removeBalloon(h);
    this.balloonsPopped++;
    this.updateScoreDisplay();
  }
  removeBalloon(h) {
    const b = this.balloons.get(h);
    if (!b) return;
    this.remove(b.mesh);
    this.physicsWorld.removeCollider(b.collider, false);
    this.physicsWorld.removeRigidBody(b.rigidBody);
    this.balloons.delete(h);
  }
  removeDart(h) {
    const d = this.darts.get(h);
    if (!d) return;
    this.remove(d.mesh);
    this.physicsWorld.removeCollider(d.collider, false);
    this.physicsWorld.removeRigidBody(d.rigidBody);
    this.darts.delete(h);
  }
}

```
File: `demos/balloonpop/audio.js`
```javascript
// --- AUDIO CONTEXT (Retro Noise Pop) ---
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

export function playPopSound() {
  if (audioContext.state === 'suspended') audioContext.resume();
  const noiseSource = audioContext.createBufferSource();
  const bandpass = audioContext.createBiquadFilter();
  const gainNode = audioContext.createGain();
  const now = audioContext.currentTime;

  const sampleRate = audioContext.sampleRate;
  const bufferSize = sampleRate * 0.15;
  const noiseBuffer = audioContext.createBuffer(1, bufferSize, sampleRate);
  const output = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1;
  }
  noiseSource.buffer = noiseBuffer;

  bandpass.type = 'bandpass';
  bandpass.frequency.setValueAtTime(3000, now);
  bandpass.Q.setValueAtTime(1.2, now);

  gainNode.gain.setValueAtTime(0, now);
  gainNode.gain.linearRampToValueAtTime(0.8, now + 0.002);
  gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

  noiseSource.connect(bandpass);
  bandpass.connect(gainNode);
  gainNode.connect(audioContext.destination);
  noiseSource.start(0);
}

export function playWhooshSound() {
  if (audioContext.state === 'suspended') audioContext.resume();
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  const now = audioContext.currentTime;
  oscillator.type = 'sawtooth';
  oscillator.frequency.setValueAtTime(800, now);
  oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.1);
  gainNode.gain.setValueAtTime(0.3, now);
  gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  oscillator.start(0);
  oscillator.stop(now + 0.1);
}

```
File: `demos/balloonpop/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>XR Blocks: Balloon Pop (v5.1 - Stable Fallback)</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../demo.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "@dimforge/rapier3d-simd-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-simd-compat@0.17.0",
          "xrblocks": "https://cdn.jsdelivr.net/gh/google/xrblocks@build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/gh/google/xrblocks@build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `demos/balloonpop/main.js`
```javascript
import * as xb from 'xrblocks';
import RAPIER from '@dimforge/rapier3d-simd-compat';
import 'xrblocks/addons/simulator/SimulatorAddons.js';
import {BalloonGame, GROUP_WORLD} from './BalloonPop.js';

document.addEventListener('DOMContentLoaded', () => {
  const o = new xb.Options();
  o.enableUI();
  o.physics.RAPIER = RAPIER;
  o.physics.useEventQueue = true;
  o.physics.worldStep = true;
  o.hands.enabled = true;
  o.simulator.defaultMode = xb.SimulatorMode.POSE;

  // START DISABLED to avoid Simulator Camera-Clone Crash
  o.depth.enabled = false;
  if (o.depth.depthMesh) {
    o.depth.depthMesh.enabled = true;
    o.depth.depthMesh.physicsEnabled = true;
    o.depth.depthMesh.collisionGroups = GROUP_WORLD;
    o.depth.depthMesh.colliderUpdateFps = 5;
  }

  xb.add(new BalloonGame());
  xb.init(o);
});

```


### Demo: ballpit
File: `demos/ballpit/BallPit.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';
import {palette} from 'xrblocks/addons/utils/Palette.js';

import {BallShooter} from './BallShooter.js';

const kTimeLiveMs = xb.getUrlParamInt('timeLiveMs', 3000);
const kDefalteMs = xb.getUrlParamInt('defalteMs', 200);
const kLightX = xb.getUrlParamFloat('lightX', 0);
const kLightY = xb.getUrlParamFloat('lightY', 500);
const kLightZ = xb.getUrlParamFloat('lightZ', -10);
const kRadius = xb.getUrlParamFloat('radius', 0.08);
const kBallsPerSecond = xb.getUrlParamFloat('ballsPerSecond', 30);
const kVelocityScale = xb.getUrlParamInt('velocityScale', 1.0);
const kNumSpheres = 100;

export class BallPit extends xb.Script {
  constructor() {
    super();
    this.ballShooter = new BallShooter({
      numBalls: kNumSpheres,
      radius: kRadius,
      palette: palette,
      liveDuration: kTimeLiveMs,
      deflateDuration: kDefalteMs,
    });
    this.add(this.ballShooter);
    this.addLights();

    this.lastBallCreatedTimeForController = new Map();
    this.pointer = new THREE.Vector2();
    this.velocity = new THREE.Vector3();
  }

  init() {
    xb.add(this);
  }

  update() {
    super.update();
    for (const controller of xb.core.input.controllers) {
      this.controllerUpdate(controller);
    }
  }

  // Adds hemisphere light for ambient lighting and directional light.
  addLights() {
    this.add(new THREE.HemisphereLight(0xbbbbbb, 0x888888, 3));
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(kLightX, kLightY, kLightZ);
    light.castShadow = true;
    light.shadow.mapSize.width = 2048; // Default is usually 1024
    light.shadow.mapSize.height = 2048; // Default is usually 1024
    this.add(light);
  }

  // Calculates pointer position in normalized device coordinates.
  updatePointerPosition(event) {
    // (-1 to +1) for both components
    this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // scale pointer.x from [-1, 0] to [-1, 1]
    this.pointer.x = 1 + 2 * this.pointer.x;
  }

  onPointerDown(event) {
    this.updatePointerPosition(event);
    const cameras = xb.core.renderer.xr.getCamera().cameras;
    if (cameras.length == 0) return;
    const camera = cameras[0];
    // Spawn a ball slightly in front of the camera.
    const position = new THREE.Vector3(0.0, 0.0, -0.2)
      .applyQuaternion(camera.quaternion)
      .add(camera.position);
    const matrix = new THREE.Matrix4();
    matrix.setPosition(position.x, position.y, position.z);
    // Convert pointer position to angle based on the camera.
    const vector = new THREE.Vector4(this.pointer.x, this.pointer.y, 1.0, 1);
    const inverseProjectionMatrix = camera.projectionMatrix.clone().invert();
    vector.applyMatrix4(inverseProjectionMatrix);
    vector.multiplyScalar(1 / vector.w);
    this.velocity.copy(vector);
    this.velocity.normalize().multiplyScalar(4.0);
    this.velocity.applyQuaternion(camera.quaternion);
    this.ballShooter.spawnBallAt(position, this.velocity);
  }

  controllerUpdate(controller) {
    const now = performance.now();
    if (!this.lastBallCreatedTimeForController.has(controller)) {
      this.lastBallCreatedTimeForController.set(controller, -99);
    }
    if (
      controller.userData.selected &&
      now - this.lastBallCreatedTimeForController.get(controller) >=
        1000 / kBallsPerSecond
    ) {
      // Place this 8 cm in front of the hands.
      const newPosition = new THREE.Vector3(0.0, 0.0, -0.08)
        .applyQuaternion(controller.quaternion)
        .add(controller.position);

      this.velocity.set(0, 0, -5.0 * kVelocityScale);
      this.velocity.applyQuaternion(controller.quaternion);

      this.ballShooter.spawnBallAt(newPosition, this.velocity);

      this.lastBallCreatedTimeForController.set(controller, now);
    }
  }
}

```
File: `demos/ballpit/BallShooter.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';

export class BallShooter extends xb.Script {
  constructor({
    numBalls = 100,
    radius = 0.08,
    palette = null,
    liveDuration = 3000,
    deflateDuration = 200,
    distanceThreshold = 0.25,
    distanceFadeout = 0.25,
  }) {
    super();
    this.liveDuration = liveDuration;
    this.deflateDuration = deflateDuration;
    this.distanceThreshold = distanceThreshold;
    this.distanceFadeout = distanceFadeout;
    const geometry = new THREE.IcosahedronGeometry(radius, 3);
    this.spheres = [];
    for (let i = 0; i < numBalls; ++i) {
      const material = new THREE.MeshLambertMaterial({transparent: true});
      const sphere = new THREE.Mesh(geometry, material);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      this.spheres.push(sphere);
    }

    const matrix = new THREE.Matrix4();
    for (let i = 0; i < this.spheres.length; i++) {
      const x = Math.random() * 2 - 2;
      const y = Math.random() * 2;
      const z = Math.random() * 2 - 2;

      matrix.setPosition(x, y, z);
      this.spheres[i].position.set(x, y, z);
      if (palette != null) {
        this.spheres[i].material.color.copy(palette.getRandomLiteGColor());
      }
    }

    const now = performance.now();
    this.spawnTimes = [];
    for (let i = 0; i < numBalls; ++i) {
      this.spawnTimes[i] = now;
    }

    this.nextBall = 0;
    this.rigidBodies = [];
    this.colliders = [];
    this.colliderHandleToIndex = new Map();
    this.viewSpacePosition = new THREE.Vector3();
    this.clipSpacePosition = new THREE.Vector3();
    this.projectedPosition = new THREE.Vector3();
    this.clipFromWorld = new THREE.Matrix4();
  }

  initPhysics(physics) {
    this.setupPhysics({
      RAPIER: physics.RAPIER,
      blendedWorld: physics.blendedWorld,
      colliderActiveEvents: physics.RAPIER.ActiveEvents.CONTACT_FORCE_EVENTS,
    });
  }

  setupPhysics({
    RAPIER,
    blendedWorld,
    colliderActiveEvents = 0,
    continuousCollisionDetection = false,
  }) {
    for (let i = 0; i < this.spheres.length; ++i) {
      const position = this.spheres[i].position;
      const desc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(...position)
        .setCcdEnabled(continuousCollisionDetection);
      const body = blendedWorld.createRigidBody(desc);
      const shape = RAPIER.ColliderDesc.ball(
        this.spheres[i].geometry.parameters.radius
      ).setActiveEvents(colliderActiveEvents);
      const collider = blendedWorld.createCollider(shape, body);
      this.colliderHandleToIndex.set(collider.handle, i);
      this.rigidBodies.push(body);
      this.colliders.push(collider);
    }
  }

  /**
   * Spawns a ball at the given location with the given velocity.
   * @param {THREE.Vector3} position Position to place the ball.
   * @param {THREE.Vector3} velocity Velocity of the ball.
   * @param {number} now Time when the ball is spawned.
   */
  spawnBallAt(
    position,
    velocity = new THREE.Vector3(),
    now = performance.now()
  ) {
    const ball = this.spheres[this.nextBall];
    ball.position.copy(position);
    ball.scale.setScalar(1.0);
    ball.opacity = 1.0;
    if (this.rigidBodies.length > 0) {
      const body = this.rigidBodies[this.nextBall];
      body.setTranslation(position);
      body.setLinvel(velocity);
    }
    this.spawnTimes[this.nextBall] = now;
    this.nextBall = (this.nextBall + 1) % this.spheres.length;
    this.add(ball);
  }

  physicsStep(now = performance.now()) {
    const camera = xb.core.camera;
    for (let i = 0; i < this.spheres.length; i++) {
      const sphere = this.spheres[i];
      const body = this.rigidBodies[i];
      let spawnTime = this.spawnTimes[i];

      if (this.isBallActive(i)) {
        let ballVisibility = 1.0;
        const position = sphere.position.copy(body.translation());
        // If the ball falls behind the depth then adjust the spawnTime to begin
        // expiring the ball.
        const viewSpacePosition = this.viewSpacePosition
          .copy(position)
          .applyMatrix4(camera.matrixWorldInverse);
        const clipSpacePosition = this.clipSpacePosition
          .copy(viewSpacePosition)
          .applyMatrix4(camera.projectionMatrix);
        const ballIsInView =
          -1.0 <= clipSpacePosition.x &&
          clipSpacePosition.x <= 1.0 &&
          -1.0 <= clipSpacePosition.y &&
          clipSpacePosition.y <= 1.0;
        if (ballIsInView && xb.depth.enabled) {
          const projectedPosition =
            xb.depth.getProjectedDepthViewPositionFromWorldPosition(
              position,
              this.projectedPosition
            );
          const distanceBehindDepth = Math.max(
            projectedPosition.z - viewSpacePosition.z,
            0.0
          );
          if (distanceBehindDepth > this.distanceThreshold) {
            const deflateAmount = Math.max(
              (distanceBehindDepth - this.distanceThreshold) /
                this.distanceFadeout,
              1.0
            );
            spawnTime = Math.min(
              spawnTime,
              now - this.liveDuration - this.deflateDuration * deflateAmount
            );
          }
        }

        // Compute the visibility if the ball has lived too long.
        if (now - spawnTime > this.liveDuration) {
          const timeSinceDeflateStarted = now - spawnTime - this.liveDuration;
          const deflateAmount = Math.min(
            1,
            timeSinceDeflateStarted / this.deflateDuration
          );
          ballVisibility = 1.0 - deflateAmount;
        }

        body.setTranslation(position);
        sphere.material.opacity = ballVisibility;

        if (ballVisibility < 0.001) {
          sphere.material.opacity = 0.0;
          sphere.scale.setScalar(0);
          position.set(0.0, -1000.0, 0.0);
          body.setTranslation(position);
          this.removeBall(i);
        }
      }

      sphere.position.copy(body.translation());
      sphere.quaternion.copy(body.rotation());
    }
  }

  getIndexForColliderHandle(handle) {
    return this.colliderHandleToIndex.get(handle);
  }

  removeBall(index) {
    const ball = this.spheres[index];
    const body = this.rigidBodies[index];
    ball.position.set(0.0, -1000.0, 0.0);
    body.setTranslation(ball.position);
    this.remove(ball);
  }

  isBallActive(index) {
    return this.spheres[index].parent == this;
  }
}

```
File: `demos/ballpit/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Ballpit</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../demo.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "@dimforge/rapier3d-simd-compat": "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-simd-compat@0.19.2/rapier.mjs",
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <div
      class="background-image"
      style="background-image: url('textures/background.webp')"
    ></div>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `demos/ballpit/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import RAPIER from '@dimforge/rapier3d-simd-compat';
import * as xb from 'xrblocks';

import {BallPit} from './BallPit.js';

const depthMeshColliderUpdateFps = xb.getUrlParamFloat(
  'depthMeshColliderUpdateFps',
  5
);

const useSceneMesh = xb.getUrlParamBool('scenemesh', false);

const options = new xb.Options();
if (useSceneMesh) {
  options.world.enableMeshDetection();
} else {
  options.depth = new xb.DepthOptions(xb.xrDepthMeshPhysicsOptions);
  options.depth.depthMesh.colliderUpdateFps = depthMeshColliderUpdateFps;
}
options.xrButton = {
  ...options.xrButton,
  startText: '<i id="xrlogo"></i> LET THE FUN BEGIN',
  endText: '<i id="xrlogo"></i> MISSION COMPLETE',
};
options.physics.RAPIER = RAPIER;

// Initializes the scene, camera, xrRenderer, controls, and XR button.
async function start() {
  xb.add(new BallPit());
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Demo: gemini-icebreakers
File: `demos/gemini-icebreakers/EarthAnimation.js`
```javascript
/**
 * Animates the earth model.
 */
export class EarthAnimation {
  model = null;
  speed = 0.2;

  setModel(model) {
    this.model = model;
  }

  update(deltaTime) {
    const gltfScene = this?.model?.gltf?.scene;
    if (gltfScene) {
      gltfScene.rotation.y += this.speed * deltaTime;
    }
  }
}

```
File: `demos/gemini-icebreakers/GeminiIcebreakers.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';

import {EarthAnimation} from './EarthAnimation.js';
import {TranscriptionManager} from './TranscriptionManager.js';

const ASSETS_BASE_URL = 'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/';
const PROPRIETARY_ASSETS_BASE_URL =
  'https://cdn.jsdelivr.net/gh/xrblocks/proprietary-assets@main/';

const DATA = [
  {
    model: {
      scale: {x: 4.0, y: 4.0, z: 4.0},
      path: PROPRIETARY_ASSETS_BASE_URL + 'monalisa/',
      model: 'mona_lisa_picture_frame_compressed.glb',
      verticallyAlignObject: false,
    },
    prompt: '‚ÄúWhat is she smiling about?‚Äù',
  },
  {
    model: {
      scale: {x: 0.03, y: 0.03, z: 0.03},
      rotation: {x: 80, y: 0, z: 0},
      position: {x: 0, y: -0.2, z: -3.0},
      path: PROPRIETARY_ASSETS_BASE_URL + 'chess/',
      model: 'chess_compressed.glb',
      verticallyAlignObject: false,
    },
    prompt: "‚ÄúWhat's a good strategy for this game?‚Äù",
  },
  {
    model: {
      scale: {x: 0.9, y: 0.9, z: 0.9},
      rotation: {x: 75, y: 0, z: 0},
      position: {x: 0, y: 0.0, z: 0},
      path: PROPRIETARY_ASSETS_BASE_URL + 'vegetable_on_board/',
      model: 'vegetable_on_board_compressed.glb',
      verticallyAlignObject: false,
    },
    prompt:
      '‚ÄúWhat is the most unexpected dish you could make with these ingredients?‚Äù',
  },
  {
    model: {
      path: ASSETS_BASE_URL + 'models/',
      model: 'Parasaurolophus.glb',
      scale: {x: 0.3, y: 0.3, z: 0.3},
      position: {x: 0, y: -0.6, z: 0},
      verticallyAlignObject: false,
      horizontallyAlignObject: false,
    },
    prompt: '‚ÄúIf this dinosaur could talk, what would it say?‚Äù',
  },
  {
    model: {
      path: PROPRIETARY_ASSETS_BASE_URL + 'earth/',
      model: 'Earth_1_12756.glb',
      scale: {x: 0.001, y: 0.001, z: 0.001},
      position: {x: 0, y: 0, z: 0},
      verticallyAlignObject: false,
    },
    modelAnimation: new EarthAnimation(),
    prompt: '‚ÄúHow big would I need to be to hold this in my hands?‚Äù',
  },
];

export class GeminiIcebreakers extends xb.Script {
  constructor() {
    super();

    // Loads data.
    this.data = DATA;
    this.journeyId = 0;
    this.models = [];
    this.isAIRunning = false;
    this.screenshotInterval = null;
    this.time = 0;
    this.micButtonInitialY = null;
    this.transcriptionManager = null;

    // Initializes UI.
    const panel = new xb.SpatialPanel({
      backgroundColor: '#00000000',
      useDefaultPosition: false,
      showEdge: false,
    });
    this.add(panel);

    this.descriptionPagerState = new xb.PagerState({pages: DATA.length});
    console.log('pages:', this.descriptionPagerState.pages);
    const grid = panel.addGrid();

    const imageRow = grid.addRow({weight: 0.5});
    imageRow.addCol({weight: 0.1});
    this.imagePager = new xb.HorizontalPager({
      state: this.descriptionPagerState,
    });
    imageRow.addCol({weight: 0.8}).add(this.imagePager);
    imageRow.addCol({weight: 0.1});
    for (let i = 0; i < DATA.length; i++) {
      if (DATA[i].src) {
        this.imagePager.children[i].addImage({src: DATA[i].src});
      } else {
        this.imagePager.children[i].add(new xb.View());
      }
    }

    grid.addRow({weight: 0.15});
    const controlRow = grid.addRow({weight: 0.35});

    const ctrlPanel = controlRow.addPanel({backgroundColor: '#000000D9'});

    const ctrlGrid = ctrlPanel.addGrid();
    {
      const leftColumn = ctrlGrid.addCol({weight: 0.1});
      this.backButton = leftColumn.addIconButton({
        text: 'arrow_back',
        fontSize: 0.5,
        paddingX: 0.2,
      });

      const midColumn = ctrlGrid.addCol({weight: 0.8});
      const descRow = midColumn.addRow({weight: 0.8});
      this.descRow = descRow;

      // TODO: use phong and point light to highlight gemini.
      this.add(this.descriptionPagerState);
      this.descriptionPager = new xb.HorizontalPager({
        state: this.descriptionPagerState,
        enableRaycastOnChildren: false,
      });
      descRow.add(this.descriptionPager);
      this.transcriptView = new xb.ScrollingTroikaTextView({
        text: '',
        fontSize: 0.05,
        textAlign: 'left',
      });
      for (let i = 0; i < DATA.length; i++) {
        this.descriptionPager.children[i].add(
          new xb.TextView({
            text: this.data[i].prompt,
            fontColor: '#ffffff',
            imageOverlay: 'images/gradient.png',
            /** This modifier makes the gradient more towards purple. */
            imageOffsetX: 0.2,
          })
        );
      }

      const botRow = midColumn.addRow({weight: 0.1});

      botRow.add(
        new xb.PageIndicator({
          pagerState: this.descriptionPager.state,
          fontColor: '#FFFFFF',
        })
      );

      const rightColumn = ctrlGrid.addCol({weight: 0.1});

      this.forwardButton = rightColumn.addIconButton({
        text: 'arrow_forward',
        fontSize: 0.5,
        paddingX: -0.2,
      });

      this.micButton = ctrlGrid.addCol({weight: 0.1}).addIconButton({
        text: 'mic',
        fontSize: 0.8,
        paddingX: -2,
        paddingY: -1,
        fontColor: '#fdfdfdff',
      });
      this.micButton.onTriggered = () => {
        this.toggleGeminiLive();
      };
    }

    const orbiter = ctrlGrid.addOrbiter();
    orbiter.addExitButton();

    panel.updateLayouts();

    this.panel = panel;

    // TODO(M): This is a bad design, onSelect is triggered twice
    // when user pinches.
    this.backButton.onTriggered = (id) => {
      console.log('back button');
      this.loadPrevious();
    };

    this.forwardButton.onTriggered = (id) => {
      console.log('forward button');
      this.loadNext();
    };
  }

  /**
   * Initializes the script.
   */
  init() {
    this.loadModels();
    xb.core.renderer.localClippingEnabled = true;

    this.add(new THREE.HemisphereLight(0x888877, 0x777788, 3));
    const light = new THREE.DirectionalLight(0xffffff, 5.0);
    light.position.set(-0.5, 4, 1.0);
    this.add(light);

    this.panel.position.set(0, 1.2, -1.0);

    if (!xb.core.ai || !xb.core.ai.options.gemini.apiKey) {
      this.micButton.visible = false;
    }
  }

  reload() {
    const roundedCurrentPage = Math.round(
      this.descriptionPagerState.currentPage
    );
    if (roundedCurrentPage != this.journeyId) {
      this.descriptionPagerState.currentPage = this.journeyId;
    }
  }

  loadPrevious() {
    this.journeyId = (this.journeyId - 1 + this.data.length) % this.data.length;
    this.reload();
  }

  loadNext() {
    this.journeyId = (this.journeyId + 1 + this.data.length) % this.data.length;
    this.reload();
  }

  update() {
    const deltaTime = xb.getDeltaTime();
    this.time += deltaTime;

    if (this.micButtonInitialY === null && this.micButton.visible) {
      this.micButtonInitialY = this.micButton.position.y;
    }

    const roundedCurrentPage = Math.round(
      this.descriptionPagerState.currentPage
    );
    if (this.journeyId != roundedCurrentPage) {
      this.journeyId = roundedCurrentPage;
      this.reload();
    }

    for (const model of this.data) {
      model.modelAnimation?.update(deltaTime);
    }

    if (
      this.micButtonInitialY !== null &&
      this.micButton.visible &&
      this.isAIRunning
    ) {
      const jumpHeight = 0.05;
      const jumpSpeed = 4;
      this.micButton.position.y =
        this.micButtonInitialY +
        Math.abs(Math.sin(this.time * jumpSpeed)) * jumpHeight;
    } else if (this.micButtonInitialY !== null) {
      this.micButton.position.y = this.micButtonInitialY;
    }
  }

  loadModels() {
    for (let i = 0; i < this.data.length; i++) {
      if (this.data[i].model) {
        const data = this.data[i];
        const model = new xb.ModelViewer({});
        model.loadGLTFModel({
          data: this.data[i].model,
          setupPlatform: false,
          setupRaycastCylinder: false,
          setupRaycastBox: true,
          renderer: xb.core.renderer,
          onSceneLoaded: () => {
            this.reload();
            this.imagePager.children[i].children[0].add(model);
            data.modelAnimation?.setModel(model);
          },
        });
        this.models[i] = model;
      }
    }
  }

  async toggleGeminiLive() {
    return this.isAIRunning ? this.stopGeminiLive() : this.startGeminiLive();
  }

  async startGeminiLive() {
    if (this.isAIRunning) return;
    try {
      this.descriptionPager.visible = false;
      this.descRow.add(this.transcriptView);
      this.transcriptView.visible = true;
      this.transcriptionManager = new TranscriptionManager(this.transcriptView);
      await xb.core.sound.enableAudio();
      await this.startLiveAI();
      this.startScreenshotCapture();
      this.isAIRunning = true;
    } catch (error) {
      console.error('Failed to start AI session:', error);
      this.cleanup();
      this.isAIRunning = false;
    }
  }

  async stopGeminiLive() {
    if (this.transcriptionManager) {
      this.transcriptionManager.clear();
    }
    if (!this.isAIRunning) return;
    this.descriptionPager.state.currentPage = this.journeyId;
    this.descriptionPager.visible = true;
    this.transcriptView.visible = false;
    await xb.core.ai?.stopLiveSession?.();
    this.cleanup();
    if (this.screenshotInterval) {
      clearInterval(this.screenshotInterval);
      this.screenshotInterval = null;
    }
  }

  async startLiveAI() {
    return new Promise((resolve, reject) => {
      xb.core.ai.setLiveCallbacks({
        onopen: resolve,
        onmessage: (message) => this.handleAIMessage(message),
        onerror: reject,
        onclose: (closeEvent) => {
          this.cleanup();
          this.isAIRunning = false;
        },
      });
      xb.core.ai.startLiveSession().catch(reject);
    });
  }

  handleAIMessage(message) {
    message.data && xb.core.sound.playAIAudio(message.data);

    const content = message.serverContent;
    if (content) {
      content.inputTranscription?.text &&
        this.transcriptionManager.handleInputTranscription(
          content.inputTranscription.text
        );
      content.outputTranscription?.text &&
        this.transcriptionManager.handleOutputTranscription(
          content.outputTranscription.text
        );
      content.turnComplete && this.transcriptionManager.finalizeTurn();
    }
  }

  cleanup() {
    this.isAIRunning = false;
  }

  startScreenshotCapture() {
    this.screenshotInterval = setInterval(async () => {
      const base64Image = await xb.core.screenshotSynthesizer.getScreenshot();
      if (base64Image) {
        const base64Data = base64Image.startsWith('data:')
          ? base64Image.split(',')[1]
          : base64Image;
        try {
          xb.core.ai?.sendRealtimeInput?.({
            video: {data: base64Data, mimeType: 'image/png'},
          });
        } catch (error) {
          console.warn(error);
          this.stopGeminiLive();
        }
      }
    }, 1000);
  }
}

```
File: `demos/gemini-icebreakers/TranscriptionManager.js`
```javascript
export class TranscriptionManager {
  constructor(responseDisplay) {
    this.responseDisplay = responseDisplay;
    this.currentInputText = '';
    this.currentOutputText = '';
    this.conversationHistory = [];
  }

  handleInputTranscription(text) {
    if (!text) return;
    this.currentInputText += text;
    this.updateLiveDisplay();
  }

  handleOutputTranscription(text) {
    if (!text) return;
    this.currentOutputText += text;
    this.updateLiveDisplay();
  }

  finalizeTurn() {
    if (this.currentInputText.trim()) {
      this.conversationHistory.push({
        speaker: 'You',
        text: this.currentInputText.trim(),
      });
    }
    if (this.currentOutputText.trim()) {
      this.conversationHistory.push({
        speaker: 'AI',
        text: this.currentOutputText.trim(),
      });
    }
    this.currentInputText = '';
    this.currentOutputText = '';
    this.updateFinalDisplay();
  }

  updateLiveDisplay() {
    let displayText = '';
    for (const entry of this.conversationHistory.slice(-2)) {
      displayText += `${entry.speaker}: ${entry.text}\n\n`;
    }
    if (this.currentInputText.trim()) {
      displayText += `You: ${this.currentInputText}`;
    }
    if (this.currentOutputText.trim()) {
      if (this.currentInputText.trim()) displayText += '\n\n';
      displayText += `AI: ${this.currentOutputText}`;
    }
    this.responseDisplay?.setText(displayText);
  }

  updateFinalDisplay() {
    let displayText = '';
    for (const entry of this.conversationHistory) {
      displayText += `${entry.speaker}: ${entry.text}\n\n`;
    }
    this.responseDisplay?.setText(displayText);
  }

  clear() {
    this.currentInputText = '';
    this.currentOutputText = '';
    this.conversationHistory = [];
  }

  addText(text) {
    this.responseDisplay?.addText(text + '\n\n');
  }

  setText(text) {
    this.responseDisplay?.setText(text);
  }
}

```
File: `demos/gemini-icebreakers/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Gemini Icebreakers</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../demo.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <div
      id="background-image"
      class="background-image"
      style="background-image: url('textures/background.webp')"
    ></div>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `demos/gemini-icebreakers/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {GeminiIcebreakers} from './GeminiIcebreakers.js';

const options = new xb.Options({
  antialias: true,
  reticles: {enabled: true},
  visualizeRays: true,
});
options.enableAI();
options.enableCamera();

async function start() {
  xb.add(new GeminiIcebreakers());
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```
File: `demos/gemini-icebreakers/materials/LinearGradientMaterial.js`
```javascript
import * as THREE from 'three';

export class LinearGradientMaterial extends THREE.ShaderMaterial {
  constructor() {
    const options = {
      uniforms: {
        time: {value: 1.0},
        resolution: {value: new THREE.Vector2()},
      },
      vertexShader: /* glsl */ `
      varying vec2 vTexCoord;

      void main() {
        vTexCoord = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    `,
      fragmentShader: /* glsl */ `
      precision mediump float;

      varying vec2 vTexCoord;

      void main() {
        // --- Constants ---
        const vec4 startColor = vec4(0.125,0.486,1.000, 1.0);
        const vec4 quarterColor = vec4(0.035,0.557,0.984, 1.0);
        const vec4 thirdQuarterColor = vec4(0.678,0.529,0.922, 1.0);
        const vec4 endColor = vec4(0.933,0.302,0.369, 1.0);
        const float angle = radians(90.0 + 16.0);
        const vec2 origin = vec2(0.5, 0.5);

        // --- Pre-calculate rotation components ---
        float rotation = radians(90.0) - angle;
        float cosRot = cos(rotation);
        float sinRot = sin(rotation);

        // --- Normalized and centered UV ---
        vec2 uv = vTexCoord - origin;

        // --- Rotate the UV coordinates ---
        vec2 rotatedUV = vec2(
            cosRot * uv.x - sinRot * uv.y,
            sinRot * uv.x + cosRot * uv.y
        ) + origin;

        // --- Original color mixing logic based on rotatedUV.x ---
        if (rotatedUV.x < 0.5) {
          gl_FragColor = mix(startColor, quarterColor, smoothstep(0.0, 0.25, rotatedUV.x));
        } else if (rotatedUV.x < 0.75) {
          gl_FragColor = mix(quarterColor, thirdQuarterColor, smoothstep(0.5, 0.75, rotatedUV.x));
        } else {
          gl_FragColor = mix(thirdQuarterColor, endColor, smoothstep(0.75, 1.0, rotatedUV.x));
        }
      }`,
    };
    super(options);
  }
}

```


### Demo: occlusion
File: `demos/occlusion/DepthMeshClone.js`
```javascript
import * as THREE from 'three';
import {xrDepthMeshOptions} from 'xrblocks';

export class DepthMeshClone extends THREE.Mesh {
  constructor() {
    super(
      new THREE.PlaneGeometry(),
      new THREE.ShadowMaterial({
        opacity: xrDepthMeshOptions.depthMesh.shadowOpacity,
        depthWrite: false,
      })
    );
    this.receiveShadow = true;
  }

  cloneDepthMesh(depthMesh) {
    this.geometry.dispose();
    this.geometry = depthMesh.geometry.clone();
    depthMesh.getWorldPosition(this.position);
    depthMesh.getWorldQuaternion(this.quaternion);
    depthMesh.getWorldScale(this.scale);
  }
}

```
File: `demos/occlusion/OcclusionScene.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';
import {ModelManager} from 'xrblocks/addons/ui/ModelManager.js';

import {ANIMALS_DATA} from './animals_data.js';
import {DepthMeshClone} from './DepthMeshClone.js';

const kLightX = xb.getUrlParamFloat('lightX', 0);
const kLightY = xb.getUrlParamFloat('lightY', 500);
const kLightZ = xb.getUrlParamFloat('lightZ', -10);

export class OcclusionScene extends xb.Script {
  constructor() {
    super();
    this.pointer = new THREE.Vector3();
    this.depthMeshClone = new DepthMeshClone();
    this.raycaster = new THREE.Raycaster();
    this.modelManager = new ModelManager(
      ANIMALS_DATA,
      /*enableOcclusion=*/ true
    );
    this.modelManager.layers.enable(xb.OCCLUDABLE_ITEMS_LAYER);
    this.add(this.modelManager);
    this.instructionText =
      'Pinch on the environment and try hiding the cat behind sofa!';
    this.instructionCol = null;
  }

  init() {
    this.addLights();
    xb.showReticleOnDepthMesh(true);
    this.addPanel();
  }

  addPanel() {
    const panel = new xb.SpatialPanel({
      backgroundColor: '#00000000',
      useDefaultPosition: false,
      showEdge: false,
    });
    panel.position.set(0, 1.6, -1.0);
    panel.isRoot = true;
    this.add(panel);

    const grid = panel.addGrid();
    grid.addRow({weight: 0.05});
    // Space for orbiter
    grid.addRow({weight: 0.1});

    const controlRow = grid.addRow({weight: 0.3});
    const ctrlPanel = controlRow.addPanel({backgroundColor: '#000000bb'});
    const ctrlGrid = ctrlPanel.addGrid();

    const midColumn = ctrlGrid.addCol({weight: 0.9});
    midColumn.addRow({weight: 0.3});
    const gesturesRow = midColumn.addRow({weight: 0.4});
    gesturesRow.addCol({weight: 0.05});

    const textCol = gesturesRow.addCol({weight: 1.0});
    this.instructionCol = textCol.addRow({weight: 1.0}).addText({
      text: `${this.instructionText}`,
      fontColor: '#ffffff',
      fontSize: 0.05,
    });

    gesturesRow.addCol({weight: 0.01});
    midColumn.addRow({weight: 0.1});

    const orbiter = ctrlGrid.addOrbiter();
    orbiter.addExitButton();

    panel.updateLayouts();

    this.panel = panel;
    this.frameId = 0;
  }

  onSimulatorStarted() {
    this.instructionText =
      'Click on the environment and try hiding the cat behind sofa!';
    if (this.instructionCol) {
      this.instructionCol.setText(this.instructionText);
    }
  }

  addLights() {
    this.add(new THREE.HemisphereLight(0xbbbbbb, 0x888888, 3));
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(kLightX, kLightY, kLightZ);
    light.castShadow = true;
    light.shadow.mapSize.width = 2048; // Default is usually 1024
    light.shadow.mapSize.height = 2048; // Default is usually 1024
    this.add(light);
  }

  updatePointerPosition(event) {
    // (-1 to +1) for both components
    this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // scale pointer.x from [-1, 0] to [-1, 1]
    this.pointer.x = 1 + 2 * this.pointer.x;
  }

  onSelectStart(event) {
    const controller = event.target;
    if (xb.core.input.intersectionsForController.get(controller).length > 0) {
      const intersection =
        xb.core.input.intersectionsForController.get(controller)[0];
      if (intersection.handleSelectRaycast) {
        intersection.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object.handleSelectRaycast) {
        intersection.object.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object == xb.core.depth.depthMesh) {
        this.onDepthMeshSelectStart(intersection);
        return;
      }
    }
  }

  onDepthMeshSelectStart(intersection) {
    this.modelManager.positionModelAtIntersection(intersection, xb.core.camera);
  }

  onPointerDown(event) {
    this.updatePointerPosition(event);
    const cameras = xb.core.renderer.xr.getCamera().cameras;
    if (cameras.length == 0) return;
    const camera = cameras[0];
    this.raycaster.setFromCamera(this.pointer, camera);
    const intersections = this.raycaster.intersectObjects(
      xb.core.input.reticleTargets
    );
    for (let intersection of intersections) {
      if (intersection.handleSelectRaycast) {
        intersection.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object.handleSelectRaycast) {
        intersection.object.handleSelectRaycast(intersection);
        return;
      } else if (intersection.object == xb.core.depth.depthMesh) {
        this.modelManager.positionModelAtIntersection(intersection, camera);
        return;
      }
    }
  }
}

```
File: `demos/occlusion/animals_data.js`
```javascript
export const ANIMALS_DATA = [
  {
    path: 'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/',
    model: 'models/Cat/cat.gltf',
    thumbnail: 'thumbnail.png',
  },
];

```
File: `demos/occlusion/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Occlusion</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../demo.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "@material/web/": "https://esm.run/@material/web/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
    <script type="module">
      import '@material/web/all.js';
      import {styles as typescaleStyles} from '@material/web/typography/md-typescale-styles.js';

      document.adoptedStyleSheets.push(typescaleStyles.styleSheet);
    </script>
  </head>

  <body>
    <div
      class="background-image"
      style="background-image: url('textures/background.webp')"
    ></div>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `demos/occlusion/main.js`
```javascript
import * as xb from 'xrblocks';

import {OcclusionScene} from './OcclusionScene.js';

const options = new xb.Options();
options.reticles.enabled = true;
options.depth = new xb.DepthOptions(xb.xrDepthMeshOptions);
options.depth.depthMesh.updateFullResolutionGeometry = true;
options.depth.depthMesh.renderShadow = true;
options.depth.depthTexture.enabled = true;
options.depth.occlusion.enabled = true;
options.xrButton.startText = '<i id="xrlogo"></i> BRING IT TO LIFE';
options.xrButton.endText = '<i id="xrlogo"></i> MISSION COMPLETE';

async function start() {
  const occlusion = new OcclusionScene();
  await xb.init(options);
  xb.add(occlusion);

  window.addEventListener(
    'pointerdown',
    occlusion.onPointerDown.bind(occlusion)
  );
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Demo: rain
File: `demos/rain/RainParticles.js`
```javascript
import * as THREE from 'three';

const kMaxAnimationFrames = 15;
const kAnimationSpeed = 2.0;
const DEBUG_SINGLE = false;
// const DEBUG_SINGLE = true;

function clamp(x, a, b) {
  return Math.min(Math.max(x, a), b);
}

export class RainParticles extends THREE.Object3D {
  constructor() {
    super();
    // Sets the number of particles and defines the range of the raindrop
    // effect.
    this.particleCount = DEBUG_SINGLE ? 1 : 200;
    this.RANGE = 4;
    this.raycaster = new THREE.Raycaster();

    // Initializes arrays for fall speeds, animation weights, and visibility
    // states of each particle.
    this.velocities = new Float32Array(this.particleCount);
    this.particleWeights = new Float32Array(this.particleCount);
    this.particleVisibility = new Float32Array(this.particleCount);

    // Placeholder for the InstancedMesh representing the raindrop particles.
    this.raindropMesh = null;
  }

  /**
   * Initializes raindrop particles with a shader material and instanced
   * geometry. Loads the texture and sets up the particle mesh and instanced
   * attributes.
   */
  init() {
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load('textures/rain_sprite_sheet.png', (raindropTexture) => {
      // Creates a custom shader material for the raindrop particles.
      const raindropMaterial = this.createRaindropMaterial(raindropTexture);

      // Creates a simple plane geometry for each raindrop particle.
      const raindropGeometry = new THREE.PlaneGeometry(0.1, 0.1);

      // Initializes an InstancedMesh with the defined geometry and material.
      this.raindropMesh = new THREE.InstancedMesh(
        raindropGeometry,
        raindropMaterial,
        this.particleCount
      );

      // Populates the particle mesh with initial positions and properties.
      this.initializeParticles();

      // Adds instanced attributes for weight and visibility to control raindrop
      // animation and rendering.
      this.raindropMesh.geometry.setAttribute(
        'aWeight',
        new THREE.InstancedBufferAttribute(this.particleWeights, 1).setUsage(
          THREE.DynamicDrawUsage
        )
      );
      this.raindropMesh.geometry.setAttribute(
        'aVisibility',
        new THREE.InstancedBufferAttribute(this.particleVisibility, 1).setUsage(
          THREE.DynamicDrawUsage
        )
      );

      // Flags the instance matrix for an initial update and adds the raindrop
      // mesh to the scene.
      this.raindropMesh.instanceMatrix.needsUpdate = true;
      this.add(this.raindropMesh);
    });
  }

  /**
   * Creates and returns a custom shader material for the raindrop particles.
   * Uses a texture and sets up uniforms for the camera position to handle
   * billboard rotation.
   */
  createRaindropMaterial(texture) {
    return new THREE.ShaderMaterial({
      uniforms: {
        uTexture: {value: texture},
        uCameraPosition: {value: new THREE.Vector3()},
        uCameraRotationMatrix: {value: new THREE.Matrix4()},
      },
      vertexShader: `
        attribute float aWeight;
        attribute float aVisibility;
        varying float vWeight;
        varying float vVisibility;
        varying vec2 vUv;
        uniform vec3 uCameraPosition;
        uniform mat4 uCameraRotationMatrix;

        const float PI = 3.14159265359;


        void main() {
          vUv = uv;
          vWeight = aWeight;
          vVisibility = aVisibility;

          // Get the world position of the instance
          vec4 worldPosition = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);

          vec3 rotatedPosition;

          if (vWeight < 1.5) {
            // Compute vector from particle to camera, projected onto XZ plane
            vec3 toCamera = uCameraPosition - worldPosition.xyz;
            toCamera.y = 0.0; // Ignore vertical component
            toCamera = normalize(toCamera);

            // Compute the angle to rotate around Y-axis
            float angle = atan(toCamera.x, toCamera.z);

            // Create rotation matrix around Y-axis
            mat3 rotationMatrix = mat3(
              cos(angle), 0.0, -sin(angle),
              0.0,        1.0,  0.0,
              sin(angle), 0.0,  cos(angle)
            );

            // Apply rotation to vertex position
            rotatedPosition = rotationMatrix * position;
          } else {
            // Rotate the particle to face positive Y-axis
            // This is a rotation of -90 degrees around X-axis
            float angle = 0.5 * PI; // -90 degrees in radians

            // Create rotation matrix around X-axis
            mat3 rotationMatrix = mat3(
              1.0,       0.0,        0.0,
              0.0, cos(angle), -sin(angle),
              0.0, sin(angle),  cos(angle)
            );

            // Apply rotation to vertex position
            rotatedPosition = rotationMatrix * position;
          }

          // Apply instance transformations
          vec4 finalPosition = instanceMatrix * vec4(rotatedPosition, 1.0);

          // Transform to clip space
          gl_Position = projectionMatrix * viewMatrix * finalPosition;
        }

      `,
      fragmentShader: `
        uniform sampler2D uTexture;
        varying vec2 vUv;
        varying float vWeight;
        varying float vVisibility;

        void main() {
          const float kAnimationSpeed = 2.0;
          vec2 uv = vUv * 0.25;  // Assumes a 4x4 texture grid.
          float frame = floor(vWeight / kAnimationSpeed);
          float xIndex = mod(frame, 4.0);
          float yIndex = floor(frame / 4.0);
          uv += vec2(xIndex, 3.0 - yIndex) * 0.25;  // Maps frame index to UV coordinates.
          vec4 texColor = texture2D(uTexture, uv);
          gl_FragColor = vec4(pow(texColor.rgb, vec3(0.5)), texColor.a * vVisibility * 0.8 - step(vWeight, 0.5) * 0.2);  // Applies visibility factor.
          // gl_FragColor = vec4(0.5, 0.5, 0.0, 1.0);  // Applies visibility factor.
        }
      `,
      transparent: true,
      // side: THREE.DoubleSide,
    });
  }

  /**
   * Initializes the positions and properties for each particle.
   * Assigns random positions, fall speeds, and visibility states to each
   * particle instance.
   */
  initializeParticles() {
    const dummy = new THREE.Object3D();
    for (let i = 0; i < this.particleCount; i++) {
      // Assigns random initial position within the defined range.
      dummy.position.set(
        Math.random() * this.RANGE * 2 - this.RANGE,
        Math.random() * this.RANGE * 2,
        Math.random() * this.RANGE * 2 - this.RANGE
      );

      if (DEBUG_SINGLE) {
        dummy.position.set(0, 1.2, -1);
      }

      // Updates the instance matrix with the dummy object's position.
      dummy.updateMatrix();
      this.raindropMesh.setMatrixAt(i, dummy.matrix);

      // Sets random fall speed and initial visibility for each particle.
      this.velocities[i] = Math.random() * 0.05 + 0.2;
      // this.velocities[i] = 0.1;
      this.particleWeights[i] = 0;
      this.particleVisibility[i] = 1;
    }
  }

  /**
   * Updates particle positions and visibility on each frame.
   * Adjusts particle weights, visibility, and repositions particles as they
   * "fall."
   */
  update(camera, xrDepth) {
    if (!this.raindropMesh) return;
    const depthMesh = xrDepth.depthMesh;

    const dummy = new THREE.Object3D();
    const particleWeightsAttribute =
      this.raindropMesh.geometry.attributes.aWeight;
    const particleVisibilityAttribute =
      this.raindropMesh.geometry.attributes.aVisibility;
    // const nextDummy = new THREE.Object3D();

    // Compute the camera's rotation excluding Y-axis rotation (yaw)
    const cameraEuler = new THREE.Euler().setFromQuaternion(
      camera.quaternion,
      'YXZ'
    );
    const cameraEulerNoYaw = new THREE.Euler(
      cameraEuler.x, // pitch
      0, // yaw
      cameraEuler.z, // roll
      'YXZ'
    );
    const cameraRotationMatrix = new THREE.Matrix4().makeRotationFromEuler(
      cameraEulerNoYaw
    );
    const inverseCameraRotationMatrix = cameraRotationMatrix.clone().invert();

    // Update the uniform with the inverse rotation matrix
    this.raindropMesh.material.uniforms.uCameraRotationMatrix.value.copy(
      inverseCameraRotationMatrix
    );

    for (let i = 0; i < this.raindropMesh.count; ++i) {
      // Gets the current transformation matrix of the particle instance.
      this.raindropMesh.getMatrixAt(i, dummy.matrix);
      dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

      // Proceeds the raindrop.
      if (this.particleWeights[i] < 0.5) {
        dummy.position.y -= this.velocities[i];
      }

      // Computes screen position and depth for visibility checks.
      const screenPos = dummy.position.clone().project(camera);

      // Check if the point is within the visible NDC range.
      // const isWithinFoV = screenPos.x >= -1 && screenPos.x <= 1 &&
      //     screenPos.y >= -1 && screenPos.y <= 1 && screenPos.z >= 0 &&
      //     screenPos.z <= 1;

      const isWithinFoV =
        screenPos.x >= -0.8 &&
        screenPos.x <= 0.6 &&
        screenPos.y >= -1.0 &&
        screenPos.y <= 1.0 &&
        screenPos.z >= 0 &&
        screenPos.z <= 1;

      let isOccluded = false;
      let maxVisibility = 1.0;
      let deltaDepth = 0.0;

      const isHigh = dummy.position.y > 2.0;

      if (isWithinFoV) {
        const depth = xrDepth.getDepth(
          (screenPos.x + 1) / 2,
          (screenPos.y + 1) / 2
        );

        // Transform the point to camera space.
        const pointInCameraSpace = dummy.position
          .clone()
          .applyMatrix4(camera.matrixWorldInverse);

        // The z-coordinate in camera space is the perpendicular distance to the
        // camera plane
        const distanceToCameraPlane = -pointInCameraSpace.z;

        isOccluded = depth == 0 || depth < distanceToCameraPlane;
        deltaDepth = Math.abs(distanceToCameraPlane - depth);
        // console.log(
        //     'occluded: ' + isOccluded, 'isWithinFoV: ' + isWithinFoV, depth,
        //     distanceToCameraPlane);

        if (
          this.particleWeights[i] == 0 &&
          this.particleVisibility[i] > 0.5 &&
          isOccluded &&
          !isHigh
        ) {
          this.particleWeights[i] = 1;

          if (depth < 0.3) {
            // maxVisibility *= 0.2 + depth;
            maxVisibility = 0.0;
          } else if (depth > 2.0) {
            maxVisibility *= 0.5 + (4.0 - depth) / 4.0;
          }
          // console.log('hit ', dummy.position.y, depth,
          // distanceToCameraPlane);
        }
      }

      if (isWithinFoV) {
        // console.log(
        //     depth, distanceToCameraPlane, pointInCameraSpace.z,
        //     dummy.position);

        this.particleVisibility[i] =
          isOccluded && !isHigh
            ? clamp(0.6 - deltaDepth, 0.0, 0.6)
            : maxVisibility;
      } else {
        this.particleVisibility[i] = 0.0;
      }

      // Hits the floor.
      if (dummy.position.y < 0) {
        dummy.position.y = 0;
        if (this.particleWeights[i] < 0.5) {
          this.particleWeights[i] = 1;
        }

        this.particleVisibility[i] =
          isOccluded && !isHigh ? 0.0 : maxVisibility;
      }

      if (this.particleWeights[i] > 0) {
        this.particleWeights[i] += 1;
      }

      // Global minimum test.
      if (depthMesh.minDepth < 0.1) {
        this.particleVisibility[i] = 0.0;
      }

      // this.particleVisibility[i] = 1.0;

      // if (this.particleVisibility[i] > 0.5) {
      //   console.log(
      //       'current: w', this.particleWeights[i], 'v',
      //       this.particleVisibility[i], dummy.position.y,
      //       this.velocities[i]);
      // }

      if (this.particleWeights[i] > kMaxAnimationFrames * kAnimationSpeed) {
        // Resets particle position and animation weight upon animation
        // completion.
        // console.log('reset', dummy.position.y, this.velocities[i]);
        this.respawnPrticle(dummy, i, camera, depthMesh);
      }

      // if (depth > 1) {
      //   depth *= 1.1;
      // }
      // TODO: use a slerp.
      // Sets visibility based on the distance to the screen and depth.

      // this.particleVisibility[i] = (this.particleWeights[i] > 0.0) ? 0.6 :
      // 0.9;

      // Occlusion
      // if (distanceToScreen > depth + 0.5) {
      //   this.particleVisibility[i] = 0.0;
      // }

      // if (depth < 0.3) {
      //   if (distanceToScreen > 0.5) {
      //     this.particleVisibility[i] = 1.0;
      //   } else {
      //     this.particleVisibility[i] = 0.4;
      //     this.particleWeights[i] += 1;
      //   }
      // }

      // if (distanceToScreen < 0.5) {
      //   this.particleVisibility[i] = 0.0;
      // }

      // this.particleVisibility[i] = 1.0;

      // if (this.particleWeights[i] == 0) {
      //   dummy.scale.set(1, 1, 1);
      // } else {
      //   dummy.scale.set(0.5, 0.5, 0.5);
      // }

      // console.log(
      //     'current: w', this.particleWeights[i], 'v',
      //     this.particleVisibility[i], 'y', dummy.position,
      //     this.velocities[i]);

      // Updates weight attribute for the shader.
      particleVisibilityAttribute.setX(i, this.particleVisibility[i]);
      particleWeightsAttribute.setX(i, this.particleWeights[i]);
      dummy.updateMatrix();
      this.raindropMesh.setMatrixAt(i, dummy.matrix);
    }

    // Marks mesh attributes for update and updates camera position uniform.
    this.raindropMesh.instanceMatrix.needsUpdate = true;
    particleWeightsAttribute.needsUpdate = true;
    particleVisibilityAttribute.needsUpdate = true;
    this.raindropMesh.material.uniforms.uCameraPosition.value.copy(
      camera.position
    );
  }

  /**
   * Resets a particle's position and animation weight upon reaching the ground.
   */
  respawnPrticle(dummy, index, camera, depthMesh) {
    let u = Math.random();
    let v = Math.random();
    const half = Math.random();
    // const vertex = depthMesh.getPosition(u, v);
    let vertex;
    let inited = false;
    let threshold = 0.05;
    if (depthMesh.minDepth < 0.16) {
      threshold = depthMesh.minDepth * 0.01;
    }

    threshold = 0.1;

    if (Math.random() < threshold) {
      u = u * 0.8 + 0.1;
      v = v * 0.8 + 0.1;
      this.raycaster.setFromCamera(
        {x: u * 2.0 - 1.0, y: v * 2.0 - 1.0},
        camera
      );
      const intersections = this.raycaster.intersectObject(depthMesh);
      if (intersections.length > 0) {
        vertex = intersections[0].point;
        inited = true;
      }
    }

    if (!inited) {
      const theta = u * 2 * Math.PI;
      let radius = Math.sqrt(v) * this.RANGE + 0.2;
      if (half < 0.5) {
        radius = Math.sqrt(v) * 0.7 + 0.3;
      } else if (half < 0.7) {
        radius = Math.sqrt(v) * 1.5 + 0.3;
      }

      vertex = {
        x: radius * Math.cos(theta),
        z: radius * Math.sin(theta),
        y: 4.0,
      };
    } else {
      // if (half < 0.5) {
      //   vertex = vertex.clone().lerp(camera.position, 0.5);
      //   dummy.position.set(vertex.x, 4.0, vertex.z);
      //   inited = false;
      // }
    }

    vertex = DEBUG_SINGLE ? new THREE.Vector3(-1, 4, -1) : vertex;

    dummy.position.set(vertex.x, vertex.y, vertex.z);
    dummy.rotation.set(0, 0, 0);
    this.particleWeights[index] = inited ? 1.0 : 0.0;

    // // Generate a random angle.
    // const theta = Math.random() * 2 * Math.PI;
    // // Generate a random radius with uniform distribution.
    // const radius = Math.sqrt(Math.random()) * this.RANGE;
    // // Calculate x and z positions.
    // const x = radius * Math.cos(theta);
    // const z = radius * Math.sin(theta);
    // const y = 4.0;

    // // Set the new position and reset other properties
    // dummy.position.set(x, y, z);
    // dummy.rotation.set(0, 0, 0);
    // this.particleWeights[index] = 0;
  }
}

```
File: `demos/rain/RainScene.js`
```javascript
import * as xb from 'xrblocks';
import * as THREE from 'three';
import {VolumetricCloud} from 'xrblocks/addons/volumes/VolumetricCloud.js';

import {RainParticles} from './RainParticles.js';

const ASSETS_PATH = 'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/';

export class RainScene extends xb.Script {
  rainParticles = new RainParticles();
  cloud = new VolumetricCloud();

  listener = null;
  rainSound = null;

  init() {
    this.add(this.rainParticles);
    this.rainParticles.init();
    this.add(this.cloud);

    this.listener = new THREE.AudioListener();
    xb.core.camera.add(this.listener);

    this.rainSound = new THREE.Audio(this.listener);
    const audioLoader = new THREE.AudioLoader();
    audioLoader.load(ASSETS_PATH + 'demos/rain/rain.opus', (buffer) => {
      this.rainSound.setBuffer(buffer);
      this.rainSound.setLoop(true); // Loop the sound for continuous rain
      this.rainSound.setVolume(0.5); // Set a comfortable volume
      this.rainSound.play(); // Start playback
      console.log('Rain audio loaded and playing.');
    });

    const startButton = document.getElementById('startButton');
    if (startButton) {
      startButton.addEventListener('click', () => {
        this.startAudio();
        startButton.remove(); // Remove the button after use
      });
    }
  }

  startAudio() {
    if (this.listener.context.state === 'suspended') {
      this.listener.context.resume();
    }

    if (this.rainSound.buffer) {
      this.rainSound.play();
      console.log('Rain audio started by user gesture.');
    }
  }

  update() {
    const leftCamera = xb.getXrCameraLeft() || xb.core.camera;
    this.rainParticles.update(leftCamera, xb.core.depth);
    this.cloud.update(xb.core.camera, xb.core.depth);
  }
}

```
File: `demos/rain/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Rain</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../demo.css" />

    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <div
      class="background-image"
      style="background-image: url('textures/background.webp')"
    ></div>

    <div
      id="startButton"
      style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: black;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 1000;
      "
    >
      <p style="font-size: 24px">Click to Start Rain Experience</p>
    </div>

    <script type="module" src="main.js?version=80"></script>
  </body>
</html>

```
File: `demos/rain/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {RainScene} from './RainScene.js';

const depthMeshColliderUpdateFps = xb.getUrlParamFloat(
  'depthMeshColliderUpdateFps',
  30
);

const options = new xb.Options();
options.reticles.enabled = false;
options.depth = new xb.DepthOptions(xb.xrDepthMeshPhysicsOptions);
options.depth.depthMesh.colliderUpdateFps = depthMeshColliderUpdateFps;
options.xrButton.startText = '<i id="xrlogo"></i> LET IT RAIN';
options.xrButton.endText = '<i id="xrlogo"></i> MISSION COMPLETE';

// Initializes the scene, camera, xrRenderer, controls, and XR button.
async function start() {
  const rainScene = new RainScene();
  xb.add(rainScene);
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Demo: screenwiper
File: `demos/screenwiper/ScreenWiper.js`
```javascript
import * as THREE from 'three';
import {ShaderPass} from 'three/addons/postprocessing/ShaderPass.js';

import {AlphaShader} from './alphashader.js';
import {ClearShader} from './clearshader.js';
import {ScreenWiperShader} from './screenwipershader.js';

const raycaster = new THREE.Raycaster();

const clearpass = new ShaderPass(ClearShader);
clearpass.renderToScreen = false;

export class ScreenWiper extends THREE.Mesh {
  activeControllers = [];

  constructor() {
    const NATIVE_RESOLUTION = 1024;
    const RESOLUTION_MULTIPLIER = 4;
    const RESOLUTION = NATIVE_RESOLUTION * RESOLUTION_MULTIPLIER;
    const renderTargetA = new THREE.WebGLRenderTarget(RESOLUTION, RESOLUTION);
    const renderTargetB = new THREE.WebGLRenderTarget(RESOLUTION, RESOLUTION);

    const geometry = new THREE.SphereGeometry(15, 32, 16);
    const material = new THREE.ShaderMaterial({
      name: 'ScreenWiperShader',
      defines: Object.assign({}, ScreenWiperShader.defines),
      uniforms: THREE.UniformsUtils.clone(ScreenWiperShader.uniforms),
      vertexShader: ScreenWiperShader.vertexShader,
      fragmentShader: ScreenWiperShader.fragmentShader,
      transparent: true,
      side: THREE.DoubleSide,
    });
    super(geometry, material);
    this.renderTargetA = renderTargetA;
    this.renderTargetB = renderTargetB;

    this.shaderpass = new ShaderPass(AlphaShader);
    this.controllerActiveUniforms = [
      this.shaderpass.material.uniforms.uLeftWiperActive,
      this.shaderpass.material.uniforms.uRightWiperActive,
    ];
    this.controllerCartesianCoordinateUniforms = [
      this.shaderpass.material.uniforms.uLeftHandCartesianCoordinate,
      this.shaderpass.material.uniforms.uRightHandCartesianCoordinate,
    ];
    this.worldPosition = new THREE.Vector3();
    this.starttime = Date.now();
  }

  clear(renderer) {
    // Remember renderer state.
    const xrEnabled = renderer.xr.enabled;
    const xrTarget = renderer.getRenderTarget();

    // Render to offscreen buffer.
    renderer.xr.enabled = false;
    clearpass.render(renderer, this.renderTargetA, null);
    clearpass.render(renderer, this.renderTargetB, null);
    this.material.uniforms.uMask.value = this.renderTargetB.texture;

    // Reset renderer state
    renderer.xr.enabled = xrEnabled;
    renderer.setRenderTarget(xrTarget);
  }

  update(renderer) {
    const camera = renderer.xr.getCamera().cameras[0];
    if (camera != null) {
      // Make this headtracked
      this.position.copy(camera.position);
    }

    this.getWorldPosition(this.worldPosition);
    for (let i = 0; i < 2; i++) {
      if (i < this.activeControllers.length) {
        this.controllerActiveUniforms[i].value = true;
        const controller = this.activeControllers[i];
        raycaster.setFromXRController(controller);
        const intersects = raycaster.intersectObject(this);
        if (intersects.length > 0) {
          this.controllerCartesianCoordinateUniforms[i].value
            .copy(intersects[0].point)
            .sub(this.worldPosition)
            .normalize();
        }
      } else {
        this.controllerActiveUniforms[i].value = false;
      }
    }

    const elapsedTime = (Date.now() - this.starttime) / 1000;
    if (this.material.uniforms.uTime) {
      this.material.uniforms.uTime.value.set(
        elapsedTime / 20,
        elapsedTime,
        elapsedTime * 2,
        elapsedTime * 3
      );
    }

    // Remember renderer state.
    const xrEnabled = renderer.xr.enabled;
    const xrTarget = renderer.getRenderTarget();

    // Render to offscreen buffer.
    renderer.xr.enabled = false;
    [this.renderTargetA, this.renderTargetB] = [
      this.renderTargetB,
      this.renderTargetA,
    ];
    this.shaderpass.renderToScreen = false;
    this.shaderpass.render(renderer, this.renderTargetB, this.renderTargetA);
    this.material.uniforms.uMask.value = this.renderTargetB.texture;

    // Reset renderer state
    renderer.xr.enabled = xrEnabled;
    renderer.setRenderTarget(xrTarget);
  }

  addActiveController(controller) {
    this.activeControllers.push(controller);
  }

  removeActiveController(controller) {
    const index = this.activeControllers.indexOf(controller);
    if (index != -1) {
      this.activeControllers.splice(index, 1);
    }
  }

  dispose() {
    this.renderTargetA.dispose();
    this.renderTargetB.dispose();
    this.shaderpass.dispose();
    this.material.dispose();
  }

  startTransition(passthrough) {
    this.shaderpass.material.uniforms.uReturnSpeed.value = passthrough
      ? -0.005
      : 0.005;
  }
}

```
File: `demos/screenwiper/ScreenWiperScene.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';

import {ScreenWiper} from './ScreenWiper.js';

export class ScreenWiperScene extends xb.Script {
  screenWiper = new ScreenWiper({
    width: 1.0,
    height: 1.0,
    color: new THREE.Color(0x000000),
    speed: 0.5,
    direction: 'right',
    start: 0.0,
    end: 1.0,
  });

  constructor(opts) {
    super(opts);
    this.add(this.screenWiper);
  }

  init() {
    this.screenWiper.clear(xb.core.renderer);
  }

  onSelectStart(event) {
    this.screenWiper.addActiveController(event.target);
  }

  onSelectEnd(event) {
    this.screenWiper.removeActiveController(event.target);
  }

  update() {
    this.screenWiper.update(xb.core.renderer);
  }
}

```
File: `demos/screenwiper/alphashader.js`
```javascript
import * as THREE from 'three';

export const AlphaShader = {
  name: 'AlphaShader',

  defines: {
    DEG_TO_RAD: 3.14159265359 / 180.0,
  },

  uniforms: {
    tDiffuse: {value: null},
    uWiperDegrees: {value: 10.0},
    uLeftWiperActive: {value: false},
    uLeftHandCartesianCoordinate: {value: new THREE.Vector3(0.0, -1.0, 0.0)},
    uRightWiperActive: {value: false},
    uRightHandCartesianCoordinate: {value: new THREE.Vector3(0.0, -1.0, 0.0)},
    uReturnSpeed: {value: 0.005},
  },

  vertexShader: /* glsl */ `

          varying vec2 vUv;

          void main() {

              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

          }`,

  fragmentShader: /* glsl */ `

          #include <common>

          varying vec2 vUv;

          uniform sampler2D tDiffuse;
          uniform float uWiperDegrees;
          uniform bool uLeftWiperActive;
          uniform vec3 uLeftHandCartesianCoordinate;
          uniform bool uRightWiperActive;
          uniform vec3 uRightHandCartesianCoordinate;
          uniform float uReturnSpeed;

          vec3 sphericalToCartesian(vec3 spherical) {
            float x = spherical.x * cos(spherical.y) * sin(spherical.z);
            float y = spherical.x * cos(spherical.z);
            float z = spherical.x * sin(spherical.y) * sin(spherical.z);
            return vec3(x, y, z);
          }

          float getWiperValue(bool wiperActive, vec3 handCartesianCoordinate) {
            if (!wiperActive) return 1.0;
            vec3 cartesianCoordinate = sphericalToCartesian(vec3(1.0, PI - vUv.x * 2.0 * PI, PI - vUv.y * PI));
            float cosineSimilarity = dot(handCartesianCoordinate, cartesianCoordinate);
            float wiperValue = 1.0 - smoothstep(cos(uWiperDegrees * DEG_TO_RAD), 1.0, cosineSimilarity);
            wiperValue = 0.95 + 0.05 * wiperValue;
            return wiperValue;
          }

          void main() {
              float prevFrameValue = texture(tDiffuse, vUv).g;
              float newFrameValue = prevFrameValue + uReturnSpeed * (uLeftWiperActive || uRightWiperActive ? 0.0 : 1.0);
              newFrameValue *= getWiperValue(uLeftWiperActive, uLeftHandCartesianCoordinate);
              newFrameValue *= getWiperValue(uRightWiperActive, uRightHandCartesianCoordinate);
              gl_FragColor = vec4(vec3(newFrameValue), 1.0);
          }`,
};

```
File: `demos/screenwiper/clearshader.js`
```javascript
import * as THREE from 'three';

export const ClearShader = {
  name: 'ClearShader',

  defines: {
    DEG_TO_RAD: 3.14159265359 / 180.0,
  },

  uniforms: {
    uClearColor: {
      value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0),
    },
  },

  vertexShader: /* glsl */ `

          varying vec2 vUv;

          void main() {

              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

          }`,

  fragmentShader: /* glsl */ `

          #include <common>

          varying vec2 vUv;
          uniform vec4 uClearColor;


          void main() {
            gl_FragColor = uClearColor;
          }`,
};

```
File: `demos/screenwiper/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Screen Wiper</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../demo.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <audio loop id="music" preload="auto" style="display: none">
      <source
        src="https://cdn.jsdelivr.net/gh/xrblocks/assets@main/musicLibrary/BackgroundMusic4.mp3"
        type="audio/mpeg"
      />
    </audio>

    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `demos/screenwiper/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {ScreenWiperScene} from './ScreenWiperScene.js';

const options = new xb.Options();
options.antialias = true;
options.reticles.enabled = true;
options.visualizeRays = true;

function start() {
  xb.add(new ScreenWiperScene());
  xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```
File: `demos/screenwiper/screenwipershader.js`
```javascript
import * as THREE from 'three';

const noise_texture = new THREE.TextureLoader().load(
  'screenwiper_assets/Noise.png'
);
noise_texture.wrapS = THREE.RepeatWrapping;
noise_texture.wrapT = THREE.RepeatWrapping;

const color_map = new THREE.TextureLoader().load(
  'screenwiper_assets/ColorMap.png'
);
color_map.wrapS = THREE.RepeatWrapping;

export const ScreenWiperShader = {
  name: 'ScreenWiperShader',

  defines: {
    DEG_TO_RAD: 3.14159265359 / 180.0,
  },

  uniforms: {
    uTexture: {value: noise_texture},
    uMask: {value: null},
    uColorMap: {value: color_map},
    uTime: {value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0)},
    uMoveSpeed: {value: 0.1},
    uColorSpeed: {value: 0.2},
    uPulseSpeed: {value: 4.0},
    uPulseAmount: {value: 0.025},
    uHoleColor: {
      value: new THREE.Vector4(
        49.0 / 255,
        103.0 / 255,
        154.0 / 255,
        64.0 / 255
      ),
    },
  },

  vertexShader: /* glsl */ `

          varying vec2 vUv;

          void main() {

              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

          }`,

  fragmentShader: /* glsl */ `

          #include <common>

          varying vec2 vUv;

          uniform sampler2D uTexture;
          uniform sampler2D uMask;
          uniform sampler2D uColorMap;
          uniform vec4 uTime;
          uniform float uColorSpeed;
          uniform float uMoveSpeed;
          uniform float uPulseSpeed;
          uniform float uPulseAmount;
          uniform vec4 uHoleColor;


          void main() {
            // Sample at uv scale 1.
            vec2 uv1 = vUv;
            uv1.x += sin(uTime.x * 4.89 * uMoveSpeed);
            uv1.y += uTime.y * .123 * uMoveSpeed;
            vec4 tex1 = texture(uTexture, 2.0 * uv1);

            // Sample at uv scale 2.
            vec2 uv2 = vUv * 2.0;
            uv2.x += uTime.y * 0.277 * uMoveSpeed;
            uv2.y += sin(uTime.x * 6.231 * uMoveSpeed);
            vec4 tex2 = texture(uTexture, 2.0 * uv2);

            float totalValue = (tex1.r * 0.75) + (tex2.r * 0.25);
            vec4 mapColor = texture(uColorMap, vec2(totalValue + uTime.x * uColorSpeed, 0.5));
            vec4 col = saturate(mapColor);
            col.a = 1.0;

            // Mask.
            float pulseInside = sin(uTime.y * uPulseSpeed + vUv.x * 150.0) * uPulseAmount;
            float pulseOutside = cos(uTime.y * uPulseSpeed + vUv.x * 150.0) * uPulseAmount;
            vec4 mask = texture(uMask, vUv);
            vec4 tintedCol = mix(col, uHoleColor, 0.5);
            col = mix(tintedCol, col, step(0.8 + pulseOutside, mask.r));
            col.a = mix(0.0, max(col.a, tintedCol.a), step(0.5 + pulseInside, mask.r));
            gl_FragColor = col;
          }`,
};

```


### Demo: splash
File: `demos/splash/PaintSplash.js`
```javascript
import * as THREE from 'three';
import {SimpleDecalGeometry} from 'xrblocks/addons/objects/SimpleDecalGeometry.js';

const ASSETS_PATH = 'https://cdn.jsdelivr.net/gh/xrblocks/assets@main/';

// Duration of fade out in ms.
const kFadeoutMs = 2000;
const textureLoader = new THREE.TextureLoader();
const decalDiffuse = textureLoader.load(
  './paintball_assets/decal-diffuse1.webp'
);
decalDiffuse.colorSpace = THREE.SRGBColorSpace; // Sets the color space for the decal diffuse texture.
const decalNormal = textureLoader.load('./paintball_assets/decal-normal1.webp');

let paintshotAudioBuffer; // Declares a variable to hold the audio buffer for
// the paint shot sound.
const audioLoader = new THREE.AudioLoader();
audioLoader.load(
  ASSETS_PATH + 'musicLibrary/PaintOneShot1.opus',
  function (buffer) {
    paintshotAudioBuffer = buffer; // Loads the paint shot audio and assigns it to the buffer.
  }
);

/**
 * PaintSplash class represents a 3D object for the paintball decal, including
 * the visual decal and optional sound.
 */
export class PaintSplash extends THREE.Object3D {
  /**
   * @param {THREE.AudioListener} listener The audio listener for spatial audio.
   * @param {THREE.Color} color The color of the paintball.
   */
  constructor(listener, color) {
    super();
    // Adds positional audio to the paintball if a listener is provided.
    if (listener != null) {
      this.sound = new THREE.PositionalAudio(listener);
    }
    this.color = color; // Sets the paintball color.
    this.enableSound = true;
    this.splashList = [];
  }

  /**
   * Projects a splat onto a mesh from an intersection point, applying rotation
   * and scale.
   * @param {THREE.Intersection} intersection The intersection data.
   * @param {number} scale The scale of the splat.
   */
  splatFromIntersection(intersection, scale) {
    const objectRotation = new THREE.Quaternion();
    intersection.object.getWorldQuaternion(objectRotation); // Gets the world quaternion for rotation.

    // Clones and rotates the intersection normal to align it with the mesh's
    // orientation.
    const normal = intersection.normal.clone().applyQuaternion(objectRotation);

    const originalNormal = new THREE.Vector3(0, 0, 1); // The original normal to face.
    const angle = originalNormal.angleTo(normal); // Calculates the angle between the normals.

    // Rotates the original normal by the cross product and normalizes it.
    originalNormal.cross(normal).normalize();

    // Applies a random rotation to the splat around the normal.
    const randomRotation = new THREE.Quaternion().setFromAxisAngle(
      normal,
      Math.random() * Math.PI * 2
    );

    // Rotates the splat to face the surface normal with a random rotation.
    const rotateFacingNormal = new THREE.Quaternion()
      .setFromAxisAngle(originalNormal, angle)
      .premultiply(randomRotation);

    // Projects the splat onto the mesh at the given position, orientation, and
    // scale.
    this.splatOnMesh(
      intersection.object,
      intersection.point,
      rotateFacingNormal,
      scale
    );
  }

  /**
   * Creates and applies a decal on the mesh at the specified position with the
   * given orientation and scale.
   * @param {THREE.Mesh} mesh The mesh where the splat will be applied.
   * @param {THREE.Vector3} position The world position of the splat.
   * @param {THREE.Quaternion} orientation The rotation of the splat.
   * @param {number} scale The scale of the splat.
   */
  splatOnMesh(mesh, position, orientation, scale) {
    // Creates a material for the decal using the specified color, textures, and
    // settings.
    const material = new THREE.MeshPhongMaterial({
      color: this.color,
      specular: 0x555555,
      map: decalDiffuse,
      normalMap: decalNormal,
      normalScale: new THREE.Vector2(1, 1),
      shininess: 30,
      transparent: true,
      depthTest: true,
      polygonOffset: true,
      polygonOffsetFactor: 0,
      alphaTest: 0.5,
      opacity: 1.0,
      side: THREE.FrontSide,
    });

    // Creates a scale vector for the decal geometry.
    const scaleVector3 = new THREE.Vector3(scale, scale, scale);

    // Generates a custom geometry for the decal using the SimpleDecalGeometry
    // class.
    const geometry = new SimpleDecalGeometry(
      mesh,
      position,
      orientation,
      scaleVector3
    );
    geometry.computeVertexNormals(); // Computes vertex normals for proper shading.

    // Creates a mesh for the decal and adds it to the scene.
    this.decalMesh = new THREE.Mesh(geometry, material);
    this.decalMesh.createdTime = performance.now();
    this.add(this.decalMesh);

    // Plays the paint shot sound if the audio buffer is loaded and sound is
    // enabled.
    if (
      this.enableSound &&
      this.sound != null &&
      paintshotAudioBuffer != null
    ) {
      this.sound.setBuffer(paintshotAudioBuffer);
      this.sound.setRefDistance(10);
      this.sound.play();
    }
  }

  update() {
    const currentTime = performance.now();

    // Iterate over all children of the Object3D instance
    this.children.forEach((child) => {
      // Ensure the child is a THREE.Mesh and has a 'createdTime' property
      if (child instanceof THREE.Mesh && child.createdTime !== undefined) {
        const timeElapsed = currentTime - child.createdTime;

        // Check if it's time to start fading out the mesh (after 2 seconds)
        if (timeElapsed > kFadeoutMs) {
          const timeSinceFadeStart = timeElapsed - kFadeoutMs; // Time since the start of fade

          // If within the fade duration, update opacity
          if (timeSinceFadeStart <= kFadeoutMs) {
            const newOpacity = 1.0 - timeSinceFadeStart / kFadeoutMs;
            child.material.opacity = Math.max(0.0, newOpacity); // Ensure opacity doesn't go below 0
            child.material.transparent = true; // Ensure transparency is enabled
          } else {
            // If the fade duration has passed, remove the mesh from the scene
            this.remove(child);
          }
        }
      }
    });
  }

  /**
   * Disposes of the paintball's decal mesh and its associated geometry and
   * material.
   */
  dispose() {
    if (this.decalMesh) {
      this.decalMesh.geometry.dispose(); // Disposes of the geometry.
      this.decalMesh.material.dispose(); // Disposes of the material.
    }
  }
}

```
File: `demos/splash/SplashScript.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';
import {palette} from 'xrblocks/addons/utils/Palette.js';

import {BallShooter} from '../ballpit/BallShooter.js';

import {PaintSplash} from './PaintSplash.js';

const kLightX = xb.getUrlParamFloat('lightX', 0);
const kLightY = xb.getUrlParamFloat('lightY', 500);
const kLightZ = xb.getUrlParamFloat('lightZ', -10);
const kBallsPerSecond = xb.getUrlParamFloat('ballsPerSecond', 10);
const kVelocityScale = xb.getUrlParamInt('velocityScale', 1.0);
const kBallRadius = xb.getUrlParamFloat('ballRadius', 0.04);

export class SplashScript extends xb.Script {
  constructor() {
    super();
    this.ballShooter = new BallShooter({
      numBalls: 100,
      radius: kBallRadius,
      palette: palette,
    });
    this.add(this.ballShooter);
    this.lastBallTime = new Map();

    this.raycaster = new THREE.Raycaster();
    this.paintballs = [];
    this.listener = new THREE.AudioListener();

    this.pointer = new THREE.Vector2();
    this.velocity = new THREE.Vector3();
  }

  init() {
    this.addLights();
    xb.core.input.addReticles();
    xb.showReticleOnDepthMesh(true);
    xb.core.camera.add(this.listener);
  }

  initPhysics(xrPhysics) {
    this.physics = xrPhysics;
    this.ballShooter.setupPhysics({
      RAPIER: xrPhysics.RAPIER,
      blendedWorld: xrPhysics.blendedWorld,
      colliderActiveEvents: xrPhysics.RAPIER.ActiveEvents.CONTACT_FORCE_EVENTS,
      continuousCollisionDetection: true,
    });
  }

  generateDecalAtIntersection(intersection) {
    const paintball = new PaintSplash(
      this.listener,
      palette.getRandomLiteGColor()
    );

    const scaleMultiplier = 0.4;

    if (xb.core.depth.depthData.length > 0) {
      xb.core.depth.depthMesh.updateFullResolutionGeometry(
        xb.core.depth.depthData[0]
      );
    }
    paintball.splatFromIntersection(
      intersection /*scale=*/,
      xb.lerp(scaleMultiplier * 0.3, scaleMultiplier * 0.5, Math.random())
    );
    this.add(paintball);
    this.paintballs.push(paintball);
  }

  generateDecalFromCollision(position, direction, color) {
    const paintball = new PaintSplash(this.listener, color);
    const orientation = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0.0, 0.0, -1.0),
      direction
    );
    const scaleMultiplier = 0.4;
    const scale = xb.lerp(
      scaleMultiplier * 0.3,
      scaleMultiplier * 0.5,
      Math.random()
    );
    if (xb.core.depth.cpuDepthData.length > 0) {
      xb.core.depth.depthMesh.updateFullResolutionGeometry(
        xb.core.depth.cpuDepthData[0]
      );
    } else if (xb.core.depth.gpuDepthData.length > 0) {
      xb.core.depth.depthMesh.updateFullResolutionGeometry(
        xb.core.depth.depthMesh.convertGPUToGPU(xb.core.depth.gpuDepthData[0])
      );
    }
    paintball.splatOnMesh(
      xb.core.depth.depthMesh,
      position,
      orientation,
      scale
    );
    this.add(paintball);
    this.paintballs.push(paintball);
  }

  // Handles controller interactions for spawning and launching spheres.
  controllerUpdate(controller) {
    const now = performance.now();
    if (!this.lastBallTime.has(controller)) {
      this.lastBallTime.set(controller, -99);
    }
    if (
      controller.userData.selected &&
      now - this.lastBallTime.get(controller) >= 1000 / kBallsPerSecond
    ) {
      // Place this 10 cm in front of the controller.
      const newPosition = new THREE.Vector3(0.0, 0.0, -0.1)
        .applyQuaternion(controller.quaternion)
        .add(controller.position);
      this.velocity
        .set(0, 0, -5.0 * kVelocityScale)
        .applyQuaternion(controller.quaternion);
      this.ballShooter.spawnBallAt(newPosition, this.velocity);
      this.lastBallTime.set(controller, now);
    }
  }

  update() {
    for (let controller of xb.core.input.controllers) {
      this.controllerUpdate(controller);
    }

    for (let paintball of this.paintballs) {
      paintball.update();
    }
  }

  physicsStep() {
    const contactPoint = new THREE.Vector3();
    const forceDirection = new THREE.Vector3();
    const ballShooter = this.ballShooter;
    this.physics.eventQueue.drainContactForceEvents((event) => {
      const handle1 = event.collider1();
      const handle2 = event.collider2();
      const depthMeshCollider =
        xb.core.depth.depthMesh.getColliderFromHandle(handle1) ||
        xb.core.depth.depthMesh.getColliderFromHandle(handle2);
      const ballIndex =
        ballShooter.getIndexForColliderHandle(handle1) ||
        ballShooter.getIndexForColliderHandle(handle2);
      let generatedDecal = false;
      if (
        depthMeshCollider &&
        ballIndex != null &&
        ballShooter.isBallActive(ballIndex)
      ) {
        const ball = ballShooter.spheres[ballIndex];
        this.physics.blendedWorld.contactPair(
          depthMeshCollider,
          ballShooter.colliders[ballIndex],
          (manifold, flipped) => {
            if (!generatedDecal && manifold.numSolverContacts() > 0) {
              contactPoint.copy(manifold.solverContactPoint(0));
              forceDirection.copy(event.maxForceDirection());
              this.generateDecalFromCollision(
                contactPoint,
                forceDirection,
                ball.material.color
              );
              generatedDecal = true;
            }
          }
        );
        ballShooter.removeBall(ballIndex);
      }
    });
    ballShooter.physicsStep();
  }

  // Adds hemisphere light for ambient lighting and directional light.
  addLights() {
    this.add(new THREE.HemisphereLight(0xbbbbbb, 0x888888, 3));
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(kLightX, kLightY, kLightZ);
    light.castShadow = true;
    light.shadow.mapSize.width = 2048; // Default is usually 1024
    light.shadow.mapSize.height = 2048; // Default is usually 1024
    this.add(light);
  }

  onPointerUp(event) {
    this.mouseReticle.setPressed(false);
  }
}

```
File: `demos/splash/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Splash</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../demo.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "@dimforge/rapier3d-simd-compat": "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-simd-compat@0.19.2/rapier.mjs",
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <div
      class="background-image"
      style="background-image: url('textures/background.webp')"
    ></div>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `demos/splash/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import RAPIER from '@dimforge/rapier3d-simd-compat';
import * as xb from 'xrblocks';

import {SplashScript} from './SplashScript.js';

const depthMeshColliderUpdateFps = xb.getUrlParamFloat(
  'depthMeshColliderUpdateFps',
  30
);
const splashScript = new SplashScript();

let options = new xb.Options();
options.depth = new xb.DepthOptions(xb.xrDepthMeshPhysicsOptions);
options.depth.depthMesh.colliderUpdateFps = depthMeshColliderUpdateFps;
options.xrButton = {
  ...options.xrButton,
  startText: '<i id="xrlogo"></i> MAKE A MESS',
  endText: '<i id="xrlogo"></i> MISSION COMPLETE',
};
options.physics.RAPIER = RAPIER;
options.physics.useEventQueue = true;

// Initializes the scene, camera, xrRenderer, controls, and XR button.
async function start() {
  xb.add(splashScript);
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```


### Demo: webcam_gestures
File: `demos/webcam_gestures/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Webcam Gestures | XR Blocks</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <link type="text/css" rel="stylesheet" href="./styles.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/",
          "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
        }
      }
    </script>
  </head>

  <body>
    <div id="camera-container">
      <video id="webcam-video" autoplay playsinline muted></video>
      <canvas id="output-canvas"></canvas>
      <div id="gesture-label">Loading...</div>
    </div>
    <script type="module">
import 'xrblocks/addons/simulator/SimulatorAddons.js';
import * as xb from 'xrblocks';
import {
  FilesetResolver,
  GestureRecognizer,
  DrawingUtils,
} from '@mediapipe/tasks-vision';

class HandTrackingService {
  constructor() {
    this.gestureRecognizer = null;
    this.videoElement = document.getElementById('webcam-video');
    this.canvasElement = document.getElementById('output-canvas');
    this.canvasCtx = this.canvasElement.getContext('2d');
    this.gestureLabel = document.getElementById('gesture-label');
    this.lastVideoTime = -1;
    this.currentGesture = 'NONE';
  }

  async initialize() {
    const vision = await FilesetResolver.forVisionTasks(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm'
    );

    this.gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath:
          'https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/latest/gesture_recognizer.task',
        delegate: 'GPU',
      },
      runningMode: 'VIDEO',
      numHands: 1,
    });

    try {
      const stream = await navigator.mediaDevices.getUserMedia({video: true});
      this.videoElement.srcObject = stream;
      this.videoElement.addEventListener('loadeddata', () => {
        this.gestureLabel.innerText = 'Show Hand';
        this.predictWebcam();
      });
    } catch (err) {
      console.error(err);
      this.gestureLabel.innerText = 'Camera Error';
    }
  }

  async predictWebcam() {
    requestAnimationFrame(() => this.predictWebcam());
    if (!this.gestureRecognizer) return;

    if (this.videoElement.currentTime !== this.lastVideoTime) {
      this.lastVideoTime = this.videoElement.currentTime;
      const results = this.gestureRecognizer.recognizeForVideo(
        this.videoElement,
        performance.now()
      );
      this.drawResults(results);
    }
  }

  detectCustomGestures(landmarks) {
    const wrist = landmarks[0],
      thumbTip = landmarks[4],
      indexKnuckle = landmarks[5];
    const indexTip = landmarks[8],
      indexPip = landmarks[6];
    const middleTip = landmarks[12],
      middlePip = landmarks[10];
    const ringTip = landmarks[16],
      ringPip = landmarks[14];
    const pinkyTip = landmarks[20],
      pinkyPip = landmarks[18];

    const dist = (p1, p2) =>
      Math.sqrt(
        Math.pow(p1.x - p2.x, 2) +
          Math.pow(p1.y - p2.y, 2) +
          Math.pow(p1.z - p2.z, 2)
      );
    const isExtended = (tip, pip) => dist(tip, wrist) > dist(pip, wrist) * 1.1;

    const indexOpen = isExtended(indexTip, indexPip);
    const middleOpen = isExtended(middleTip, middlePip);
    const ringOpen = isExtended(ringTip, ringPip);
    const pinkyOpen = isExtended(pinkyTip, pinkyPip);

    // Check fist-based gestures first
    if (!indexOpen && !middleOpen && !ringOpen && !pinkyOpen) {
      if (thumbTip.y > indexKnuckle.y + 0.1) return 'THUMB_DOWN';
      if (thumbTip.y < indexKnuckle.y - 0.1) return 'THUMB_UP';
      return 'FIST';
    }

    // PINCH requires index finger partially extended
    const indexExtension = dist(indexTip, wrist) / dist(indexKnuckle, wrist);
    if (dist(thumbTip, indexTip) < 0.05 && indexExtension > 1.3) {
      return 'PINCH';
    }

    // ROCK gesture
    if (indexOpen && !middleOpen && !ringOpen && pinkyOpen) {
      return 'ROCK';
    }

    return null;
  }

  drawResults(results) {
    this.canvasElement.width = this.videoElement.videoWidth;
    this.canvasElement.height = this.videoElement.videoHeight;
    this.canvasCtx.clearRect(
      0,
      0,
      this.canvasElement.width,
      this.canvasElement.height
    );

    if (!results || !results.landmarks.length) {
      this.currentGesture = 'NONE';
      this.gestureLabel.innerText = 'No Hand';
      this.gestureLabel.style.color = '#fff';
      return;
    }

    const landmarks = results.landmarks[0];
    const drawingUtils = new DrawingUtils(this.canvasCtx);
    drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {
      color: '#00FF00',
      lineWidth: 3,
    });
    drawingUtils.drawLandmarks(landmarks, {
      color: '#FF0000',
      lineWidth: 1,
      radius: 3,
    });

    let gesture = this.detectCustomGestures(landmarks);

    // Fallback to MediaPipe native gestures
    if (!gesture && results.gestures.length > 0) {
      const name = results.gestures[0][0].categoryName;
      const mapping = {
        Pointing_Up: 'POINTING',
        Victory: 'VICTORY',
        Thumb_Up: 'THUMB_UP',
        Closed_Fist: 'FIST',
        Open_Palm: 'RELAXED',
      };
      gesture = mapping[name] || name;
    }

    gesture = gesture || 'NONE';
    this.currentGesture = gesture;
    this.gestureLabel.innerText = gesture.replace(/_/g, ' ');
    this.gestureLabel.style.color =
      gesture !== 'NONE' && gesture !== 'RELAXED' ? '#0f0' : '#ccc';
  }
}

const handTracking = new HandTrackingService();
handTracking.initialize();

class GestureToSimulatorBridge extends xb.Script {
  constructor() {
    super();
    this.lastGesture = 'NONE';
    this.lastTriggerTime = 0;
    this.cooldownMs = 100;
    this.gestureToSimulatorPose = {
      PINCH: xb.SimulatorHandPose.PINCHING,
      FIST: xb.SimulatorHandPose.FIST,
      THUMB_UP: xb.SimulatorHandPose.THUMBS_UP,
      THUMB_DOWN: xb.SimulatorHandPose.THUMBS_DOWN,
      POINTING: xb.SimulatorHandPose.POINTING,
      VICTORY: xb.SimulatorHandPose.VICTORY,
      ROCK: xb.SimulatorHandPose.ROCK,
      RELAXED: xb.SimulatorHandPose.RELAXED,
      NONE: xb.SimulatorHandPose.RELAXED,
    };
  }

  update() {
    const gesture = handTracking.currentGesture;
    const currentTime = performance.now();

    if (
      gesture !== this.lastGesture &&
      currentTime - this.lastTriggerTime >= this.cooldownMs
    ) {
      this.lastGesture = gesture;
      this.lastTriggerTime = currentTime;
      const simulatorPose = this.gestureToSimulatorPose[gesture];
      if (simulatorPose && xb.core.simulator?.hands) {
        xb.core.simulator.hands.setRightHandLerpPose(simulatorPose);
      }
    }
  }
}

const options = new xb.Options();
options.enableUI();
options.simulator.defaultMode = xb.SimulatorMode.POSE;
options.simulator.stereo.enabled = true;
options.xrButton.alwaysAutostartSimulator = true;

document.addEventListener('DOMContentLoaded', () => {
  xb.add(new GestureToSimulatorBridge());
  xb.init(options);
});

</script>
  </body>
</html>

```


### Demo: xremoji
File: `demos/xremoji/AnimationHandler.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';

//
// Unique name for objects
//
let globalIndex = 0;

class AnimationItemView {
  constructor(options, objectView, modelView, isDebug = false) {
    this.options = {...options};
    this.objectView = objectView;
    this.modelView = modelView;
    this.isDebug = isDebug;
    this.isReady = false;
    this.isPlaying = false;
    this.animationStartTime = performance.now();
    this.enableDebugIfNeeded();
  }

  enableDebugIfNeeded() {
    if (this.isDebug) {
      return;
    }

    this.uniqueId = globalIndex++;

    this.name = 'GLTF_MODEL_VIEW_' + this.uniqueId;

    //
    // Uses to measure models load time
    //
    console.time(this.name);

    // disable auto-start for animation

    // name for debug messages
    this.modelView.name = 'ModelViewer-' + this.uniqueId;

    // Init ObjectViewer (wrapper for the ModelViewer)

    // objectView.visible = false;
    this.objectView.name = 'ObjectView-' + this.uniqueId;
  }

  printItemInfo() {
    if (!this.isDebug) return;

    this.printInfo(this.modelView);
    this.printInfo(this.objectView);
  }

  printInfo(model) {
    if (!model) {
      console.warn('Model is null or undefined.');
      return;
    }

    console.log(`--- Model Information: ${model.name || 'Unnamed Model'} ---`);

    // Position
    console.log(
      'Position:',
      model.position.x.toFixed(2),
      model.position.y.toFixed(2),
      model.position.z.toFixed(2)
    );

    // Scale
    console.log(
      'Scale:',
      model.scale.x.toFixed(5),
      model.scale.y.toFixed(5),
      model.scale.z.toFixed(5)
    );

    // Size (Bounding Box)
    const boundingBox = new THREE.Box3().setFromObject(model);
    const size = new THREE.Vector3();
    boundingBox.getSize(size);
    console.log(
      'Size (Width x Height x Depth):',
      `${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`
    );

    console.log('------------------------------------------');
  }

  onSceneReady(data, scene) {
    this.isReady = true;
    //
    // Note: Pay attention that scale will be applied to position too
    //
    if (data.position) {
      this.modelView.position.copy(data.position);
    }

    //
    // Set 0 position for the scene
    //
    const scene_position = data.model.position || {x: 0, y: 0, z: 0};
    scene.position.copy(scene_position);

    //
    // Debug: print the model load time
    //
    if (this.isDebug) console.timeEnd(this.name);
  }

  //
  // update binded options
  //
  updateOptions(newOptions) {
    this.options = {...newOptions};
  }
}

export class AnimationHandler {
  constructor(data, isDebug = false) {
    this.data = data;
    this.isDebug = isDebug;
    this.animationViews = [];
  }

  init(core, panel, options = {}) {
    this.loadGltfModels(panel, this.data, options);
    for (let i = 0; i < this.animationViews.length; ++i) {
      const item = this.animationViews[i];
      core.scene.add(item.modelView);
    }
  }

  loadGltfModels(panel, data, options) {
    // Return the list
    let result = [];
    for (let i = 0; i < data.length; i++) {
      if (data[i].model) {
        //
        // Init model viewer
        //
        let objectView = new xb.View();
        // objectView.visible = false;
        const model = new xb.ModelViewer({});
        model.visible = false;
        model.startAnimationOnLoad = false;

        const animationItem = new AnimationItemView(
          options,
          objectView,
          model,
          this.isDebug
        );
        this.animationViews.push(animationItem);

        // Load model
        model.loadGLTFModel({
          data: data[i].model,
          setupRaycastCylinder: false,
          setupRaycastBox: true,
          renderer: xb.core.renderer,
          setupPlatform: false,
          onSceneLoaded: (scene) => {
            animationItem.onSceneReady(data[i], scene);
          },
        });
        // Make a scene hierarchy
        objectView.add(model);
        panel.add(objectView);
      }
    }
    panel.updateLayouts();
  }

  onBeforePlay() {
    // Empty
  }

  onBeforeUpdate() {}

  play(playbackTime = 1800) {
    if (this.isPlaying) {
      return;
    }

    this.isPlaying = true;

    this.animationDuration = playbackTime;

    // Override this method if needed
    this.onBeforePlay();

    for (let i = 0; i < this.animationViews.length; ++i) {
      const item = this.animationViews[i];
      // Assign core to model
      item.modelView.playClipAnimationOnce();

      // Print position + size
      item.printItemInfo();
    }
    // Make all objects visible
    this.setVisibility(true);

    //
    // NOTE: Increase timeout to hide animation later
    //       Entire animation ~6 seconds
    //

    setTimeout(() => {
      this.setVisibility(false);
      setTimeout(() => {
        this.isPlaying = false;
      }, 150);
    }, playbackTime);
  }

  setVisibility(visible) {
    for (let i = 0; i < this.animationViews.length; ++i) {
      const item = this.animationViews[i];
      item.modelView.visible = visible;
    }
  }
}

```
File: `demos/xremoji/BallloonsAnimationHandler.js`
```javascript
import {AnimationHandler} from './AnimationHandler.js';

const defaultOptions = {
  oscillationAmplitude: 0.2,
  oscillationFrequencyX: 0.2, // Oscillations per second for X
  oscillationFrequencyZ: 0.3, // Oscillations per second for Z
};

export class BalloonsAnimationHandler extends AnimationHandler {
  constructor(data, isDebug) {
    super(data, isDebug);
    this.animationStartTime = performance.now();
    this.animationDuration = 3000; // Default = 3 seconds
    this.totalVerticalDistance = 0.15;
  }

  init(core, panel, options = {}) {
    super.init(core, panel, {...defaultOptions, ...options});
  }

  onBeforePlay() {
    this.animationStartTime = performance.now();

    for (let i = 0; i < this.data.length; ++i) {
      let original = this.data[i].position;
      if (original) {
        this.animationViews[i].modelView.position.copy({
          x: original.x + (Math.random() - 0.5),
          y: original.y + (Math.random() - 0.5),
          z: original.z + (Math.random() - 0.5),
        });
      }

      // update binded data
      this.animationViews[i].updateOptions({
        oscillationAmplitude:
          defaultOptions.oscillationAmplitude + (Math.random() - 0.5) * 0.2,
        oscillationFrequencyX:
          defaultOptions.oscillationFrequencyX + (Math.random() - 0.5) * 0.2,
        oscillationFrequencyZ:
          defaultOptions.oscillationFrequencyZ + (Math.random() - 0.5) * 0.2,
      });
    }
  }

  onBeforeUpdate() {
    const currentTime = performance.now();
    const elapsedTime = currentTime - this.animationStartTime;
    const progress = Math.min(1, elapsedTime / this.animationDuration); // Normalized progress (0 to 1)

    this.animationViews.forEach((viewData) => {
      const mv = viewData.modelView;
      const startY = mv.position.y || 0; // Use current Y if animation restarts

      const opt = viewData.options;

      // Vertical movement
      mv.position.y = startY + this.totalVerticalDistance * progress;

      // Horizontal oscillation
      const time = currentTime * 0.001; // Convert milliseconds to seconds
      mv.position.x +=
        Math.sin(time * opt.oscillationFrequencyX * Math.PI * 2) *
        opt.oscillationAmplitude *
        progress;
      mv.position.z +=
        Math.cos(time * opt.oscillationFrequencyZ * Math.PI * 2) *
        opt.oscillationAmplitude *
        progress;
    });
  }
}

```
File: `demos/xremoji/GestureDetectionHandler.js`
```javascript
// TensorflowJS + WebGpu backend
import * as tf from '@tensorflow/tfjs';
import {WebGPUBackend} from '@tensorflow/tfjs-backend-webgpu';

// LiteRt-eap
import {loadLiteRt, setWebGpuDevice} from '@litertjs/core';
import {runWithTfjsTensors} from '@litertjs/tfjs-interop';

//
// Constants for a custom gesture model
//
const HAND_JOINT_COUNT = 25;
const HAND_JOINT_IDX_CONNECTION_MAP = [
  [1, 2],
  [2, 3],
  [3, 4], // Thumb has 3 bones
  [5, 6],
  [6, 7],
  [7, 8],
  [8, 9], // Index finger has 4 bones
  [10, 11],
  [11, 12],
  [12, 13],
  [13, 14], // Middle finger has 4 bones
  [15, 16],
  [16, 17],
  [17, 18],
  [18, 19], // Ring finger has 4 bones
  [20, 21],
  [21, 22],
  [22, 23],
  [23, 24], // Little finger has 4 bones
];

const HAND_BONE_IDX_CONNECTION_MAP = [
  [0, 1],
  [1, 2], // Thumb has 2 angles
  [3, 4],
  [4, 5],
  [5, 6], // Index finger has 3 angles
  [7, 8],
  [8, 9],
  [9, 10], // Middle finger has 3 angles
  [11, 12],
  [12, 13],
  [13, 14], // Ring finger has 3 angles
  [15, 16],
  [16, 17],
  [17, 18], // Little finger has 3 angles
];

const UNKNOWN_GESTURE = 7;

class LatestTaskQueue {
  constructor() {
    this.latestTask = null;
    this.isProcessing = false;
  }

  enqueue(task) {
    if (typeof task !== 'function') {
      console.error('Task must be a function.');
      return;
    }
    this.latestTask = task;
    if (!this.isProcessing) {
      this.processLatestTask();
    }
  }

  processLatestTask() {
    if (this.latestTask) {
      this.isProcessing = true;
      const taskToProcess = this.latestTask;
      this.latestTask = null; // Clear the reference immediately

      // Execute the task asynchronously using setTimeout (or queueMicrotask)
      setTimeout(async () => {
        try {
          await taskToProcess(); // If the task is async
        } catch (error) {
          console.error('Error processing latest task:', error);
        } finally {
          this.isProcessing = false;
          if (this.latestTask) {
            this.processLatestTask();
          }
        }
      }, 0); // Delay of 0ms puts it in the event queue
    }
  }

  getSize() {
    return this.latestTask === null ? 0 : 1;
  }

  isEmpty() {
    return this.latestTask === null;
  }
}

export class GestureDetectionHandler {
  constructor() {
    // model
    this.modelPath = './custom_gestures_model.tflite';
    this.modelState = 'None';

    //
    // left and right hand queues
    this.queue = [];
    this.queue.push(new LatestTaskQueue());
    this.queue.push(new LatestTaskQueue());

    setTimeout(() => {
      this.setBackendAndLoadModel();
    }, 1);
  }

  //
  // set TF.js backend and load tflite model
  //
  async setBackendAndLoadModel() {
    this.modelState = 'Loading';
    try {
      await tf.setBackend('webgpu');
      await tf.ready();

      // Initialize LiteRT.js's WASM files
      const wasmPath = 'https://unpkg.com/@litertjs/core@0.2.1/wasm/';
      const liteRt = await loadLiteRt(wasmPath);

      // Make LiteRt use the same GPU device as TFJS (for tensor conversion)
      const backend = tf.backend(); // as WebGPUBackend;
      setWebGpuDevice(backend.device);

      // Load model via LiteRt
      await this.loadModel(liteRt);

      if (this.model) {
        // print model details to the log
        console.log('MODEL DETAILS: ', this.model.getInputDetails());
      }
      this.modelState = 'Ready';
    } catch (error) {
      console.error('Failed to load model or backend:', error);
    }
  }

  async loadModel(liteRt) {
    try {
      this.model = await liteRt.loadAndCompile(this.modelPath, {
        // Currently, only 'webgpu' is supported
        accelerator: 'webgpu',
      });
    } catch (error) {
      this.model = null;
      console.error('Error loading model:', error);
    }
  }

  calculateRelativeHandBoneAngles(jointPositions) {
    // Reshape jointPositions
    let jointPositionsReshaped = [];

    jointPositionsReshaped = jointPositions.reshape([HAND_JOINT_COUNT, 3]);

    // Calculate bone vectors
    const boneVectors = [];
    HAND_JOINT_IDX_CONNECTION_MAP.forEach(([joint1, joint2]) => {
      const boneVector = jointPositionsReshaped
        .slice([joint2, 0], [1, 3])
        .sub(jointPositionsReshaped.slice([joint1, 0], [1, 3]))
        .squeeze();
      const norm = boneVector.norm();
      const normalizedBoneVector = boneVector.div(norm);
      boneVectors.push(normalizedBoneVector);
    });

    // Calculate relative hand bone angles
    const relativeHandBoneAngles = [];
    HAND_BONE_IDX_CONNECTION_MAP.forEach(([bone1, bone2]) => {
      const angle = boneVectors[bone1].dot(boneVectors[bone2]);
      relativeHandBoneAngles.push(angle);
    });

    // Stack the angles into a tensor
    return tf.stack(relativeHandBoneAngles);
  }

  async detectGesture(handJoints) {
    if (!this.model || !handJoints || handJoints.length !== 25 * 3) {
      console.log('Invalid hand joints or model load error.');
      return UNKNOWN_GESTURE;
    }

    try {
      const tensor = this.calculateRelativeHandBoneAngles(
        tf.tensor1d(handJoints)
      );

      let tensorReshaped = tensor.reshape([
        1,
        HAND_BONE_IDX_CONNECTION_MAP.length,
        1,
      ]);
      var result = -1;

      result = runWithTfjsTensors(this.model, tensorReshaped);

      let integerLabel = result[0].as1D().arraySync();
      if (integerLabel.length == 7) {
        let x = integerLabel[0];
        let idx = 0;
        for (let t = 0; t < 7; ++t) {
          if (integerLabel[t] > x) {
            idx = t;
            x = integerLabel[t];
          }
        }
        return idx;
      }
    } catch (error) {
      console.error('Error:', error);
    }
    return UNKNOWN_GESTURE;
  }

  //
  // Clone joints and post queue task
  //
  postTask(joints, handIndex) {
    if (Object.keys(joints).length !== 25) {
      return UNKNOWN_GESTURE;
    }

    let handJointPositions = [];
    for (const i in joints) {
      handJointPositions.push(joints[i].position.x);
      handJointPositions.push(joints[i].position.y);
      handJointPositions.push(joints[i].position.z);
    }

    if (handJointPositions.length !== 25 * 3) {
      return UNKNOWN_GESTURE;
    }

    if (handIndex >= 0 && handIndex < this.queue.length) {
      this.queue[handIndex].enqueue(async () => {
        let result = await this.detectGesture(handJointPositions);
        //
        // Check if thumb is up
        //
        if (result === 2 && !this.isThumbUp(handJointPositions, 2, 3, 4)) {
          result = 0;
        }
        if (this.observer && this.observer.onGestureDetected) {
          this.observer.onGestureDetected(handIndex, result);
        }
      });
    }
  }

  isThumbUp(d1, p1, p2, p3) {
    return this.isThumbUpSimple(d1, p1, p3);
  }

  isThumbUpAdvanced(data, p1, p2, p3) {
    // Assuming p1 is the base of the thumb, p2 is the knuckle, and p3 is the tip.

    // Vector from base to knuckle
    const v1 = {
      x: data[p2 * 3] - data[p1 * 3],
      y: data[p2 * 3 + 1] - data[p1 * 3 + 1],
      z: data[p2 * 3 + 2] - data[p1 * 3 + 2],
    };

    // Vector from knuckle to tip
    const v2 = {
      x: data[p3 * 3] - data[p2 * 3],
      y: data[p3 * 3 + 1] - data[p2 * 3 + 1],
      z: data[p3 * 3 + 2] - data[p2 * 3 + 2],
    };

    // Calculate the angle between the two vectors using the dot product
    const dotProduct = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;

    // Calculate the magnitudes (lengths) of the vectors
    const magnitudeV1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
    const magnitudeV2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);

    // Avoid division by zero if either vector has zero length
    if (magnitudeV1 === 0 || magnitudeV2 === 0) {
      return false; // Cannot determine angle if segments have zero length
    }

    // Calculate the cosine of the angle
    const cosAngle = dotProduct / (magnitudeV1 * magnitudeV2);

    // Get the angle in radians
    const angleRadians = Math.acos(Math.max(-1, Math.min(1, cosAngle))); // Clamp to handle potential floating-point errors

    // Convert the angle to degrees
    const angleDegrees = angleRadians * (180 / Math.PI);

    // Define a threshold angle for what we consider "thumb up".
    // This value might need adjustment based on your specific application and data.
    const thumbUpThreshold = 90; // Example: If the angle is greater than 90 degrees, it's considered "up"

    // In a typical "thumb up" gesture, the angle between the base-knuckle segment
    // and the knuckle-tip segment would be relatively straight or even slightly bent backward.
    // Therefore, we are looking for an angle close to 180 degrees or greater than 90.

    return angleDegrees > thumbUpThreshold;
  }

  isThumbUpSimple(data, p1, p2) {
    // Assuming p1 is the base of the thumb and p2 is the tip.

    // Vector from base to tip
    const vector = {
      x: data[p2 * 3] - data[p1 * 3],
      y: data[p2 * 3 + 1] - data[p1 * 3 + 1],
      z: data[p2 * 3 + 2] - data[p1 * 3 + 2],
    };

    // Calculate the magnitude of the vector
    const magnitude = Math.sqrt(
      vector.x * vector.x + vector.y * vector.y + vector.z * vector.z
    );

    // If the magnitude is very small, it's likely not a significant gesture
    if (magnitude < 0.001) {
      return false;
    }

    // Normalize the vector to get its direction
    const normalizedVector = {
      x: vector.x / magnitude,
      y: vector.y / magnitude,
      z: vector.z / magnitude,
    };

    // Define the "up" direction vector (positive Y-axis)
    const upVector = {x: 0, y: 1, z: 0};

    // Calculate the dot product between the normalized thumb vector and the up vector
    const dotProduct =
      normalizedVector.x * upVector.x +
      normalizedVector.y * upVector.y +
      normalizedVector.z * upVector.z;

    // The dot product of two normalized vectors is equal to the cosine of the angle between them.
    // An angle of 45 degrees has a cosine of approximately Math.cos(Math.PI / 4) or ~0.707.
    // We want the angle to be within 45 degrees of the vertical "up" direction.
    // This means the cosine of the angle should be greater than or equal to cos(45 degrees).

    const cos45Degrees = Math.cos((45 * Math.PI) / 180); // Approximately 0.707

    return dotProduct >= cos45Degrees;
  }

  registerObserver(observer) {
    this.observer = observer;
  }
}

```
File: `demos/xremoji/MeetEmoji.js`
```javascript
import * as THREE from 'three';
import * as xb from 'xrblocks';

import {AnimationHandler} from './AnimationHandler.js';
import {BalloonsAnimationHandler} from './BallloonsAnimationHandler.js';
import {GestureDetectionHandler} from './GestureDetectionHandler.js';

const LEFT_HAND_INDEX = 0;
const RIGHT_HAND_INDEX = 1;

const PROPRIETARY_ASSETS_PATH =
  'https://cdn.jsdelivr.net/gh/xrblocks/proprietary-assets@main/';

const BALLOONS_MODELS = [
  {
    model: {
      scale: {x: 1, y: 1, z: 1},
      rotation: {x: 0, y: 0, z: 0},
      path: PROPRIETARY_ASSETS_PATH + 'balloons/',
      model: 'scene.gltf',
      verticallyAlignObject: true,
    },
    position: {x: 4, y: -1.2, z: -5},
  },
  {
    model: {
      scale: {x: 1, y: 1, z: 1},
      rotation: {x: 0, y: 0, z: 0},
      path: PROPRIETARY_ASSETS_PATH + 'balloons/',
      model: 'scene.gltf',
      verticallyAlignObject: true,
    },
    position: {x: 0, y: -1, z: -5},
  },
  {
    model: {
      scale: {x: 1, y: 1, z: 1},
      rotation: {x: 0, y: 0, z: 0},
      path: PROPRIETARY_ASSETS_PATH + 'balloons/',
      model: 'scene.gltf',
      verticallyAlignObject: true,
    },
    position: {x: -4, y: -1.2, z: -5},
  },
];

const VICTORY_MODELS = [
  {
    model: {
      scale: {x: 0.05, y: 0.05, z: 0.05},
      rotation: {x: 0, y: 0, z: 0},
      scene_position: {x: 0, y: 0, z: 0},
      path: PROPRIETARY_ASSETS_PATH + 'Confetti/',
      model: 'scene.gltf',
      verticallyAlignObject: true,
    },
    position: {x: 34, y: -15, z: 15},
  },
  {
    model: {
      scale: {x: 0.05, y: 0.05, z: 0.05},
      rotation: {x: 0, y: 0, z: 0},
      scene_position: {x: 0, y: 0, z: 0},
      path: PROPRIETARY_ASSETS_PATH + 'Confetti/',
      model: 'scene.gltf',
      verticallyAlignObject: true,
    },
    position: {x: -34, y: -15, z: 15},
  },
];

export class MeetEmoji extends xb.Script {
  constructor() {
    super();
    // Loads data.
    this.handGesture = [0, 0];

    this.playBalloonsOnUpdate = false;
    this.playConfettiOnUpdate = false;

    //
    // Initializes UI.
    //
    {
      // Make a root panel>grid>row>controlPanel>grid
      const panel = new xb.SpatialPanel({
        backgroundColor: '#00000000',
        useDefaultPosition: false,
        showEdge: false,
      });
      panel.scale.set(panel.width, panel.height, 1);
      panel.isRoot = true;
      this.add(panel);

      const grid = panel.addGrid();
      // Add blank space on top of the ctrlPanel
      grid.addRow({weight: 0.4});

      // Space for orbiter
      grid.addRow({weight: 0.1});
      // control row
      const controlRow = grid.addRow({weight: 0.5});
      const ctrlPanel = controlRow.addPanel({backgroundColor: '#000000bb'});

      const ctrlGrid = ctrlPanel.addGrid();
      {
        // middle column
        const midColumn = ctrlGrid.addCol({weight: 0.9});

        // top indentation
        midColumn.addRow({weight: 0.3});

        const gesturesRow = midColumn.addRow({weight: 0.4});

        // left indentation
        gesturesRow.addCol({weight: 0.05});

        const textCol = gesturesRow.addCol({weight: 1.0});
        textCol.addRow({weight: 1.0}).addText({
          text: 'Give the victory or thumbs-up gestures a try!',
          fontColor: '#ffffff',
          fontSize: 0.05,
        });

        // right indentation
        gesturesRow.addCol({weight: 0.01});

        // bottom indentation
        midColumn.addRow({weight: 0.1});
      }

      const orbiter = ctrlGrid.addOrbiter();
      orbiter.addExitButton();

      panel.updateLayouts();

      this.panel = panel;

      // Animated models
      this.victoryHandler = new AnimationHandler(VICTORY_MODELS);
      this.balloonsHandler = new BalloonsAnimationHandler(BALLOONS_MODELS);

      // Gesture detector
      this.gestureDetectionHandler = new GestureDetectionHandler();
      this.gestureDetectionHandler.registerObserver(this);
    }

    this.frameId = 0;
  }

  onGestureDetected(handIndex, result) {
    if (this.handGesture[handIndex] !== result) {
      if (result === 4) {
        if (!this.victoryHandler.isPlaying) this.playConfettiOnUpdate = true;
      } else if (result === 2) {
        if (!this.balloonsHandler.isPlaying) this.playBalloonsOnUpdate = true;
      }

      // Stub for gesture completion handler
      if (
        this.handGesture[handIndex] === 4 ||
        this.handGesture[handIndex] === 2
      ) {
        this.onGestureStopped(handIndex, this.handGesture[handIndex]);
      }
      this.handGesture[handIndex] = result;
    }
  }

  onGestureStopped(handIndex, gestureIndex) {
    // TODO: we could hide animation on gesture stop
  }

  /**
   * Initializes the PaintScript.
   */
  init() {
    xb.core.renderer.localClippingEnabled = true;

    this.add(new THREE.HemisphereLight(0x888877, 0x777788, 3));
    const light = new THREE.DirectionalLight(0xffffff, 5.0);
    light.position.set(-0.5, 4, 1.0);
    this.add(light);

    this.panel.position.set(0, 1.2, -1.0);

    this.victoryHandler.init(xb.core, this.panel);
    this.balloonsHandler.init(xb.core, this.panel);
  }

  /**
   * Moves the painter to the pivot position when select starts.
   * @param {XRInputSourceEvent} event
   */
  onSelectStart(event) {}

  /**
   * Updates the painter's line to the current pivot position during selection.
   * @param {number} id The controller id.
   */
  onSelecting(id) {}

  async update() {
    if (this.playConfettiOnUpdate) {
      this.victoryHandler.play(3000);
      this.playConfettiOnUpdate = false;
    }

    if (this.playBalloonsOnUpdate) {
      this.balloonsHandler.play(3000);
      this.playBalloonsOnUpdate = false;
    }

    if (this.balloonsHandler) {
      this.balloonsHandler.onBeforeUpdate();
    }

    // Run gesture detection 12 times per second for ~60fps
    // But an avg fps for webxr is 30-60
    if (this.frameId % 5 === 0 || false) {
      const hands = xb.core.user.hands;
      if (hands != null && hands.hands && hands.hands.length == 2) {
        this.gestureDetectionHandler.postTask(
          hands.hands[LEFT_HAND_INDEX].joints,
          LEFT_HAND_INDEX
        );
        this.gestureDetectionHandler.postTask(
          hands.hands[RIGHT_HAND_INDEX].joints,
          RIGHT_HAND_INDEX
        );
      }
    }

    this.frameId++;
  }
}

```
File: `demos/xremoji/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <title>Meet emoji</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    
    
    
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "@tensorflow/tfjs-core": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core/+esm",
          "@tensorflow/tfjs": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/+esm",
          "@tensorflow/tfjs-backend-webgpu": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu/+esm",
          "@litertjs/core": "https://unpkg.com/@litertjs/core@0.2.1",
          "@litertjs/tfjs-interop": "https://unpkg.com/@litertjs/tfjs-interop@1.0.1",
          "@litertjs/wasm-utils": "https://unpkg.com/@litertjs/wasm-utils@0.2.1",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `demos/xremoji/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {MeetEmoji} from './MeetEmoji.js';

const options = new xb.Options({
  antialias: true,
  reticles: {enabled: true},
  visualizeRays: false,
  hands: {enabled: true, visualization: true},
  simulator: {defaultMode: xb.SimulatorMode.POSE},
});

async function start() {
  xb.add(new MeetEmoji());
  options.setAppTitle('XR Emoji');
  await xb.init(options);
}

document.addEventListener('DOMContentLoaded', function () {
  setTimeout(function () {
    start();
  }, 200);
});

```


### Demo: xrpoet
File: `demos/xrpoet/PoemGenerator.js`
```javascript
import * as xb from 'xrblocks';

export class PoemGenerator extends xb.Script {
  constructor() {
    super();
    this.panel = null;
    this.isProcessing = false;
    this.responseDisplay = null;
  }

  init() {
    this.ai = xb.core.ai;
    this.deviceCamera = xb.core.deviceCamera;

    this.createPanel();
  }

  createPanel() {
    this.panel = new xb.SpatialPanel({
      width: 2.0,
      height: 1.25,
      backgroundColor: '#1a1a1abb',
    });
    this.panel.position.set(0, 1.6, -2);
    this.add(this.panel);

    const grid = this.panel.addGrid();

    const responseRow = grid.addRow({weight: 0.9});
    this.responseDisplay = new xb.ScrollingTroikaTextView({
      text: '',
      fontSize: 0.03,
    });
    responseRow.add(this.responseDisplay);

    const buttonRow = grid.addRow({weight: 0.2});

    const videoRow = grid.addRow({weight: 0.7});
    this.videoView = new xb.VideoView({
      width: 1.0,
      height: 1.0,
      mode: 'stretch',
    });
    videoRow.add(this.videoView);

    const buttonPanel = buttonRow.addPanel({
      backgroundColor: '#00000000',
      showEdge: false,
    });
    buttonPanel.addGrid().addIconButton({
      text: 'photo_camera',
      fontSize: 0.6,
      backgroundColor: '#FFFFFF',
      defaultOpacity: 0.2,
      hoverOpacity: 0.8,
      selectedOpacity: 1.0,
    }).onTriggered = () => this.captureAndGeneratePoem();

    if (this.deviceCamera) {
      this.videoView.load(this.deviceCamera);
    }
  }

  async captureAndGeneratePoem() {
    if (this.isProcessing || !this.ai?.isAvailable()) return;
    this.isProcessing = true;

    const snapshot = this.deviceCamera.getSnapshot({outputFormat: 'base64'});
    if (!snapshot) {
      throw new Error('Failed to capture video snapshot.');
    }
    const {strippedBase64, mimeType} = xb.parseBase64DataURL(snapshot);
    const image = {inlineData: {mimeType: mimeType, data: strippedBase64}};
    const question =
      'Can you write a 12 lined, lighthearted poem about what you see?';
    const parts = [image, {text: question}];

    try {
      const response = await this.ai.query({
        type: 'multiPart',
        parts: parts,
      });
      this.responseDisplay.addText(`${response.text}\n\n`);
    } catch (error) {
      this.responseDisplay.addText(`Error: ${error.message}\n\n`);
    }

    this.isProcessing = false;
  }
}

```
File: `demos/xrpoet/index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    
    
    <title>Gemini Poem Generator</title>
    <link type="text/css" rel="stylesheet" href="../../samples/main.css" />
    <script>
      window.litDisableBundleWarning = true;
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "troika-three-text": "https://cdn.jsdelivr.net/gh/protectwise/troika@028b81cf308f0f22e5aa8e78196be56ec1997af5/packages/troika-three-text/src/index.js",
          "troika-three-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-three-utils/src/index.js",
          "troika-worker-utils": "https://cdn.jsdelivr.net/gh/protectwise/troika@v0.52.4/packages/troika-worker-utils/src/index.js",
          "bidi-js": "https://esm.sh/bidi-js@%5E1.0.2?target=es2022",
          "webgl-sdf-generator": "https://esm.sh/webgl-sdf-generator@1.1.1/es2022/webgl-sdf-generator.mjs",
          "lit": "https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js",
          "lit/": "https://esm.run/lit@3/",
          "xrblocks": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/xrblocks.js",
          "xrblocks/addons/": "https://cdn.jsdelivr.net/npm/xrblocks@0.9.0/build/addons/",
          "@google/genai": "https://cdn.jsdelivr.net/npm/@google/genai/+esm"
        }
      }
    </script>
  </head>

  <body>
    <script type="module" src="main.js"></script>
  </body>
</html>

```
File: `demos/xrpoet/main.js`
```javascript
import 'xrblocks/addons/simulator/SimulatorAddons.js';

import * as xb from 'xrblocks';

import {PoemGenerator} from './PoemGenerator.js';

const options = new xb.Options();
options.enableUI();
options.enableAI();
options.enableCamera();
options.setAppTitle('XR Poet');

function start() {
  try {
    xb.init(options);
    xb.add(new PoemGenerator());
  } catch (error) {
    console.error('Failed to initialize XR app:', error);
  }
}

document.addEventListener('DOMContentLoaded', function () {
  start();
});

```

--------------------------------------------------------------------------------
üî¥ FINAL CHECK: IMPORT MAP AND xb.Script
Before finishing the response, DOUBLE CHECK the `<script type="importmap">`.
You **MUST** include ALL the imports defined in Rule #1 (SDK Integration) and Rule #2.
Ensure `three`, `three/addons/`, `troika-three-text`, `lit`, `xrblocks`, **`xrblocks/addons/`** are present and point to the URLs specified above.
Ensure to write everything as XR Blocks Script as xb.script.
--------------------------------------------------------------------------------
After writing code, RECHECK THE TOP 10 RULES and REVISE code.
Do NOT hullicinate other xrblocks versions.
